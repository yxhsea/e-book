<html class="cye-disabled cye-lm"><head><meta charset="utf-8"><link rel="apple-touch-icon" sizes="180x180" href="http://static001.geekbang.org/static/icon/time/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="http://static001.geekbang.org/static/icon/time/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="http://static001.geekbang.org/static/icon/time/favicon-16x16.png"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover"><meta name="format-detection" content="telephone=no"><title>05 | 数组：为什么很多编程语言中数组都从0开始编号？</title><link href="https://static001.geekbang.org/static/time/css/app.b230db929e53af87acd535637f5011b8.css" rel="stylesheet"><style id="nightModeStyle">    html.cye-enabled.cye-nm:not(*:-webkit-full-screen) body,html.cye-enabled.cye-nm:not(*:-webkit-full-screen) #cye-workaround-body {-webkit-filter:contrast(91%) brightness(84%) invert(1);}</style><style id="cyebody">html.cye-enabled.cye-lm body{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyediv">html.cye-enabled.cye-lm div{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyetable">html.cye-enabled.cye-lm th{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}html.cye-enabled.cye-lm td{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyetextInput">html.cye-enabled.cye-lm input[type=text]{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}html.cye-enabled.cye-lm textarea{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyeselect">html.cye-enabled.cye-lm select{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyeul">html.cye-enabled.cye-lm ul{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyeChangeByClick">html.cye-enabled.cye-lm .cye-lm-tag,html.cye-enabled.cye-lm.cye-lm-tag{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style type="text/css">    .hljs-ln {      border-collapse: collapse    }    .hljs-ln td {      padding: 0    }    .hljs-ln-n:before {      content: attr(data-line-number)    }</style><style type="text/css">    #iv-container {      position: fixed;      background: #0d0d0d;      width: 100%;      height: 100%;      top: 0;      left: 0;      display: none;      z-index: 1000    }    .iv-container {      overflow: hidden    }    .iv-close {      width: 26px;      height: 26px;      position: absolute;      right: 20px;      top: 20px;      cursor: pointer;      text-align: center;      overflow: hidden;      text-shadow: 0 0 3px #6d6d6d;      -webkit-transition: all .2s ease;      -moz-transition: all ease .2s;      -o-transition: all ease .2s;      transition: all .2s ease    }    .iv-close:after,    .iv-close:before {      content: "";      height: 2px;      width: 26px;      background: #fff;      position: absolute;      left: 0;      top: 50%;      margin-top: -2px;      border-radius: 2px    }    .iv-close:before {      -webkit-transform: rotate(45deg);      -moz-transform: rotate(45deg);      -ms-transform: rotate(45deg);      -o-transform: rotate(45deg);      transform: rotate(45deg)    }    .iv-close:after {      -webkit-transform: rotate(-45deg);      -moz-transform: rotate(-45deg);      -ms-transform: rotate(-45deg);      -o-transform: rotate(-45deg);      transform: rotate(-45deg)    }    .iv-close:hover {      -webkit-transform: rotate(90deg);      -moz-transform: rotate(90deg);      -ms-transform: rotate(90deg);      -o-transform: rotate(90deg);      transform: rotate(90deg)    }    .iv-image-view {      position: absolute;      height: 100%;      width: 100%    }    .iv-image-wrap {      display: inline-block    }    .iv-image-wrap:active {      cursor: move    }    .iv-large-image {      cursor: move;      max-width: 100%;      max-height: 100%;      background-color: #ececec;      -moz-transform: translateZ(0);      -o-transform: translateZ(0)    }    .iv-large-image,    .iv-loader {      position: absolute;      -webkit-transform: translateZ(0);      -ms-transform: translateZ(0);      transform: translateZ(0)    }    .iv-loader {      top: 50%;      left: 50%;      border-radius: 50%;      width: 32px;      height: 32px;      z-index: 100;      margin-top: -16px;      margin-left: -16px;      font-size: 5px;      text-indent: -9999em;      border-top: 1em solid hsla(0, 0%, 100%, .2);      border-right: 1em solid hsla(0, 0%, 100%, .2);      border-bottom: 1em solid hsla(0, 0%, 100%, .2);      border-left: 1em solid #fff;      -webkit-animation: load8 1.1s infinite linear;      animation: load8 1.1s infinite linear    }    .iv-loader:after {      width: 10em;      height: 10em;      border-radius: 50%    }    @-webkit-keyframes load8 {      0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg)      }      to {        -webkit-transform: rotate(1turn);        transform: rotate(1turn)      }    }    @keyframes load8 {      0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg)      }      to {        -webkit-transform: rotate(1turn);        transform: rotate(1turn)      }    }</style><style type="text/css">    .vue-pull-to-wrapper[data-v-12abd9fb] {      display: -webkit-box;      display: -webkit-flex;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -webkit-flex-direction: column;      flex-direction: column;      height: 100%    }    .scroll-container[data-v-12abd9fb] {      -webkit-box-flex: 1;      -webkit-flex: 1;      flex: 1;      overflow-y: auto;      -webkit-overflow-scrolling: touch    }    .vue-pull-to-wrapper .action-block[data-v-12abd9fb] {      position: relative;      width: 100%    }    .default-text[data-v-12abd9fb] {      height: 100%;      line-height: 50px;      text-align: center    }</style><style type="text/css">    .button-cancel[data-v-87ffcada] {      color: #888;      border: 1px solid #888;      border-radius: 3px;      margin-right: 12px    }    .button-cancel[data-v-87ffcada],    .button-primary[data-v-87ffcada] {      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      height: 35px;      display: inline-block;      font-size: 15px;      text-align: center;      line-height: 36px    }    .button-primary[data-v-87ffcada] {      color: #fff;      background-color: #ff5a05;      border-radius: 3px    }    .article[data-v-87ffcada] {      max-width: 46.25rem;      margin: 0 auto    }    .article .article-unavailable[data-v-87ffcada] {      color: #fff;      text-align: center;      font-size: .875rem;      font-weight: 400;      width: 100%;      -webkit-box-sizing: border-box;      box-sizing: border-box;      padding: 0 15%;      height: 4.9rem;      background-image: url(data:image/jpeg;base64,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);      background-position: 0 0;      background-repeat: no-repeat;      background-size: cover;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: center;      -ms-flex-pack: center;      justify-content: center    }    .article .main[data-v-87ffcada] {      padding: 1.25rem 1.375rem;      margin-top: 52px;      margin-bottom: 52px    }    .article-title[data-v-87ffcada] {      color: #353535;      font-weight: 400;      line-height: 1.65rem;      font-size: 1.34375rem    }    .article-info[data-v-87ffcada] {      color: #888;      font-size: .9375rem;      margin-top: 1.0625rem    }    .article-content[data-v-87ffcada] {      margin-top: 1.0625rem    }    .article-content.android video[data-v-87ffcada]::-webkit-media-controls-fullscreen-button {      display: none    }    .audio-player[data-v-87ffcada] {      width: 100%;      margin: 20px 0    }    .to-comment[data-v-87ffcada] {      overflow: hidden;      margin-bottom: -30px    }    .to-comment a.button-primary[data-v-87ffcada] {      float: right;      height: 20px;      font-size: 12px;      line-height: 20px;      padding: 4px 8px;      cursor: pointer    }    .article-comments[data-v-87ffcada] {      margin-top: 2rem    }    .article-comments h2[data-v-87ffcada] {      text-align: center;      color: #888;      position: relative;      z-index: 1;      margin-bottom: 1rem    }    .article-comments h2[data-v-87ffcada]:before {      border-top: 1px dotted #888;      content: "";      position: absolute;      top: 56%;      left: 0;      width: 100%;      z-index: -1    }    .article-comments h2 span[data-v-87ffcada] {      font-size: 15.25px;      font-weight: 400;      padding: 0 1rem;      background: #fff;      display: inline-block    }    .article-sub-bottom[data-v-87ffcada] {      z-index: 10;      cursor: pointer    }    @media (max-width:769px) {      .article .breadcrumb[data-v-87ffcada] {        padding: 10px 0      }    }</style><style type="text/css">    .share-poster-wrapper {      position: fixed;      background-color: #fff;      left: 0;      bottom: 0;      z-index: 100;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      overflow: hidden;      width: 100%;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -moz-user-select: -moz-none;      -webkit-user-select: none;      -ms-user-select: none;      user-select: none    }    .share-poster-wrapper .poster-bottom,    .share-poster-wrapper .poster-middle,    .share-poster-wrapper .poster-top {      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .poster-middle {      padding: 16px 32px;      -webkit-box-sizing: border-box;      box-sizing: border-box    }    .share-poster-wrapper .poster-middle .poster-userinfo {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      padding-bottom: 18px    }    .share-poster-wrapper .poster-middle .poster-userinfo .poster-avatar {      min-width: 45px;      min-height: 45px;      width: 7vw;      height: 7vw;      border-radius: 50%;      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .poster-middle .nickname {      font-size: 5vw;      font-weight: 400;      margin-left: 18px    }    .share-poster-wrapper .poster-middle .time {      font-size: 3.2vw    }    .share-poster-wrapper .poster-middle .poster-middle-content {      font-size: 4vw;      font-weight: 400;      white-space: normal;      word-wrap: break-word;      word-break: break-word;      letter-spacing: 1px    }    .share-poster-wrapper .poster-middle .poster-middle-content p {      margin-bottom: 22px    }    .share-poster-wrapper .poster-middle .quote-content {      font-size: 3.7vw;      padding: 32px 0    }    .share-poster-wrapper .poster-middle .quote-content p {      margin-bottom: 22px    }    .share-poster-wrapper .poster-middle .quote-info {      border-left: 1px solid #000;      padding-left: 10px;      margin-top: 38px    }    .share-poster-wrapper .poster-middle .quote-info p {      font-size: 3.2vw;      line-height: 1.5    }    .share-poster-wrapper.theme0 .poster-top {      width: 100%;      height: 25px;      margin-top: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/top.png") no-repeat 15px 1px    }    .share-poster-wrapper.theme0 .poster-middle {      width: 100%;      padding-left: 56px;      padding-right: 56px;      background-image: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/middle.png");      background-repeat: repeat-y;      background-position: 15px 0    }    .share-poster-wrapper.theme0 .poster-middle .time {      margin-bottom: 45px    }    .share-poster-wrapper.theme0 .poster-middle .quote-content {      border-top: 1px solid #e3e1dc;      margin-top: 30px    }    .share-poster-wrapper.theme0 .poster-bottom {      width: 100%;      height: 25px;      margin-bottom: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/bottom.png") no-repeat 15px -10px    }    .share-poster-wrapper.theme1 .poster-top {      width: 100%;      height: 25px;      margin-top: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/top.png") no-repeat 38px 1px    }    .share-poster-wrapper.theme1 .poster-middle {      width: 100%;      padding: 0 42px 10px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/middle.png") repeat-y 38px 0    }    .share-poster-wrapper.theme1 .poster-middle .poster-userinfo {      border-bottom: 1px solid #b5a899    }    .share-poster-wrapper.theme1 .poster-middle .poster-userinfo .poster-avatar {      margin-left: 38px    }    .share-poster-wrapper.theme1 .poster-middle .poster-middle-wrapper {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      min-height: 260px;      border-bottom: 1px solid #b5a899    }    .share-poster-wrapper.theme1 .poster-middle .time {      max-width: 65px;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -webkit-box-pack: center;      -ms-flex-pack: center;      justify-content: center;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      text-align: center;      vertical-align: middle;      border-right: 1px solid #b5a899    }    .share-poster-wrapper.theme1 .poster-middle .time span {      white-space: nowrap;      -webkit-transform: rotate(90deg);      transform: rotate(90deg)    }    .share-poster-wrapper.theme1 .poster-middle .poster-middle-content {      padding: 30px    }    .share-poster-wrapper.theme1 .poster-middle .quote-content {      font-size: 3.7vw;      margin-left: 36px;      margin-right: 36px    }    .share-poster-wrapper.theme1 .poster-middle .quote-info {      margin-left: 36px;      margin-right: 36px    }    .share-poster-wrapper.theme1 .poster-middle .footer {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      margin-right: 30px    }    .share-poster-wrapper.theme1 .poster-bottom {      width: 100%;      height: 25px;      margin-bottom: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/bottom.png") no-repeat 38px -10px    }    .share-poster-wrapper .share-poster {      background: #fefdf8;      -webkit-box-sizing: border-box;      box-sizing: border-box;      color: #9b8d73;      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      overflow: auto;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -webkit-overflow-scrolling: touch;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center    }    .share-poster-wrapper .share-poster.color0 {      background-color: #fefdf8    }    .share-poster-wrapper .share-poster.color1 {      background-color: #4d4d4d    }    .share-poster-wrapper .share-poster .footer {      margin-top: 2rem;      position: relative;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-pack: end;      -ms-flex-pack: end;      justify-content: flex-end;      -webkit-box-align: end;      -ms-flex-align: end;      align-items: flex-end    }    .share-poster-wrapper .share-poster .footer p {      margin: 0;      line-height: 1.4;      margin-left: 20px;      text-align: right;      padding-right: 20px    }    .share-poster-wrapper .controls {      background: #fff;      border-top: 1px solid #f5f5f5;      width: 100%;      padding-top: 5px;      -webkit-box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, .1);      box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, .1);      z-index: 1;      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .controls>div {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-pack: center;      -ms-flex-pack: center;      justify-content: center;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      padding: 10px 0    }    .share-poster-wrapper .controls>div span {      font-size: .85rem    }    .share-poster-wrapper .controls>div button {      width: 100px;      height: 24px;      background: #eee;      margin: 0 10px;      border-radius: 5px;      border: 2px solid #b2b2b2;      outline: none    }    .share-poster-wrapper .controls>div button.on {      border: 2px solid #ff5a05    }    .share-poster-wrapper .controls .controls-themes button {      color: #b2b2b2;      font-size: 12px;      background: #fff;      text-align: center    }    .share-poster-wrapper .controls .controls-themes button.on {      color: #ff5a05    }    .share-poster-wrapper .buttons {      background: #fff;      border-top: 1px solid #f5f5f5;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .buttons a {      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      text-align: center;      color: #000;      font-weight: 400;      height: 3rem;      line-height: 3rem    }    .share-poster-wrapper .buttons a:last-child {      border-left: 1px solid #f5f5f5    }    .share-poster-wrapper img {      max-width: 100%    }    .share-poster-wrapper.android .poster-middle .nickname {      font-size: 10vw    }    .share-poster-wrapper.android .poster-middle .time {      font-size: 6.4vw    }    .share-poster-wrapper.android .poster-middle .poster-middle-content {      font-size: 8vw    }    .share-poster-wrapper.android .poster-middle .quote-content {      font-size: 7.4vw    }    .share-poster-wrapper.android .poster-middle .quote-info p {      font-size: 6.4vw    }</style><style type="text/css">    .mobile-tips {      width: 100%;      height: 51px;      background: rgba(0, 0, 0, .8);      position: fixed;      top: 0;      left: 0;      z-index: 20;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: justify;      -ms-flex-pack: justify;      justify-content: space-between;      -webkit-box-sizing: border-box;      box-sizing: border-box;      padding: 0 12px;      -webkit-transition: opacity .35s;      transition: opacity .35s;      opacity: 0;      pointer-events: none    }    .mobile-tips.istop {      opacity: 1;      pointer-events: auto    }    .mobile-tips .mobile-tips-info {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: start;      -ms-flex-pack: start;      justify-content: flex-start    }    .mobile-tips .mobile-tips-info i {      width: 36px;      height: 36px;      background-image: url(data:image/png;base64,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);      background-position: 0 0;      background-repeat: no-repeat;      background-size: contain;      border-radius: 7px    }    .mobile-tips .mobile-tips-info h2 {      font-size: 15px;      color: #fff;      font-weight: 400;      margin-left: 6px    }    .mobile-tips .mobile-tips-info h2 span {      font-size: 11px    }    .mobile-tips a {      width: 72px;      height: 31px;      text-align: center;      border: 1px solid #ff5a05;      border-radius: 3px;      font-size: 13px;      color: #ff5a05;      line-height: 31px    }</style><style type="text/css">    .mini-audio-player {      width: 100%;      height: 5.25rem;      border: 1px solid #d9d9d9;      background: #fafafa;      -webkit-box-sizing: border-box;      box-sizing: border-box;      padding: 1rem;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: justify;      -ms-flex-pack: justify;      justify-content: space-between;      margin: 1rem 0    }    .mini-audio-player>a {      border: none;      -ms-flex-negative: 0;      flex-shrink: 0    }    .mini-audio-player .btn-play {      background-image: url(data:image/png;base64,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)    }    .mini-audio-player .btn-pause,    .mini-audio-player .btn-play {      width: 2.6875rem;      height: 2.6875rem;      background-repeat: no-repeat;      background-position: 0 0;      background-size: contain;      text-decoration: none    }    .mini-audio-player .btn-pause {      background-image: url(data:image/png;base64,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)    }    .mini-audio-player .audio-info {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      margin-left: .6875rem;      min-width: 0    }    .mini-audio-player .audio-info h3 {      color: #353535;      font-size: 15.25px;      margin: 0;      white-space: nowrap;      overflow: hidden;      text-overflow: ellipsis    }    .mini-audio-player .audio-info p {      margin: 0;      margin-top: .125rem;      font-size: 11px;      line-height: 1rem    }    .mini-audio-player .audio-info p span {      color: #888    }    .mini-audio-player .btn-download {      width: 1.25rem;      height: 1.25rem;      position: relative;      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA+CAYAAACbQR1vAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+IEmuOgAAA4hJREFUaIHtm8lOFFEUhr9qCWGHGxcaY1joK2h0YRzAtYmsWbAGGidEXOACbAYRxfgAPoEPoInGxJgg86gsJTHMw86EhS7O7TDk3uqq6qo6HahvQ7pOce7//1U0feve9vr6+lAiD3QC/4AC8FZDRJXGoMB14PWB1yPANPA1bSG5tAc0XLEcu5y6CvQCOGU5pnI3agVQMWQBaAvQJgtAW4A2WQDaArTJAtAWoE0WgLYAbbIAtAVokwWgLUCbLABtAdpkAfjU6oC7wKV0pCTCRcRDnesEVwDNwC/gg/nZHbeyFOgGltj30Gw7yRZALfAOqDavPeA50BO7xOToQTR75nU14qn26Im2AM4DNZbjz4DeePQlSi+i9Sg1iLdD2AJYApYdzbuo7BBeIBptLCPeDmELYA9oBHYdjbqQpaxKowA8ddR2gXuIt0O43gRHgTu4Q+ikskIoIJps7AINwA9b0e/fYJAQ1FZWD9CP2/wOUI/DPJT+IDRqGrhCeGIEaNEPdDhqO8iVH/NrEOST4BgSwo6j3gEMBOgTNwP4m6+nhHkI/lG4VAiPgcGAveJg0IxpYxvROh6kUZi5wLhpvO2oPyKdEF6asWyEMg/hJ0PjyN+VXwhDIXuGYQh46KhtIeYnwjSMMhss3glbjvoDkglhyPS2Eck8RJ8OTyB3gl8IryL2tjGM2/wmYn4ySuNyngdMmIE3HfX7iHDPUQ+CZ3q0O+qbyIWIZB7KfyAyaQS4QmhH7oQoIZQyv0EZV75IHE+EJvG/E9oJfyd4yC6yvKO+gQQ/FaKnlbgeiU0hIWw46nnEUJAQiubbHPV1M1bZ5iHeZ4KlQmgD3uAfgofsGfQz34DsKYyFuLemTSMhfATOWOqtiMk/llrRfIuj9zpwG5gtX+Y+SezNK4bwCXsILdgDaAXOOnomYh6Seyw+gwhed9TPWY75mb9FAuYh2XWBWUS4K4QgrAE3gblYFFlIemFkDjEQJYQ1JMD5WBUdIY2VoXkkhLUQv7NqfidR85De0liYEFaRK7+QqCJDmmuDC0gIqz7nrJhzUjEP6S+O+oWwglz5xTQFaawOLwI3gO8Hjo2ZY6maB72vzPwErgEXkO8MuVaiEkcrgCK/lcfPNkhkAWgL0KYKmZiMIG9Ktn0Bx5G/wDcgXwW8R6avJ41G4HQOufInlas5ZO5+UpnJAU3AFyy7J44xe8BnoOk/JruwYo92bigAAAAASUVORK5CYII=);      background-repeat: no-repeat;      background-position: 0 0;      background-size: contain;      text-decoration: none;      padding-right: .25rem    }    .mini-audio-player .btn-download .icon-download-done {      width: .45rem;      height: .45rem;      position: absolute;      bottom: 0;      right: 0;      display: inline-block;      background-image: url(data:image/png;base64,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);      background-repeat: no-repeat;      background-position: 0 0;      background-size: contain    }</style><style type="text/css">    .MathJax_Display {      overflow: auto    }    .poster {      position: fixed;      left: -10000px;      top: -10000px;      overflow: hidden;      padding: 1rem;      background: #ececec    }    .richcontent-pre-copy {      font-size: 13px;      color: #888;      position: absolute;      right: 1em;      top: .2em;      cursor: pointer;      -webkit-user-select: none;      -moz-user-select: none;      -ms-user-select: none;      user-select: none    }    .richcontent-pre-copy .iconfont {      font-size: 12px;      margin-right: .2em    }</style><style type="text/css">    .comment-item {      list-style-position: inside;      width: 100%;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      margin-bottom: 1rem    }    .comment-item a {      border-bottom: none    }    .comment-item .avatar {      width: 2.625rem;      height: 2.625rem;      -ms-flex-negative: 0;      flex-shrink: 0;      border-radius: 50%    }    .comment-item .info {      margin-left: .5rem;      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1    }    .comment-item .info .hd {      width: 100%;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-pack: justify;      -ms-flex-pack: justify;      justify-content: space-between;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center    }    .comment-item .info .hd .username {      color: #888;      font-size: 15.25px;      font-weight: 400;      line-height: 1.2    }    .comment-item .info .hd .control {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center    }    .comment-item .info .hd .control .btn-share {      color: #888;      font-size: .75rem;      margin-right: 1rem    }    .comment-item .info .hd .control .btn-praise {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      font-size: 15.25px;      text-decoration: none    }    .comment-item .info .hd .control .btn-praise i {      color: #888;      display: inline-block;      font-size: .75rem;      margin-right: .3rem;      margin-top: -.01rem    }    .comment-item .info .hd .control .btn-praise i.on,    .comment-item .info .hd .control .btn-praise span {      color: #ff5a05    }    .comment-item .info .bd {      color: #353535;      font-size: 15.25px;      font-weight: 400;      white-space: normal;      word-break: break-all;      line-height: 1.6    }    .comment-item .info .time {      color: #888;      font-size: 9px;      line-height: 1    }    .comment-item .info .reply .reply-hd {      font-size: 15.25px    }    .comment-item .info .reply .reply-hd span {      margin-left: -12px;      color: #888;      font-weight: 400    }    .comment-item .info .reply .reply-hd i {      color: #ff5a05;      font-size: 15.25px    }    .comment-item .info .reply .reply-content {      color: #353535;      font-size: 15.25px;      font-weight: 400;      white-space: normal;      word-break: break-all    }    .comment-item .info .reply .reply-time {      color: #888;      font-size: 9px    }</style><style type="text/css">    .breadcrumb {      padding: 30px 0;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -ms-flex-wrap: wrap;      flex-wrap: wrap;      background: #fff    }    .breadcrumb a.title {      color: #e57c39;      font-size: 15px;      font-weight: 400    }    .breadcrumb span.title {      color: #888;      font-size: 15px;      font-weight: 400    }    .breadcrumb .split {      color: #ccc;      font-size: 10px;      margin-right: 5px    }</style></head><body style=""><div id="app"><div data-v-87ffcada="" class="article"><div data-v-87ffcada="" class="main main-app" style="margin-top: 0px;"><h1 data-v-87ffcada="" class="article-title">          05 | 数组：为什么很多编程语言中数组都从0开始编号？</h1><div data-v-87ffcada="" class="article-info"><span data-v-87ffcada="">2018-10-01</span><span data-v-87ffcada="">王争</span></div><div data-v-87ffcada="" class="article-content typo common-content"><img data-v-87ffcada="" src="https://static001.geekbang.org/resource/image/d0/ec/d05de7616d91d99c3afe11ebd66497ec.jpg"><div data-v-87ffcada="" class="mini-audio-player"><a href="javascript:;" class="btn-play"></a><div class="audio-info"><h3>05 | 数组：为什么很多编程语言中数组都从0开始编号？</h3><p><span>朗读人：秭明&nbsp;&nbsp;&nbsp;</span><span>00:15:41 | 7365</span></p></div><audio title="05 | 数组：为什么很多编程语言中数组都从0开始编号？" src="https://res001.geekbang.org/resource/audio/5f/47/5fc6530ff4c95d755810e96393733847.mp3" controls="controls"></audio></div><div data-v-87ffcada="" id="article-content" class=""><div class="text">              <p>提到数组，我想你肯定不陌生，甚至还会自信地说，它很简单啊。</p><p>是的，在每一种编程语言中，基本都会有数组这种数据类型。不过，它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。尽管数组看起来非常基础、简单，但是我估计很多人都并没有理解这个基础数据结构的精髓。</p><p>在大部分编程语言中，数组都是从0开始编号的，但你是否下意识地想过，<strong><span class="orange">为什么数组要从0开始编号，而不是从1开始呢？</span></strong> 从1开始不是更符合人类的思维习惯吗？</p><p>你可以带着这个问题来学习接下来的内容。</p><h2>如何实现随机访问？</h2><p>什么是数组？我估计你心中已经有了答案。不过，我还是想用专业的话来给你做下解释。<strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p><p>这个定义里有几个关键词，理解了这几个关键词，我想你就能彻底掌握数组的概念了。下面就从我的角度分别给你“点拨”一下。</p><p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p><p><img src="https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg" alt=""></p><p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg" alt=""></p><p>第二个是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><p>说到数据的访问，那你知道数组是如何实现根据下标随机访问数组元素的吗？</p><p>我们拿一个长度为10的int类型的数组int[] a = new int[10]来举例。在我画的这个图中，计算机给数组a[10]，分配了一块连续内存空间1000～1039，其中，内存块的首地址为base_address = 1000。</p><p><img src="https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg" alt=""></p><p>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><pre><code>a[i]_address = base_address + i * data_type_size
</code></pre><p>其中data_type_size表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是int类型数据，所以data_type_size就为4个字节。这个公式非常简单，我就不多做解释了。</p><p>这里我要特别纠正一个“错误”。我在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度O(1)；数组适合查找，查找时间复杂度为O(1)”。</p><p>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</p><h2>低效的“插入”和“删除”</h2><p>前面概念部分我们提到，数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。现在我们就来详细说一下，究竟为什么会导致低效？又有哪些改进方法呢？</p><p>我们先来看<strong>插入操作</strong>。</p><p>假设数组的长度为n，现在，如果我们需要将一个数据插入到数组中的第k个位置。为了把第k个位置腾出来，给新来的数据，我们需要将第k～n这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？你可以自己先试着分析一下。</p><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为(1+2+…n)/n=O(n)。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第k个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。</p><p>为了更好地理解，我们举一个例子。假设数组a[10]中存储了如下5个元素：a，b，c，d，e。</p><p>我们现在需要将元素x插入到第3个位置。我们只需要将c放入到a[5]，将a[2]赋值为x即可。最后，数组中的元素如下： a，b，x，d，e，c。</p><p><img src="https://static001.geekbang.org/resource/image/3f/dc/3f70b4ad9069ec568a2caaddc231b7dc.jpg" alt=""></p><p>利用这种处理技巧，在特定场景下，在第k个位置插入一个元素的时间复杂度就会降为O(1)。这个处理思想在快排中也会用到，我会在排序那一节具体来讲，这里就说到这儿。</p><p>我们再来看<strong>删除操作</strong>。</p><p>跟插入数据类似，如果我们要删除第k个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为O(1)；如果删除开头的数据，则最坏情况时间复杂度为O(n)；平均情况时间复杂度也为O(n)。</p><p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？</p><p>我们继续来看例子。数组a[10]中存储了8个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除a，b，c三个元素。</p><p><img src="https://static001.geekbang.org/resource/image/b6/e5/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg" alt=""></p><p>为了避免d，e，f，g，h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><p>如果你了解JVM，你会发现，这不就是JVM标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，<strong><span class="orange">很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的</span></strong>。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p><h2>警惕数组的访问越界问题</h2><p>了解了数组的几个基本操作后，我们来聊聊数组访问越界的问题。</p><p>首先，我请你来分析一下这段C语言代码的运行结果：</p><pre><code>int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i&lt;=3; i++){
        arr[i] = 0;
        printf(&quot;hello world\n&quot;);
    }
    return 0;
}
</code></pre><p>你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？</p><p>因为，数组大小为3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致for循环的结束条件错写为了i&lt;=3而非i&lt;3，所以当i=3时，数组a[3]访问越界。</p><p>我们知道，在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么a[3]=0就相当于i=0，所以就会导致代码无限循环。</p><p>数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p><p>这种情况下，一般都会出现莫名其妙的逻辑错误，就像我们刚刚举的那个例子，debug的难度非常的大。而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。</p><p>但并非所有的语言都像C一样，把数组越界检查的工作丢给程序员来做，像Java本身就会做越界检查，比如下面这几行Java代码，就会抛出java.lang.ArrayIndexOutOfBoundsException。</p><pre><code>int[] a = new int[3];
a[3] = 10;
</code></pre><h2>容器能否完全替代数组？</h2><p>针对数组类型，很多语言都提供了容器类，比如Java中的ArrayList、C++ STL中的vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？</p><p>这里我拿Java语言来举例。如果你是Java工程师，几乎天天都在用ArrayList，对它应该非常熟悉。那它与数组相比，到底有哪些优势呢？</p><p>我个人觉得，ArrayList最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。</p><p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为10的数组，当第11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</p><p>如果使用ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为1.5倍大小。</p><p>不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好<strong>在创建ArrayList的时候事先指定数据大小</strong>。</p><p>比如我们要从数据库中取出10000条数据放入ArrayList。我们看下面这几行代码，你会发现，相比之下，事先指定数据大小可以省掉很多次内存申请和数据搬移操作。</p><pre><code>ArrayList&lt;User&gt; users = new ArrayList(10000);
for (int i = 0; i &lt; 10000; ++i) {
  users.add(xxx);
}
</code></pre><p>作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验。</p><p>1.Java ArrayList无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p><p>2.如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。</p><p>3.还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList<object> &gt; array。<p></p>
<p>我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p>
<h2>解答开篇</h2>
<p>现在我们来思考开篇的问题：为什么大多数编程语言中，数组要从0开始编号，而不是从1开始呢？</p>
<p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式：</p>
<pre><code>a[k]_address = base_address + k * type_size
</code></pre>
<p>但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为：</p>
<pre><code>a[k]_address = base_address + (k-1)*type_size
</code></pre>
<p>对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。</p>
<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。</p>
<p>不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非0开始不可。所以我觉得最主要的原因可能是历史原因。</p>
<p>C语言设计者用0开始计数数组下标，之后的Java、JavaScript等高级语言都效仿了C语言，或者说，为了在一定程度上减少C语言程序员学习Java的学习成本，因此继续沿用了从0开始计数的习惯。实际上，很多语言中数组也并不是从0开始计数的，比如Matlab。甚至还有一些语言支持负数下标，比如Python。</p>
<h2>内容小结</h2>
<p>我们今天学习了数组。它可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</p>
<h2>课后思考</h2>
<ol>
<li>
<p>前面我基于数组的原理引出JVM的标记清除垃圾回收算法的核心理念。我不知道你是否使用Java语言，理解JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。</p>
</li>
<li>
<p>前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？</p>
</li>
</ol>
<p>欢迎留言和我分享，我会第一时间给你反馈。</p>
<hr>
<p><span class="orange">我已将本节内容相关的详细代码更新到GitHub，<a href="https://github.com/wangzheng0822/algo">戳此</a>即可查看。</span></p>
<p><img src="https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg" alt=""></p>
</object></p></div></div></div><div data-v-87ffcada="" class="article-comments"><h2 data-v-87ffcada=""><span data-v-87ffcada="">精选留言</span></h2><ul data-v-87ffcada="">            <li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/1d/54/adb7bf82.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">杰杰</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>314</span></a></div>
	</div>
	<div class="bd">JVM标记清除算法：<br><br>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。<br><br>不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。<br><br>二维数组内存寻址：<br><br>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：<br><br>address = base_address + ( i * n + j) * type_size<br><br>另外，对于数组访问越界造成无限循环，我理解是编译器的问题，对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配。老师的程序，如果是内存地址递减的方式，就会造成无限循环。<br><br>不知我的解答和理解是否正确，望老师解答？<br><br></div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">完全正确✅</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/8c/54/deb19880.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">slvher</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>625</span></a></div>
	</div>
	<div class="bd">对文中示例的无限循环有疑问的同学，建议去查函数调用的栈桢结构细节（操作系统或计算机体系结构的教材应该会讲到）。<br><br>函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍 高手！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e9/36/f62471c5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">不诉离殇</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>213</span></a></div>
	</div>
	<div class="bd">例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环。。如果数组本身有4个元素  则这里不会出现死循环。。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">高手！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Rain</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>148</span></a></div>
	</div>
	<div class="bd">根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>*而这个地址正好是存储变量 i 的内存地址*这个地方没看太懂，为什么正好就是i的内存地址呢？<br><br>谢谢老师。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/2d/1a/fcfd9872.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">夜下凝月</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>97</span></a></div>
	</div>
	<div class="bd">突然想到了垃圾桶。<br>生活中，我们扔进屋里垃圾桶的垃圾，<br>并没有消失，只是被  &#39;&#39;标记&#39;&#39;  成了垃圾，<br>只有垃圾桶塞满时，才会清理垃圾桶。<br>再次存放垃圾</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Nirvanaliu</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>96</span></a></div>
	</div>
	<div class="bd">文章结构：<br>数组看起来简单基础，但是很多人没有理解这个数据结构的精髓。带着为什么数组要从0开始编号，而不是从1开始的问题，进入主题。<br>1.	数组如何实现随机访问<br>1）	数组是一种线性数据结构，用连续的存储空间存储相同类型数据<br>I）	线性表：数组、链表、队列、栈 非线性表：树 图<br>II）	连续的内存空间、相同的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作<br>a)	数组如何实现下标随机访问。<br>引入数组再内存种的分配图，得出寻址公式<br>b)	纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。<br>正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）<br>2.	低效的插入和删除<br>1）	插入：从最好O(1) 最坏O(n) 平均O(n)<br>2）	插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。作者举例说明<br>3）	删除：从最好O(1) 最坏O(n) 平均O(n)<br>4）	多次删除集中在一起，提高删除效率<br>记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。<br>3.	警惕数组的访问越界问题<br>用C语言循环越界访问的例子说明访问越界的bug。此例在《C陷阱与缺陷》出现过，很惭愧，看过但是现在也只有一丢丢印象。翻了下书，替作者加上一句话：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。<br>4.	容器能否完全替代数组<br>相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过村塾容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。<br>数组适合的场景：<br>1）	Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别管柱性能，可以考虑数组<br>2）	若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组<br>3）	表示多维数组时，数组往往更加直观。<br>4）	业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。<br>5.	解答开篇问题<br>1）	从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i&lt;3;i++) 而不是for(int i = 0 ;i&lt;=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据，多出1个加法运算，很恼火。<br>2）	也有一定的历史原因<br></div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/e9/1c/be4ac7af.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">zyzheng</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>84</span></a></div>
	</div>
	<div class="bd">关于数组越界访问导致死循环的问题，我也动手实践了一下，发现结果和编译器的实现有关，gcc有一个编译选项（-fno-stack-protector）用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管i声明在前还是在后，i都会在数组之后压栈，只会循环4次；如果关闭堆栈保护功能，则会出现死循环。请参考：https:&#47;&#47;www.ibm.com&#47;developerworks&#47;cn&#47;linux&#47;l-cn-gccstack&#47;index.html</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">就喜欢你这种自己动手研究的同学</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d7/85/f2d5997a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Zzzzz</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>55</span></a></div>
	</div>
	<div class="bd">对于死循环那个问题，要了解栈这个东西。栈是向下增长的，首先压栈的i，a[2]，a[1]，a[0]，这是我在我vc上调试查看汇编的时候看到的压栈顺序。相当于访问a[3]的时候，是在访问i变量，而此时i变量的地址是数组当前进程的，所以进行修改的时候，操作系统并不会终止进程。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/eb/ea/4461196d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">何江</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>43</span></a></div>
	</div>
	<div class="bd">有个小问题，我觉得 随机访问Ramdom Acess 更应该翻译成 任意访问，更能表达数组的特性。不过国内书籍都是翻译成随机。新手朋友刚看到时会有一些理解问题，如数组怎么会是随机访问的呢(当初我就是这么想的)</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f2/b6/d3afc1ec.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李朋远</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>30</span></a></div>
	</div>
	<div class="bd">老师，您好，个人觉得您举例的内存越界的循环应该限制在x86架构的小端模式，在别的架构平台上的大端模式应该不是这样的！</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">说的没错 👍</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/15/e0/bc9f556c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">hope</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>25</span></a></div>
	</div>
	<div class="bd">根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>这块不是十分清晰，希望老师详细解答一下，谢谢！<br><br>看完了 ，之前说总结但是没总结，这次前连天的总结也补上了，打卡</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。<br>2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。<br>3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.<br>4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/1d/9d/ba8dc797.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">shane</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>21</span></a></div>
	</div>
	<div class="bd">无限循环的问题，我认为内存分配是从后往前分配的。例如，在Excel中从上往下拉4个格子，变量i会先被分配到第4个格子的内存，然后变量arr往上数分配3个格子的内存，但arr的数据是从分配3个格子的第一个格子从上往下存储数据的，当访问第3索引时，这时刚好访问到第4个格子变量i的内存。<br>不知道对不对，望指正！</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">形象👍</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/2d/1e/c6359873.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">qx</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>21</span></a></div>
	</div>
	<div class="bd">1.老师您好，二维数组存储也是连续的吧。<br>2.对于数组删除abc，还没太理解?申请的是三个地址空间，a（3）越界了，那么它会去找哪个地址的数据呢？而且for循环就是三次啊，如何无限打印?<br>3.老师时候每讲完一节数据结构可以对应到一些编程题目给大家思考啊例如leetcode或其他的?</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">港</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>18</span></a></div>
	</div>
	<div class="bd">1. 我认为文中更准确的说法可能是标记-整理垃圾回收算法。标记-清除算法在垃圾收集时会先标记出需要回收的对象，标记完成后统一回收所有被标记的对象。清除之后会产生大量不连续的内存碎片。标记-整理垃圾回收算法在标记完成之后让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。<br>2. 假设二维数组大小为m*n，那么寻址公式为<br>a[i][j]_address = base_address + (i * n+j)*data_type_size<br><br>3. C语言变量的内存申请可以看做是地址按照从大到小连续申请的，因为i在arr前面申请，所以arr[3]的地址和i的地址相同。<br><br>例如对于如下代码：    <br>int i = 0;int j = 1;int k = 2;    int arr[3] = {0};    cout&lt;&lt;&quot;i-&quot;&lt;&lt;&amp;i&lt;&lt;endl;    <br>cout&lt;&lt;&quot;j-&quot;&lt;&lt;&amp;j&lt;&lt;endl;    <br>cout&lt;&lt;&quot;k-&quot;&lt;&lt;&amp;k&lt;&lt;endl;    <br>cout&lt;&lt;&quot;arr-&quot;&lt;&lt;&amp;arr&lt;&lt;endl;<br>cout&lt;&lt;&quot;arr3-&quot;&lt;&lt;&amp;arr[3]&lt;&lt;endl;<br><br>运行结果：<br>i-0x28ff0c<br>j-0x28ff08<br>k-0x28ff04<br>arr-0x28fef8<br>arr3-0x28ff04<br></div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/59/f1/5a043e01.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">HCG</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>18</span></a></div>
	</div>
	<div class="bd">对于无线循环那个问题解释<br><br>个人认为应该按照这样的顺序声明：<br>int arr［3］＝｛0｝;<br>int i;<br>因为在计算机中程序一般顺序分配存储空间，这样声明，首先分配0 1 2三个存储单元给数组arr，然后再分配 4 存储单元给变量i，然后根据数组访问公式即会出现无线循环。<br>不知道对不对，还请老师指点。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d6/59/d19253dd.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">wistbean</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>15</span></a></div>
	</div>
	<div class="bd">————总结一下————<br><br>什么是数组<br><br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br><br><br>1.线性表<br>线性表就是数据排成像一条线一样的结构。<br>常见的线性表结构：数组，链表、队列、栈等。<br><br>2. 连续的内存空间和相同类型的数据<br><br>优点：两限制使得具有随机访问的特性<br>缺点：删除，插入数据效率低<br><br>数组怎么根据下标随机访问的？<br><br>通过寻址公式，计算出该元素存储的内存地址：<br>a[i]_address = base_address + i * data_type_size<br><br>为何数组插入和删除低效<br><br>插入：<br>若有一元素想往int[n]的第k个位置插入数据，需要在k-n的位置往后移。<br>最好情况时间复杂度 O(1)<br>最坏情况复杂度为O(n)<br>平均负责度为O(n)<br><br>如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第k个位置上的数据移到最后，然后将插入的数据直接放在第k个位置上。<br><br>这样时间复杂度就将为 O（1）了。<br><br>删除：<br>与插入类似，为了保持内存的连续性。<br>最好情况时间复杂度 O(1)<br>最坏情况复杂度为O(n)<br>平均负责度为O(n)<br><br>提高效率：将多次删除操作中集中在一起执行，可以先记录已经删除的数据，但是不进行数据迁移，而仅仅是记录，当发现没有更多空间存储时，再执行真正的删除操作。这也是 JVM 标记清除垃圾回收算法的核心思想。<br><br>数组访问越界问题<br>C语言中的数据越界是一种未决行为，一般比较难发现的逻辑错误。相比之下，Java会有越界检查。<br><br>用数组还是容器？<br>数组先指定了空间大小<br>容器如ArrayList可以动态扩容。<br>1.希望存储基本类型数据，可以用数组<br>2.事先知道数据大小，并且操作简单，可以用数组<br>3.直观表示多维，可以用数组<br>4.业务开发，使用容器足够，开发框架，追求性能，首先数组。<br><br>为什么数组要从 0 开始编号？<br>由于数组是通过寻址公式，计算出该元素存储的内存地址：<br>a[i]_address = base_address + i * data_type_size<br>如果数组是从 1 开始计数，那么就会变成：<br>a[i]_address = base_address + （i-1）* data_type_size<br><br>对于CPU来说，多了一次减法的指令。<br>当然，还有一定的历史原因。<br><br>————课后思考————<br><br>1.我理解的JVM标记清除垃圾回收算法：在标记阶段会标记所有的可访问的对象，在清除阶段会遍历堆，回收那些没有被标记的对象。现在想想，和「如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第k个位置上的数据移到最后，然后将插入的数据直接放在第k个位置上。」思想类似。<br><br>2. 对于一维数组：a[i]_address = base_address + （i）* data_type_size<br>二维数组如果是m*n，那么a[i][j]== base_address + （i*n+j）* data_type_size。<br>2.</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e7/89/207cc841.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">HI</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>10</span></a></div>
	</div>
	<div class="bd">标记清除：就是将要释放清除的对象标记，之后再执行清除操作，缺点就是会产生内存碎片的问题，很有可能导致下一次分配一块连续较大的内存空间，由于找不到合适的，又触发一次垃圾回收操作，一般试用于老年代的回收<br><br>二维数组的寻址操作：首先二维数组本质也是一个连续的一维数组，只不过每个元素都为一个一维数组，在内存空间的分配是按照行的方式将每一行拼接起来，比如数组a[1][2]   来说，看做是一个一维数组的话1就代表这个一维属于的第二个元素，第二个元素为一维数组然后根据2找到这一维数组中第三的元素</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">CathyLin</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>9</span></a></div>
	</div>
	<div class="bd">看完 &amp; 写完笔记来打卡，发现评论区好多大牛！光是翻看了评论区就收获了好多！</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Kudo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>9</span></a></div>
	</div>
	<div class="bd">假设二维数组的维度为m * n，则 a[i][j]_address = base_address + (i * n + j) * type_size</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Gkedlmv1ibTmUcALf69BCDhg5j0CGtqxaHHtpnbWc6yF8Wld7ILmgoScJtk4QiblfqoUJl9jyNhjgib9aEBGlIh8Q/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">韩某众</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>8</span></a></div>
	</div>
	<div class="bd">我也是js开发者，前面的那位js开发者同学的问题其实不难解决。<br>如果不知道老师的“数组”究竟是什么，只要查一下数据结构里的“数组”和“链表”的定义，然后搜一些关于js引擎对js定义下“数组”的底层实现的文章，比如“深究 JavaScript 数组 —— 演进&amp;性能”。就知道老师在说什么了。<br>互联网从业者更要善用互联网，加油！</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">说得好！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/7e/255fb6ee.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">金炜</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>5</span></a></div>
	</div>
	<div class="bd">前面“不诉离殇“ 提到的内存对齐会影响结果的说法有点问题，对于数组内存对齐是按数组里的元素对齐的，所以即使是长度为4的数组，变量i还是和数组最后一个元素挨着相邻。</div> <span class="time">2018-10-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">姜威</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>5</span></a></div>
	</div>
	<div class="bd">五、扩展知识点<br>1.为什么数组下标从0开始？<br>因为数组的首地址是数组第1个元素存储空间的起始位置，若用下标0标记第1元素则通过寻址公式计算地址时直接使用下标值计算，即a[0]_address = base_address + 0 * data_type_size。若用下标1标记第1个元素则通过寻址公式计算地址时需将下标值减1再计算，即a[1]_address = base_address + (1-1) * data_type_size，这样每次寻址计算都多了一步减法操作，增加了性能开销。<br>2.多维数组如何寻址？<br>这个在Java中没有意义，因为Java中多维数组的内存空间是不连续的，所以，暂不考虑。<br>3.JVM垃圾回收器算法的核心精髓是什么？<br>若堆中的对象没有被引用，则其就被JVM标记为垃圾但并没有释放内存空间，当数组空间不足时，再一次性释放被标记的对象的内存空间，这就是JVM垃圾回收器算法的核心精髓。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">java二维数组是分块连续的</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Monday</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>4</span></a></div>
	</div>
	<div class="bd">以问题为思路学习本节（国庆10天假，加来完成当初立下的flag，求支持鼓励）<br>一、引子：为什么很多编程语言的数组都是从0开始编号的？<br>	1、从数组存储的内存模型上来看，“下标”确切的说法就是一种“偏移”，相比从1开始编号，从0开始编号会少一次减法运算，数组作为非常基础的数组结构，通过下标随机访问元素又是非常基础的操作，效率的优化就要尽可能的做到极致。<br>	2、主要的原因是历史原因，C语言的设计者是从0开始计数数组下标的，之后的Java、JS等语言都进行了效仿，或者说是为了减少从C转向Java、JS等的学习成本。<br>二、什么是数组？<br>	数组是一个线性数据结构，用一组连续的内存空间存储一组具有相同类型的数据。<br>	其实数组、链表、栈、队列都是线性表结构；树、图则是非线性表结构。<br>三、数组和链表的面试纠错？<br>	1、数组中的元素存在一个连续的内存空间中，而链表中的元素可以不存在于连续的内存空间。<br>	2、数组支持随机访问，根据下标随机访问的时间复杂度是O(1)；链表适合插入、删除操作，时间复杂度为O(1）。<br>四、容器是否完全替代数组？<br>	容器的优势：对于Java语言，容器封装了数组插入、删除等操作的细节，并且支持动态扩容。<br>	对于Java，一些更适合用数组的场景：<br>	1、Java的ArrayList无法存储基本类型，需要进行装箱操作，而装箱与拆箱操作都会有一定的性能消耗，如果特别注意性能，或者希望使用基本类型，就可以选用数组。<br>	2、若数组大小事先已知，并且对数组只有非常简单的操作，不需要使用到ArrayList提供的大部分方法，则可以直接使用数组。<br>	3、多维数组时，使用数组会更加直观。<br>五、JVM标记清除算法？<br>	GC最基础的收集算法就是标记-清除算法，如同他们的名字一样，此算法分为“标记”、“清除”两个阶段，先标记出需要回收的对象，再统一回收标记的对象。不足有二，一是效率不高，二是产生碎片内存空间。<br>六、数组的内存寻址公式？<br>	一维数组：a[i]_address=base_address+i*type_size<br>	二维数组：二维数组假设是m*n， a[i][j]_address=base_address + (i*n+j)*type_size<br>	三维数组：三维数组假设是m*n*q， a[i][j][k]_address=base_address + (i*n*q + j*q + k)*type_size<br><br>若理解有误，欢迎指正，谢谢！</div> <span class="time">2018-10-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/2a/ab/6b2475e9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">coulson</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">写的超级赞！提个小意见：评论那么多，看起来很碎，老师能不能定期写一篇问题汇总贴，把高频问题和优质答案进行汇总，这样看着很方便！</div> <span class="time">2018-10-12</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">可以，我回复的也很心累。</p> <p class="reply-time">2018-10-13</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/38/6b/f844fe80.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">meteor</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">数组的删除操作这段没看懂。<br><br>搬移由三次变成一次是理解的。但下面这段话不懂<br><br>“我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除”，这句话是什么意思啊？</div> <span class="time">2018-10-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/eb/81/43f4b52c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">杨伟</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br><br>struct array {<br>	int size;<br>	int used;<br>	int *arr;<br>};<br><br>void dump(struct array *array)<br>{<br>	int idx;<br>	<br>	for (idx = 0; idx &lt; array-&gt;used; idx++)<br>		printf(&quot;[%02d]: %08d\n&quot;, idx, array-&gt;arr[idx]);<br>}<br><br>void alloc(struct array *array)<br>{<br>	array-&gt;arr = (int *)malloc(array-&gt;size * sizeof(int));<br>}<br><br>int insert(struct array *array, int elem)<br>{<br>	int idx;<br>	if (array-&gt;used &gt;= array-&gt;size)<br>		return -1;<br><br>	for (idx = 0; idx &lt; array-&gt;used; idx++) {<br>		if (array-&gt;arr[idx] &gt; elem)<br>			break;<br>	}<br><br>	if (idx &lt; array-&gt;used)<br>		memmove(&amp;array-&gt;arr[array-&gt;used], &amp;array-&gt;arr[idx],<br>			(array-&gt;used - idx) * sizeof(int));<br><br>	array-&gt;arr[idx] = elem;<br>	array-&gt;used++;<br>	return idx;<br>}<br><br>int delete(struct array *array, int idx)<br>{<br>	if (idx &lt; 0 || idx &gt;= array-&gt;used)<br>		return -1;<br><br>	memmove(&amp;array-&gt;arr[idx], &amp;array-&gt;arr[idx+1], <br>		(array-&gt;used - idx) * sizeof(int));<br>	array-&gt;used--;<br>	return 0;<br>}<br><br>int search(struct array *array, int elem)<br>{<br>	int idx;<br><br>	for (idx = 0; idx &lt; array-&gt;used; idx++) {<br>		if (array-&gt;arr[idx] == elem)<br>			return idx;<br>		if (array-&gt;arr[idx] &gt; elem)<br>			return -1;<br>	}<br><br>	return -1;<br>}<br><br>int main()<br>{<br>	int idx;<br>	struct array ten_int = {10, 0, NULL};<br><br>	alloc(&amp;ten_int);<br>	if (!ten_int.arr)<br>		return -1;<br>	insert(&amp;ten_int, 1);<br>	insert(&amp;ten_int, 3);<br>	insert(&amp;ten_int, 2);<br>	printf(&quot;=== insert 1, 3, 2\n&quot;);<br>	dump(&amp;ten_int);<br><br>	idx = search(&amp;ten_int, 2);<br>	printf(&quot;2 is at position %d\n&quot;, idx);<br>	idx = search(&amp;ten_int, 9);<br>	printf(&quot;9 is at position %d\n&quot;, idx);<br><br>	printf(&quot;=== delete [6] element \n&quot;);<br>	delete(&amp;ten_int, 6);<br>	dump(&amp;ten_int);<br>	printf(&quot;=== delete [0] element \n&quot;);<br>	delete(&amp;ten_int, 0);<br>	dump(&amp;ten_int);<br>	return 0;<br>}</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/12/c6/0c1f8e4d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">_yj</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">疑问：<br>老师说压栈是从高地址向低地址扩展<br>但是我使用gcc编译打印变量地址发现地址是向上增长，于是我怀疑是不是哪里出了问题<br>经过百度我了解到bsp寄存器会存储栈顶地址<br>我便把我写的代码编译成 test.S 查看编译后的汇编代码<br>我发现bsp进行了一个subl的操作<br>因为我并没有研究过x86的汇编<br>所以我猜想：<br>这儿实际是通过向下扩展腾出变量所需的栈空间<br>但是压栈的顺序是由编译器来完成的<br>所以压栈确实是从高地址向低地址扩展<br>但为什么地址会向上增长是由编译器决定<br>所以这儿所说的i的地址为什么刚好在arr后面<br>事实上是编译器决定的<br>我在我的虚拟机上实验的结果表明编译器会先把数组的地址依次从最低位向上压栈<br>其他的变量地址在数组之后按照定义的次序压栈<br>所以：<br>我认为老师说的从高位向低位压栈arr【3】寻址访问到 i 在这儿是有问题的<br>因为实际压栈从高位往低位压还是反过来压是由编译器所决定<br>如果有误望指出</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">兄dei啊，我没说一定就会死循环呀，我说是这种数组越界是未决的，是编程语言和编译器都有关的，麻烦看看仔细看看我的文章和留言好不啦~</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/eb/aa/db213a66.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">莫弹弹</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">1， 数组越界导致无限循环，会因为编译器不一样而出现不一样的结果，不会说必然无限循环；并且声明的顺序应该是<br>int [] arr;<br>int i;<br>这样更大概率让数组越界一位后命中变量i，把i放前面基本不会被命中。<br>至于为什么越界后会命中i，这个是c语言基础，不懂的同学可以看看c语言关于数组的内存分配说明。<br><br>2， 标记清除法应该是需要借助容器类实现，单纯的基本类型数组并不能产生标记行为或者属性；<br>也就是说，<br>可能需要分配一个额外的数组记录当前数据数组的数据元素是否被删除<br>可能需要把数组元素进行包装，添加一个属性用来标记这个元素是否被删除<br>当数组标记足够多，数组空闲元素不多的时候，就需要对数组进行真正的删除，这个真正的删除过程称为碎片整理，也就是jvm的gc了，非常消耗性能，所以JAVA里有个优化策略叫减少gc次数。<br><br>个人理解，欢迎指正</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/10/d9/acc787a6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李大飞</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">感谢王大大和评论区的大牛们。我越来越感受到这门课的刺激了，上一堂课中有个“数组会被清楚掉”和这节课的“无线循环”，我也第一次看到时也有些懵逼，但是我去思考了我去实践了，让我更多的去思考去实践了，自己动手也做了，去百度点C语言的语法，理解后才发现与评论区的大牛想法是如此的接近，很有成就感！感谢王大大输出这么高质量的课程。GoGoGo...</div> <span class="time">2018-11-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/01/37/58650ade.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">高源</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">请问老师学习数据结构算法的使用技巧，如何能够灵活应用，解决实际问题，在现实中遇到问题有时候不一定能马上知道用哪种方法解决，例如中国象棋我知道肯定要用算法解决，算法好坏决定你的难度，但是我不知道是用哪个现成算法，还是自己写新算法</div> <span class="time">2018-10-20</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">这个跟你高中学数学一样的，理论老师都交了给你。但是，考试中的题目你并不一定能联想到老师讲过的解法。这之间需要你多练、多思考、多总结，才能见到题目就想到对应的解法。</p> <p class="reply-time">2018-10-20</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/40/98/e5109fca.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Scarlett</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">无限循环那个试了好几次，都试不出来，觉得应该就是编译器（xcode）的问题。后来看见上面的同学回复说-fno-stack-protector编译选项，果断尝试了一下，发现xcode也有堆栈保护，设置上就出现无限循环了，果然多看评论有好处。</div> <span class="time">2018-10-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/4b/b0/3b4b170b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">行走着的宋公子</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">m×n二维数组 a[i][j] 地址 ＝base + （i × n + j）×type_size</div> <span class="time">2018-10-09</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/fa/80/f8be387d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">途</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">jvm标记清除算法顾名思义就是标记和清除，标记阶段其实就是和专栏中讲得标记删除有着异曲同工之妙，只不过jvm中标记的是保留对象而非辣鸡对象，清除阶段做的是真正的删除的操作</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/e6/3a/5e8be862.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿火</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，这个地方不明白，老师可以再讲解下吗？</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。<br>2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。<br>3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.<br>4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/30/2b/bc5873c6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">对方正在输入</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">1.ArrayList中实际存放的只是对象的引用,每个集合元素都是一个引用变量，实际内容都放在堆内存或者方法区里面，但是基本数据类型是在栈内存上分配空间的，栈上的数据随时就会被收回的。<br><br>2. 比如 int,float...  是基本数据类型,在具体的内存分配上<br>对象是放在堆里的，基本数据类型是放在栈里的，看看容器的具体实现，你就能更理解为什么ArrayList只能存放引用类型了<br><br><br></div> <span class="time">2018-11-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/35/57/ab4ba792.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小鱼</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">Java的垃圾清除机制应该和.net是一样的。他们都采取了延迟清除的机制。没有频繁的清除内存数据可以提高效率</div> <span class="time">2018-11-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/7a/42/439d6f83.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">🍃 ℳr.唐🐲🍂</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">老师您好，我想请问一下：<br>原文如下：<br>我们知道，在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br>这里的a[3]=0为什么相当于i=0呢，这个有点不理解，请老师百忙中帮忙解答一下。</div> <span class="time">2018-10-31</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">看看留言区的回答</p> <p class="reply-time">2018-11-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8a/72/349661af.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李延志</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">有一个疑问：在数组越界时导致无限循环的问题中，变量分配不是按照内存递增或递减方式，但是无论变量i在数组的前面还是后面都会无限循环，请大神指点一下。(测试环境centos的x86_64)</div> <span class="time">2018-10-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/88/12/585dc73d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">浮夸伴身</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">关于无限循环打印“hello world”有疑惑的同学，可以看看这篇关于gcc堆栈保护机制的文章https:&#47;&#47;blog.csdn.net&#47;u012796139&#47;article&#47;details&#47;46635567</div> <span class="time">2018-10-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/19/74/2ac4edd8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">追风者</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">关于插入情况的平均情况时间复杂度为 (1+2+…n)&#47;n=O(n)。我的理解是：<br>在第1元素插入，需要向后移动n个元素；<br>在第2元素插入，需要向后移动n-1个元素；<br>。。。<br>在第倒数第2个元素插入，需要向后移动2个元素；<br>在第倒数第1个元素插入，需要向后移动1个元素；<br>末尾追加，直接插入，不需要移动元素。<br> 所以平均时间复杂度就是(n+n-1+...+2+1+0)&#47;n，也就是(1+2+…n)&#47;n=O(n).<br>不知道这样理解是否正确？</div> <span class="time">2018-10-11</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">正确</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/9d/9a/42f98193.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">芒果</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">感觉这个专栏特别棒，例如：数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)，作为学生党，觉得特别精华。</div> <span class="time">2018-10-11</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">恁真是性情中人啊 一会表扬我 一会批评我😄</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/93/4d/84200fe1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">coder</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">“其实除了数组，链表、队列、栈等也是线性表结构。”<br>—- &#47;&#47;<br>这里“除了”是不是要去掉？<br><br></div> <span class="time">2018-10-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">意思是数组也是。数组和链表直接是逗号。其他三个直接是顿号</p> <p class="reply-time">2018-10-10</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/8b/ee/49ba9142.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">王虹凯</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">为什么容器类型不支持原始类型？flag,回去查一下</div> <span class="time">2018-10-07</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">查一查 搞清楚之后 欢迎发到留言区 给其他小伙伴也看看</p> <p class="reply-time">2018-10-08</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/9d/d3/abb7bfe3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">王伟zzz</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">插入操作的 平均情况时间复杂度是不是应该这么算？ (1+2+…n+1)&#47;n+1 ？ 因为一共n+1种情况</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">嗯嗯 可以</p> <p class="reply-time">2018-10-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/6d/62/d27996f6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">陈昱</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">老师在文章中用的代码，在 Xcode 上创建一个 C 工程，复制代码执行 4 次就 Crash。在 Android Studio 中创建一个 .java 文件，执行3次就 Crash。<br><br>请问下，老师你的这个代码在什么机器，什么编译器下可以无线循环起来？<br>@slvher @Zzzzz 你们呢，有可运行起来的编译器或者环境吗？</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1a/ab/b352a655.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">佑强</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">JVM对象在内存中不被任何引用类型引用也没有引用路径到达这个对像时，会被标记为可删除对象，jvm 在为新对象分配内存空间时，如果发现内存不够分配或者没有连续的内存区域给大对象分配，则会调用垃圾回收器进行对象删除操作，这就是标记清除算法，因为被标记的对象可能不是连续的，所以回收后会产生对象碎片，所以标记清除算法并不是最佳的清理方法，一般用复制算法或者标记整理算法</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f1/8f/b3273afe.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">梦其不可梦</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">老师，我有一个疑问:<br>用记录的方式记录一下删除了的数据，这不就破坏了数组的随机访问特性吗？</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/d4/f1/c06aa702.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">惟新</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">数组和链表的区别:<br>链表适合插入、删除，时间复杂度 O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br><br>Java 中数组和 ArrayList 的选择问题：<br>1、ArrayList 无法存储基本类型，需要把 int、long 转化为 Integer、Long 类，这种Autoboxing、Unboxing 需要消耗一定的性能。所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。<br>2、如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。<br>3、当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList&gt; array。<br>总结：对于业务开发，直接使用容器就足够了，省时省力。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。<br><br>二维数组寻址公式：<br>举例：一个 m x n 的二维数组arr，arr[i][j](0&lt;=i&lt;m &amp;&amp; 0&lt;=j&lt;n) 的内存地址。<br>a[i][j]_address = base_address + i * type_size * n + j;<br><br><br>求指正。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/23/af/84f4714e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">caidy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">二维数组计算公式，假设二维数组为Array[n][m]<br>则Array[i][j]=Base_Address+(i*m+j)*type_size;<br>i&lt;n,j&lt;m;</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/01/04/108efea1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">hf</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">无限打印那个，应该是因为计算机存储大小端的问题吧，存储的声明顺序和实际物理地址顺序其实是相反的，x86机器好像是这样的</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d9/1c/aa08ae6b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">长安</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">二维数组内存寻址要考虑行优先和列优先两种情况<br>若定义一个数组a[n][m]<br>行优先 <br>a[k][j]_address = base_address+k*m*type_size + j*type_size<br>列优先 <br>a[k][j]_address = base_address+j*n*type_size + k*type_size<br>不知道是不是这样 希望老师指正</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/32/0b/81ae214b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">凌</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">go的gc也是标记的?<br>另外请教下a*是不是也是一种图</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/08/eb/fed61050.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">五岳寻仙</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">1. 不熟java，对python的垃圾回收机制有一点很肤浅的了解。<br>python中变量的值都是对象，变量名是指向这个对象的一个引用，每个对象都会有个记录被引用次数的标记。比如 “a = 1; b = 1” 其实系统只创建了一个“值为1的整数对象” ，这个对象的被引用次数为2，当被引用次数降为0的时候，代表没有人引用它了，系统就会把它清楚。<br><br>2. 在C中，数组是通过首地址加偏移来实现随机访问的。二维数组中，第一维存放的都是“第二维数组的首地址”，访问时通过两次偏移就可以了。比如 a[i][j]，第一次偏移 i 找到了第二维数组的首地址，第二次偏移 j 找到了存放的元素值。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/66/73/fd1e37a2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">良辰美景</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">二维数组就是数组中的数组咯。所以寻址做两次就好。先算出一维数组的空间地址。然后在将算出的地址作为baseadder算二维的地址</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Rain</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">1. 现在只能想起来一点点了。。JVM GC就是Mark Sweep, 不同的回收策略在执行过程中有单线程和多线程的。谢谢在a,b,c标记再删除的点拨<br>2. a[k,j]_address= base_address+ k* type_size*x + j* type_size, 设二维数组内部长度为x.</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/09/d1/3872f8c8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">山海不可平</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">老师你好，我18年毕业生，大学期间专业自动化，想学习编程，想问问您方向性的知道，或者说推荐几本书也可以，麻烦老师了。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/9e/3a/7d70960c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">张初炼</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">老师有个问题想问一下，假如数组下标从 1 开始：<br>a[k]_address = base_address + (k-1)*type_size = (base_address - type_size) + k*type_size。虽然 base_address 在编译时不确定，可加载程序时就知道了，因此 (base_address - type_size) 只需要计算一次，前半部分就可以认为是“常数”。这样来看，数组下标从 1 开始带来的“性能消耗”其实是可以避免的。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">能详细讲讲 base address - type size 只需要计算一次这块的理由吗</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/94/41/be0af1c4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">LittleLittleQ</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">龟系学习，基本刷完了leetcode的array</div> <span class="time">2019-02-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/15/50/5b/1525d8ed.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">千山2018</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">相见恨晚鸭</div> <span class="time">2019-02-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/34/f3/37264433.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">kim</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，文中提到&quot;如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。&quot; 这里需要重新申请空间才行吧，因为数组内存空间是固定大小的，插入就需要重新申请空间，复制数据，所以我觉得应该是O（n)吧</div> <span class="time">2019-02-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/15/51/64/47c19133.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">一只牛</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移，只是记录数据已经被删除。当数组没有更多空间存储时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br>这句话不理解.  怎么记录下已经删除的数据?统一删除的话java也不能实现啊?数组没有更多空间存储时再删除指的是数组的长度都被用完了么?那此时统一删除,是异步的啊?</div> <span class="time">2019-02-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">马海滨</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">首先：对于内存对象的清除是比较耗时间的，所以采取对未可达对象进行标记，然后到达一定时间之后进行清楚，并且重新整理对象池<br><br><br>base_address+ i*j*type_size + j*</div> <span class="time">2019-02-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Pre-Y</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">今日份的打卡。<br>👀看了评论区的大佬们的解答，不禁感叹所知甚少。<br>对于二维数组A[x1-x2][y1-y2]，求A[i][j]的地址<br>已知locA[x1][y1]，每个元素占k个存储单元<br>locA[i][j]＝locA[x1][y1]+[（y2-y1+1）*（i-x1）+（j-y1）]*k<br></div> <span class="time">2019-02-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epZ0KJAWQ5OtibzXaeOLbvG2icASHialeB96via6lCafNNRXAG7u3UYJ0gZPWESU1iaPMYrXZUReqwW9Cg/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">谭晓龙</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">一直不理解垃圾回收的标记阶段一开始那个root是指什么？老师能解释一下吗？？</div> <span class="time">2019-02-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwVgXx5UCmXuUJIibytjfxlfia7XJBX6ricaVuGpAREA9fm8mK7WwKXEzictLQRIicvrIgRCGtrwfsS9g/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mingjie</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我有一个问题：JVM中有ArrayList扩容方法，有没有缩减的方法？想缩减肯定是能实现的，不知道在实际应用中会不会考虑到这个问题？</div> <span class="time">2019-02-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">衬衫的价格是19美元</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组是最基本的数据结构，与编程语言没有关系<br>每种编程语言都提供了自己的类来实现数组的功能，比如Java 有ArrayList；python 有list<br>所以，当我们说数据结构的时候，我们说的是基础的数据结构，而不是由语言实现的某种类<br></div> <span class="time">2019-02-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/15/4f/d4/6b31cfc3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">a檬檬檬檬奇</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">用Java编写代码使用数组需要事先定义数组大小，所以，在Java语言中，其实是没有办法直接往一个数组插入或删除数据的，只有通过复制数组的方法才能实现插入或删除数据的问题，也就是说，在Java中，不管插入或删除的数据在哪个位置，都需要循环n＋1或循环n-1次，是不是这样子？虽然时间复杂度依然是O(n)。</div> <span class="time">2019-02-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/a9/90/0c5ed3d9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">颇忒妥</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对于二维数组 a[m][n]<br>a[i][j]_addr = base_addr + (i * n + j) * type_size<br><br>对于三维数组 a[m][n][p]<br>a[i][j][k]_addr = base_addr + (i * n * p + j * p + k) * type_size</div> <span class="time">2019-01-31</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/15/3c/03/fd1e6638.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">linux驱动层</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">那个数组越界造成的无限循环的原因是因为，数组越界的过程中，对a〔i〕赋值，会造成对i赋值，即i＝0，i永远达不到循环结束的条件，所以造成了无限循环。</div> <span class="time">2019-01-31</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/19/23/849beae4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">高山高</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">置顶的杰杰同学的留言，有一些描述是不准确的，标记-清除算法执行标记时，标记的是需要回收的对象</div> <span class="time">2019-01-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/54/20/93c79f7c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">晓龙</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组：int a[n][m]<br>for i in n<br>  for j in m<br>     line = n * sizeof( int)<br>     value = a + line + j * sizeof(int)</div> <span class="time">2019-01-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/40/ab/62b36cdf.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Henry</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组不应该是连续的吗？如果 a b c d e 插入 x 变成 a b x d e c，岂不是改变了存储顺序，那么 array[3] 依然跟插入之前一样（都是 d ，插入后，array[3] 就当是 c 吧？）。删除部分同理。不明白@_@</div> <span class="time">2019-01-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">康斯坦丁</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">标记清除算法，可达性分析标记&#47; 清除内存空间. 有碎片问题.<br><br>对于 o * t的数组<br>a[k][j]_address = base_address + k * t * type_size + j * type_size.</div> <span class="time">2019-01-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">双子座的马克思</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如果内存中的数据在一段时间后没有被引用了，该数据就会被垃圾回收器回收。结合今天的课来看，是这些未被引用的数据在内存中被标记为了删除，当垃圾回收器空间满了后，就像数组的清除一样，被统一清除，减少执行次数，提高效率。在进一步讲，当垃圾回收器频繁执行删除数据时，就会出现程序卡顿的情况。</div> <span class="time">2019-01-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">双子座的马克思</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我对“随机访问”的理解：通过下标访问数组中的元素，下标值是随机的，访问就是随机的，</div> <span class="time">2019-01-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">双子座的马克思</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">确实是，0是计算机中非常重要的数字，不从0开始总感觉不完整</div> <span class="time">2019-01-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">海军上校</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看评论也涨姿势～内存对齐一直不是很懂～</div> <span class="time">2019-01-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">linluu</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">想问个问题：数组查找为a[i]_address = base_address + i * data_type_size<br> def find(f):<br>                    list = [x for x in range(n)]<br>                    addr  =  1000  # 首个内存空间地址<br>                    data_size = 3 # 数据大小<br>                    for X in range(len(list)):<br>                        if list[x] == f:<br>                            return addr + data_size * X<br>这是用python写的按照这种说法 那么数组为何是O(logn)而不是O(n)</div> <span class="time">2019-01-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/8a/02/0bc2ed1d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">yuzehuang</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">JVM标记清除算法分为两个阶段：标记和清除。首先标记出需要被回收的所有对象，再标记完成之后统一做回收处理。但是该算法有两个缺点：一个是效率不高，无论是标记或是清除。另一个是会产生内存碎片。如果后期申请较大内存时，无法申请到合适大小的内存时会提前触发另一个垃圾收集动作。</div> <span class="time">2019-01-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">双子座的马克思</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">计算机中的内存地址是连续的字节数据，字节是由比特组成，比特是0和1，又到了光信号的低电平和高电平</div> <span class="time">2019-01-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/fe/4d/e5c33794.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">慧慧</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">想知道oc或者Java中用的是标记删除还是低效删除</div> <span class="time">2019-01-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/10/4d/f548bc68.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Apollo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">写的很深入，最近刚看了嵌入式boot loader 的实现相关内容，以及C语言环境的构建，arm 的满降栈的实现，以及看了前几个大牛的分析对这个问题的理解就不一样了</div> <span class="time">2019-01-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/c9/d8/e54f0e27.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">我是一个见谁爱谁的坏小孩</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师写的很详细很棒 补起了当年数据结构的痛啊</div> <span class="time">2019-01-13</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/35/fc/d1ebf029.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">@self</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我在linux下实验无线循环那个代码，发现即使关闭堆栈保护。也只是打印 4 次。而且我打印地址信息，发现他们离的大概有16个字节远。建议老师下次再有这种实验时能够指出在什么情况下会出现某种现象。</div> <span class="time">2019-01-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/b9/35/96fb49d6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Simon少明</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这边查了下PHP关于数组的资料：<br>1.PHP5.3以后在SPL扩展中提供了SplFixedArray，这个数组更接近于文中说的数组结构，性能更接近于C语言，不同的是数组中存储类型可以不同。<br>2.我们经常使用的数组其实是用哈希表实现的<br>总结：<br>底层或注重性能可以考虑使用读写性能更优的SplFixedArray，日常使用普通数组即可</div> <span class="time">2019-01-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/HRicO9C2gHpCxibedw0370AtpeqE9uo5kkBW4XCrsF9btibJPIq4vSribYdsjiaOFPK7YMfNmSSdIQlUMXGwgicTLTCg/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">zachary</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对于已经指定了二维的每一维的大小时，随机访问容易写出公式。在 Java 中，初始化二维数组时，高维必须指定，低维是不需要指定的。这种情况下，内存是连续的空间吗？随机访问是如何做到的呢？<br>		int[][] a = new int[3][];<br>		a[1] = new int[5];<br>		System.out.println(a[1][2]);</div> <span class="time">2019-01-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">第一维应该是连续的，第二维可能不是了</p> <p class="reply-time">2019-01-17</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/e9/f25cce9e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李军</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">js的数组不是真正意义上的数组吗？ var arr = []; 可以存储各种类型啊?</div> <span class="time">2019-01-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">是不是存储的对象的地址呢</p> <p class="reply-time">2019-01-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/4b/d4/b7719327.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">波波安</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</div> <span class="time">2018-12-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/4b/d4/b7719327.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">波波安</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组：二维数组假设是m*n， a[i][j]_address=base_address + (i*n+j)*type_size</div> <span class="time">2018-12-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/4b/d4/b7719327.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">波波安</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组：二维数组假设是m*n， a[i][j]_address=base_address + (i*n+j)*type_size</div> <span class="time">2018-12-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/5d/2f/1cf3a468.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿章</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">在对数组进行数据删除的时候，不是马上删除，而是做一个标记，等到数组没有空间的时候，再把删除的元素真正删除掉，然后移动数组中的元素，可以节约时间，实际上JVM的垃圾回收中的标记清除算法，就是采用了这个思想。</div> <span class="time">2018-12-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/5d/2f/1cf3a468.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿章</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如果数组当中的元素没有什么规律，要想在k个位置插入一个元素，可以把原来第k个位置的元素移动到末尾，然后把第k个位置的值设为这个值，这样时间复杂度就是1了，实际上快排就是利用了这个思想。</div> <span class="time">2018-12-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/5d/2f/1cf3a468.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿章</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">有个面试题问数组和链表的区别，有人说，数组适合查找，时间复杂度是1，链表适合插入和删除，时间复杂度是1，其实这种表述是错误的，数组是适合随机访问，随机访问的时间复杂度是1，而查找即使是排序好的数组采用二分查找时间复杂度也是n*lgn</div> <span class="time">2018-12-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/32/fa/71c460d9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">想想คิดถึง</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">没学过JVM，JAVA暂且不提，；二维数组寻址公式需要好好想。</div> <span class="time">2018-12-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/94/41/be0af1c4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">LittleLittleQ</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">假设有二维数组a[m][n] , 则address[i][j] = base_address + (n * i + j) * type_ size, 其中 0 &lt;= i &lt;= m, 0 &lt;= j &lt; n</div> <span class="time">2018-12-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqQbVxfDlE4LRM3UFzeeViaWld06AdsMPEMQWP3UxyF7EZHT7157Wsj61Qx66eyNGyibgz3Dw2xdAWw/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">achenbj</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对于数据结构真是一点看不进去怎么破...</div> <span class="time">2018-12-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqQbVxfDlE4LRM3UFzeeViaWld06AdsMPEMQWP3UxyF7EZHT7157Wsj61Qx66eyNGyibgz3Dw2xdAWw/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">achenbj</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看了您git上面的代码，就是拿着数组实现了一个Array类；<br>就是基本实现list的方式，这么理解对吗？</div> <span class="time">2018-12-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/PKhYJtPJpdAYMXkho8yibaudUf1AgGb1zJoo7pIAy2NabuHZWuB5viauZUm0dF7kpxx3nTdQsiboYgAhmvFzjg5YQ/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">hoyouly</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组内存寻址方式，尽管叫二维数组，其实在内存中也是一个线性结构，<br>例如int arr[2][3],在内存中存放的顺序就是arr[0][0],arr[0][1],arr[0][2],arr[1][0],arr[1][1],arr[1][2],和数组int arr1[6],内存中存放顺序是一致的，所以arr[1][1]的内存地址就是：  base_address+(1*3+1)*4<br>总结就是： 数组 array[n][m]中 array[i][j]的地址为 base_address+(i*m+4)*type_size</div> <span class="time">2018-12-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/06/4f/48355a64.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">不专注的linuxer</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">话说，老师你写for循环的时候，变量i为什么老在for循环外定义，为什么不是for(int i = 0; i &lt; 10; i++)，有什么好处么，先定义循环用到的变量</div> <span class="time">2018-12-25</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">写法问题 都一样</p> <p class="reply-time">2018-12-26</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/06/4f/48355a64.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">不专注的linuxer</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">@slvher，你说Linux是从高到低的地址分配模式，然后说i比a［3］地址大不对吧，应该是i的地址比较小呀，毕竟是数组a先定义的，占据了较高地址空间，然后才是i呀。</div> <span class="time">2018-12-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/f4/87/644c0c5d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">俊伟</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组：是一种线性表结构，用一块连续的内存存储相同类型的数据。线性表就是一种数据按一条线一样排列的结构。连续内存指的是一整块连续的内存。<br>一个二维数组连续连续访问的计算公式为：<br>假设数组为a[n][m]访问为i,j的位置<br>base_address + i *(m*size) +  j*size<br></div> <span class="time">2018-12-24</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/24/df/da37ff2b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Yayu</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">讲到容器数据类型上来就那 Java 举例子，如果没有用过 Java 的同学怎么来理解呢？</div> <span class="time">2018-12-20</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">其他语言也有的 都类似 可以自己分析下 我也只是作为一个引子  更多的还是靠自己搜搜研究研究</p> <p class="reply-time">2018-12-20</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/5c/d1/9bdd6906.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">+@+</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">想问下老师 这些图是用什么软件制作的呢 感觉很清晰 很随和</div> <span class="time">2018-12-20</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">paper</p> <p class="reply-time">2018-12-20</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/5b/ab/aac30656.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Luke</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">C# 矩阵数组 本质是一维数组存储 寻址 a[i,j]_address=base_address + i*type_size + j，多维数组就搞不清楚了</div> <span class="time">2018-12-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/67/eb/9a041634.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Violin</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">无限循环那个，在c上栈区是由高到低，堆内存是由低向高，；；理论上在内存中的模型是(由低到高地址)arr[0],arr[1],arr[2],i..... ，但是我在x64 vs2013 vc上试的，发现a[3]的地址并不是和i重合，说明arr[2]与i之间不是连续的，可能是因为对齐问题导致的(因为改成4字节或者8字节，都不重合，但地址确实有差距)</div> <span class="time">2018-12-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/9c/ed/8be154cc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Lisa💓💓</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不懂C++，只会一点点python。代码看不懂，好多理解不了，怎么办呢？</div> <span class="time">2018-12-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJic27dia65Z8OdictLLDOWic2fjFtiaQNQ1ou4icQ7AOjic4gK2iaOlYAUkNX7OoFnLs1hr1u5ib4Khcjib4DA/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">鱼子酱</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1. 什么是数组？<br>数组是一种线性表结构，用一段连续的内存存储一组相同类型的数据元素。<br>线性表结构有数组、链表、队列、栈等。<br><br>2. 数组与链表的区别：数组支持随机访问，时间复杂度为O(1)；而链表适合插入和删除操作，时间复杂度为O(1)。<br><br>3.数组是如何实现随机访问的？<br>数组中元素的内存地址是连续的，可以通过寻址公司得到元素的内存地址：<br>ai[i]_address = base_adress + i * unit_size，<br>因此只要知道索引便可迅速得到对应的内存地址。<br><br>4.为什么数组的插入和删除是低效的？<br><br>数组插入的操作过程：假设向数组的第k个元素插入元素，则首先需要将第k个至最后一个元素全部往后移动，然后才能将元素插入到索引为k的位置。<br>最好时间复杂度：O(1)<br>最坏时间复杂度；O(n)<br>平均时间复杂度：O(n)<br><br>删除操作：跟插入元素类似，删除某个索引元素时，需要将后续的所有元素往前移动。<br>时间复杂度与插图元素的一致。<br><br>5. 高效的插入和删除：<br>当不需要考虑元素的先后顺序时，为了提高效率，在第i的索引插入元素时，可以将原来的索引i对应的元素移到数组的最后，然后将新元素插入到索引i。<br><br>6.什么情况下使用数组和容器？<br>如果是业务开发，建议使用容器，因为容器中封装了很多方法，并支持动态扩容，可以牺牲一点性能换取更高的开发效率；如果是开发底层模块，例如网络连接等，优先考虑性能的时候最好采用数组。<br><br>7.为什么数组的索引一般是从0开始呢？<br>上述介绍的寻址公式是从0开始计算的，假设索引从1开始，则新的公式为：<br>ai[i]_address = base_adress + (i -1) *unit_size，<br>这种情况下需要多执行一次减法操作；另外也有一些历史原因。<br></div> <span class="time">2018-12-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/07/ea/b82fd545.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">abs</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1、数组是一组内存连续、存储相同数据类型、线性的数据结构<br>2、数组按偏移访问的时间复杂度为O(1)，访问公式为<br>    arr[i]首地址=数组首地址+数据类型大小*i ， 其中i为偏移量<br>3、java中使用容器ArrayList尽量指定初始容量，减少不必要的扩容<br>4、使用基本类型数组可以减少封箱拆箱操作，早操作频繁和性能要求高的场景使用<br>5、C语言使用0为下标的原因是根据地址偏移量计算内存地址的是否不需要为偏移量减一，之后语言为了保持习惯，或也出于C语言设计者同样的目的使用0作为下标，但也有一些语言以1作为数组下标<br>6、JVM标记清除算法的优点是每次不需要移动对象，节省每次的清理 时间，但会产生内存碎片，对于对象存活比较多，只有少部分对象死亡的场景比较适用，所以多应用于老年代的垃圾回收。</div> <span class="time">2018-12-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/07/ea/b82fd545.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">abs</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看了各位的留言总算理解了，不知道描述的是否准确<br>栈的结构如下，栈底部地址大于栈顶部，所以数组下标越大，地址就越靠近栈底部，<br>由于i首先分配的，所以i的地址比arr[2]大，且类型都是int，如果存在arr[3]的话正好是arr[3]的地址<br>当访问arr[3]的时候越界访问到i<br><br>|||||||||||||||||||||<br>|||||||||||||||||||||<br>|||||||||||||||||||||  空闲空间<br>||||| arr[0] ||||<br>||||| arr[1] ||||<br>||||| arr[2] ||||   arr入栈<br>|||||   i      ||||   i首先入栈<br>     栈<br></div> <span class="time">2018-12-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Geek_04e22a</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1、java标记清除:gcroot 不可达，标记清除标识，然后统一删除<br>2、二维数组m*n<br>a=base_addr+（i*n+j）</div> <span class="time">2018-12-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/91/4c/32c9403c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">面朝大海</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">gc 判断是否存活，最简单的是用引用数，但是又缺点，如果2个对象相互引用，这样的对象就无法回收，目前大部分的机器都是可达性，这种可达性具体实现是由图实现的。<br>对于gc产生的碎片，在年轻带中，因为复制清理，这种碎片不多；产生碎片主要是老年代，但老年代又标记清理，和标记整理，标记整理会产生的碎片理论上是没有的。<br>具体的清理：内存使用打到了设定的大小，产生gc，首先会标记一次，执行预处理操作，然后又再次标记操作，最后执行删除，这种事老年代执行的gc算法。<br>老师，我理解的对吗？<br>这里有个疑问，线性表是连续的储存空间，但是，链表的结构，决定了链表数据的寻址是由每节链存储的内存地址去寻找上一个，或者下一个，所以，链表不是连续的存储空间存储的吧？</div> <span class="time">2018-12-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/9c/85/9c920838.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">宇</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">问个小白问题。 这里的讲解数组中元素的数据类型是相同的， 在php中数据的元素类型是不同的， 或者在go中可以定义interface{}类型的切片，像这种数组的任意访问是怎么寻址的呢？</div> <span class="time">2018-12-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/91/74/aaaa8838.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">↗晴¤天</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对于java 标记清除算法，虽然有评论里那位朋友说的缺点，如会产生不连续的内存空间，但标记清除算法可以有效的处理两个互相持有对方引用的对象内存而无法被清除的情况！</div> <span class="time">2018-12-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/88/94/169d4e44.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">🍀Yan的么擦黑烫唔子🐽</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">jvm 标记清除会产生内存碎片，标记压缩会释放连续内存空间</div> <span class="time">2018-12-13</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/36/61/8863e18c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">XiangJiawei</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">最大的收获应该是老师提到的数组随机访问快，指的是基于已知下标的前提下。</div> <span class="time">2018-12-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">泉</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">标记清除法分为标记和清除两个过程，java gc会遍历可达的元素，标记为1，然后清除未被标记的，回收内存</div> <span class="time">2018-12-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/3d/6c/935bdc7d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">‭‭</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)&#47;n=O(n)。不是有n+1插入情况</div> <span class="time">2018-12-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/61/c1/e8603a19.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mr_杨</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看似简单，是因为知道的少啊，受教</div> <span class="time">2018-12-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/0d/02/4f4484f6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Zahputor</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师我有几个问题想请教一下：<br>1.为什么数组执行尾端插入时间复杂度是O（1）而不是O（0），如果说是对插入这个数本身计算了一个复杂度，为什么在数组首部插入不是O（n+1)而是O（n)?还是说这个复杂度是看声明时候的空间a[10]={1,2,3},尾部插入是执行a[3]=x;首部插入是a[0]=x...a[9]=a[8]?<br>2.为什么说在位置K插入一个数可以将k位置的元素放到末尾，那我这样访问数组时候的顺序就变化了吗？比如我数组是还是上面的a，我在1位置插入值4，那数组变成{1,4,3,2},但是我想要的效果是{1,4,2,3}，和我实际想要的效果不同，还是说这边只是说对一个方法的封装？只是一个方法的思路？<br>请老师指点迷津，谢谢！</div> <span class="time">2018-12-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e6/50/656a0012.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">王楚然</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">js是弱类型语言，那么js的数组是怎么做到可以存储不同类型数据而且支持随机访问的呢？</div> <span class="time">2018-12-07</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">存的应该是对象的地址吧</p> <p class="reply-time">2018-12-10</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/63/d4/f44f7015.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">hzlzh</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我看见很多人的课后总结，对数组的定义，是没经过自己的思考直接照搬原文呢，还是说都是学强类型语言的，像JS的数组中，元素的数据类型就不一定必须要是同一种类型啊！可以是字符串，也可以是整数，浮点数</div> <span class="time">2018-12-07</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">那个已经不是数组了</p> <p class="reply-time">2018-12-07</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/3a/4f/92df5916.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小小</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">又一节结束，加油(ง •̀_•́)ง</div> <span class="time">2018-12-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/27/06/b38cdd37.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Brandon</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组这种基础数据结构的精髓是什么？随机存取，指定大小------线性（一前一后） 连续空间，相同数据类型<br>java中有对应的容器<br><br>数组，链表，队列，栈 都是线性表；非线性 图和树<br>数组长于------随机访问------移动数组<br>链表长于------插入删除------遍历<br><br>数组<br>两个思考题都没有答上来：<br>先标记再删除<br><br>来历：结合内存分配特点而存在<br>特点：随机访问，插入删除需要移动，或者标记  <br>适合解决的问题：随机访问<br>实际应用：jvm内存管理</div> <span class="time">2018-12-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/55/a9/08ba9ecd.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Acrisius</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对JVM不太了解，我把这个算法类比成mysql更新操作中redo log跟change buffer的作用，先缓存更新操作，减少对数据IO操作和刷新索引，等到mysql处于闲暇时间或更新操作记录足够多的时候再统一进行更新操作，不是正不正确这个类比</div> <span class="time">2018-12-06</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-12-07</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/65/06/9c87322e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">zhangxy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">您好,文中提到的寻址公式a[i]_address = base_address + i * data_type_size.在Object[]中也是适用的吗?毕竟Object[]可以存放任何类型,int,String,各种对象实例等,这时候data_type_size是不是就不一样了?哪位大佬给解惑一下</div> <span class="time">2018-12-06</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">存的是指针 不是对象本身</p> <p class="reply-time">2018-12-07</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/a3/40/e0df3b84.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">力挽狂澜爆炸输出的臭臭宁</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看到数据插入和删除的优化（尤其引到了JVM垃圾回收上）的时候感觉非常妙，开拓了新思路</div> <span class="time">2018-12-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/50/4a/50275b50.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">飘澪忘川</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">读后总结：<br><br>1、数组是什么<br>数组是用来存储一组具有相同类型数据的一组连续内存空间。是一种线性数据结构。<br><br>2、数组的特性以及优缺点<br>特性：连续的内存空间和相同类型的数据。<br>优点：具有随机访问的特性。<br>缺点：删除，插入数据效率低<br><br>3、如何实现随机下标访问<br><br>根据数组内存首地址和每个数组元素的大小去计算<br><br>一维数组：a[i]_address = base_address + i * data_type_size<br>二维数组：Array[m][n]， a[i][j]_address=base_address + (i*n+j)*data_type_size<br><br>4、提高数组的插入删除效率<br>将多次删除操作中集中在一起执行，可以先记录已经删除的数据，但是不进行数据迁移，而仅仅是记录，当发现没有更多空间存储时，再执行真正的删除操作。<br><br>5、数组为什么下标从0开始<br>依据数组实现随机下标访问的原理，如果从1开始，会多执行一次减法运算。这是不必要的浪费。也有一方面历史原因在里面。<br><br>6、文中关于死循环的问题<br>这个在不同的架构上以及不同的编辑器上的结果是不一样的。需要自己动手去试。<br><br>另外，并不懂Java，对JVM没有一点的了解，所以没做总结。</div> <span class="time">2018-12-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/40/d8/69722032.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">野马</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师好，我想知道内存空间是由计算机中的谁分配的？</div> <span class="time">2018-12-05</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">操作系统 软件层面的</p> <p class="reply-time">2018-12-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/4RTKnq96jsQoEnUHhBBzVVpib5oNIPHiaLozyKlEH0oLk6D06TNtG6WHWZFiaCaaiac1ojtn5Q4NzZJYfn14vOvd8Q/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">韦康</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>a[3]为何这个地址恰好是变量i的地址呢</div> <span class="time">2018-12-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f8/b8/b7af1005.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">邱菊</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，这个路径下：algo&#47;c-cpp&#47;05_array&#47;的代码，可以缺少一个array.h文件，现在只有如下三个文件能帮忙补全吗？谢谢您！<br> Array_gp.c <br> Array_gp.h<br> array.c </div> <span class="time">2018-12-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ec/ea/c33e5a3d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">何领</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回来再读一遍，第一次看时没弄懂的东西终于懂了，开心！😊<br>但同时也明白了自己基础好差，难过！😔</div> <span class="time">2018-12-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/40/5b/3fe51d4a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">左胜利</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">标记清除算法分为两个部分：<br>1、标记：程序将所有的对象引用关系看作一张图，然后从一个GC ROOT开始，寻找对应的引用节点，然后继续寻找此节点对应的引用节点，当所有的节点寻找完后，那些没有没有被遍历到的对象节点就被标记为不可用。<br>2、清理：在标记完成后，统一回收那些被标记的对象<br><br>标记清除算法的优劣势：<br>优势：不需要进行对象的移动，只清理被标记的对象，简单<br>劣势：1、标记和清除的效率都比较低 2、会产生大量的内存碎片，当程序需要为大对象分配内存的时候因为无法找到足够的连续内存而提前触发垃圾搜集的动作。</div> <span class="time">2018-12-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f8/b8/b7af1005.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">邱菊</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师想问一下，git上c-pp的代码那三个文件可以运行起来吗？是c还是c++</div> <span class="time">2018-12-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">都是其他同学上传的 暂时还没时间整理 不确定能不能运行</p> <p class="reply-time">2018-12-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/90/4e/6b084930.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">墨禾</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">		一般我们都是 这样用index==0，为啥这里要 0 == index，之间有何区别呢？	<br>                if(0 == index ){<br>				<br>				data[j+1] = tmp[index+1];<br>			<br>			}else{<br>					<br>				data[j+1] = tmp[index-1];<br>				<br>			}</div> <span class="time">2018-12-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e7/cd/91126163.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Semon</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。.当数组没有更多空间存储数据时，我们再触发执行一次真正的删除。<br>这句话我还是不太明白。</div> <span class="time">2018-11-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/b4/39/d9429b27.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">黄宇婷</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">假设数组大小为M*N<br>a[j][k]_address = base_address + (j*N + k)*type_size<br>超感谢留言的大神！涨了很多知识！</div> <span class="time">2018-11-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/9e/b5/17ff83e6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Leo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于二维数组的计算方式：<br>二维数组首先它在内存中也是一块连续的内存地址。一个a[m][n]的二维数组，可以想象成一个a[m*n]的一维数组，跟a[m][n]二维数组长度是一致的。只是把一维数组分割成了m份，每一份的首地址就是a[m][0]，每一份数组的长度是n。一个a[5][3]长度的二维数组的地址计算公式就是：a[i][j]_address = base_address+(i*3+j)*type_size；</div> <span class="time">2018-11-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">匆匆</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组篇总结<br>数组特点：1、一种线性表 ；2、连续内存空间；3、储存相同类型数据；4、可随机访问；<br><br>线性表有哪些？：数组、队列、栈、链表；<br><br>非线性表有哪些？：树、图等；<br><br>数组的随机访问十分方便，复杂度为O(1)；但插入和删除比较低效，复杂度为O(n)，若追求性能则需要对插入和删除操作使用一些特殊的算法（比如标记删除）;<br>另外数组的使用要谨防内存越界，因为越界后可能程序并不报错，不容易debug；<br><br>所以一般业务开发使用时可以考虑使用容器，省时省力，但是最底层的东西比如网络框架的搭建，则最好使用数组以追求性能的极致；<br><br>最后数组的开头下标为什么是0呢？：主要有两点因素1、数组下标含义为“偏移”。内存地址计算为a[k]_address = base_address + k * type_size，若从1开始的话，底层的内存计算需要多计算一步k+1，这在性能上影响较大。2、最开始的C语言设计者是以0为开始，后面的各种语言则习惯性沿袭以减少程序员的学习成本。<br></div> <span class="time">2018-11-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">郑一一</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组属于线性表一种。<br>通过下标访问，时间复杂度为1。<br>删除，插入，效率比较低。<br>为什么下标是从0开始呢？因为代表的是偏移量。<br>C 语言中没有越界的做法。<br>高级语言中的容器类用在业务开发中足够了。</div> <span class="time">2018-11-28</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">探索无止境</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师你好，经过优化后的删除算法，只是将多次删除变成一次删除，而这一次删除时间复杂度依然是O（n），不知道是否正确，求指正</div> <span class="time">2018-11-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/e9/0b/53bf91d3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">WL</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题:<br>1. 标记整理算法和标记清楚算法都是在线程处于安全点或安全区域的时候通过可达性分析算法对堆中的对象是否有引用进行逐个标记, 在本轮标记结束后进行统一的整理和清除.<br>2. 对于array[m][n], 有array[i,j]_address = array[0,0]_address + (i*n+j)*type_size</div> <span class="time">2018-11-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/e9/0b/53bf91d3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">WL</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">11月27日<br>把该讲内容总结为几个问题, 大家复习的时候可以先尝试回答这些问题检查自己的掌握程度:<br><br>	1. <br>数组的概念是什么? 什么叫做线性表? 什么叫连续的内存空间和相同的类型的数据?<br>	2. <br>数组为什么可以实现高效的随机访问?<br>	3. <br>插入和删除的时间复杂度是多少, 为什么对于数组这两种操作是低效的? 各有什么改进方法? 哪些应用体现了这种思想.<br>	4. <br>容器和数组的共同点和不同点各是什么?<br>	5. <br>数组为什么从0开始计数?<br><br></div> <span class="time">2018-11-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/32/b2/e22bb496.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">AdmaBoy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">Jvm不太了解，二维数组的地址公式为<br>a[i][j]_address = base_address +(i*max +j)*data_type_size  其中max为定义的二维数组列数</div> <span class="time">2018-11-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/17/ab/c0235b70.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">遥遥无妻</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">麻烦问下，a[k]_address = base_address + k * type_size<br>在这个寻址公式中，typesize如果是一个对象的话怎么算呢，例子中用的是基本数据类型所以知道大小。</div> <span class="time">2018-11-26</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对象的话 看看存储的是对象的内存地址还是对象本身 不管哪种 都是有大小的</p> <p class="reply-time">2018-11-27</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/3c/94/fe14d548.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">nan</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">，base+（i*n+j)  *  type_size</div> <span class="time">2018-11-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ec/89/681d9b13.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小一</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1. Java的标记清除内存回收算法:<br>Java主要是针对堆内存进行回收，而堆内存中，根据对象的存活时间又分为青年代、老年代、永久代。标记清除主要是青年代的回收算法。青年代将内存进一步分为三个区域，首先对前两个区域进行可达性分析扫描，存活的对象转移到第三个区域，扫描完成后将前两个区域的内存清空.<br><br>2. 二维数组的内存寻址公式：<br>假定二维数组为m行n列，每个元素占用b个字节, 那a[i][j]的内存地址为: base_address + (i * n + j) * b </div> <span class="time">2018-11-24</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/4IFchWxKIxKZP8w5JUyibwxqsx6kjyIIxqdVgNBHdlS4V1XtSV5G0ItXFMvYz9kibZ3RtVZRXia29QhEiccz1wBmsQ/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">泰宁</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">作为一名资深潜水党，一般听完课程。做好自己的幕布笔记。就进入下一课程了。今天在吃完番茄钟的休息时间。突然不知道为啥，兴致大发，看了一下留言。才发现。牛人杠杠，小白也忒多。老王出专栏不容易。回答问题起来，估计也是，情绪也估计如同股市上上下下。建议极客时间，帮助专栏作者搞一个小姐姐助理。</div> <span class="time">2018-11-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d3/15/1981c142.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">寒江雪</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师关于数组插入和删除的特殊情况分析，还是很有参考价值的</div> <span class="time">2018-11-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/72/c0/b09911a0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">meijing0114</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">文中的两个trick让人印象深刻，一个是删除某个下标元素的时候，标记删除再统一处理。还有一个是插入元素的时候，将对应位置元素预置到数组的后方。</div> <span class="time">2018-11-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/5d/89/93b837d6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">halo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>请问  为什么a[3]=0就相当于i＝0？</div> <span class="time">2018-11-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/62/a7/a86da59a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">K战神</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组插入元素，需要判断原来基础上是否可以申请连续内存？有就插入。没有，申请新的内存然后拷贝？</div> <span class="time">2018-11-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">飞飞</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">int main(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\n&quot;);<br>    }<br>    return 0;<br>}<br>这段代码不一定会循环输出“hello world”，应该是回报一个内存错误。GCC编译，Linux上测试过了。</div> <span class="time">2018-11-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/22/9f/5aabeeae.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">你爽</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师您好，按照之前优化插入的逻辑，删除的时候，直接用最末尾的一个数据去覆盖要删除的数据，然后把最末尾的数据删掉，也是很节省性能的？</div> <span class="time">2018-11-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/96/82/44f72ed6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Legolas</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>请问为什么越界访问后，a[3]的内存地址正好会是i的地址？ 计数器i 不是在数组之前定义的吗？</div> <span class="time">2018-11-15</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">看看留言里其他盆友的解释吧</p> <p class="reply-time">2018-11-15</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/bf/0e/eae05ad9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">我们都是大好青年🙌</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师好，同学好，刚开始学习数据结构，我把我知道的也写在留言中，如果大家发现有不对的地方，热烈欢迎指导！<br>python也有垃圾回收机制，python通过对引用对象计数的方式，当某个对象的引用计数为0时，对该对象进行回收，并释放内存，暂时存放于python自带的内存池中，方便使用(pymolic)。<br></div> <span class="time">2018-11-14</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-11-15</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/c7/67/0077314b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">田佳伟</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，文中举的例子是int型的数组，预先知道长度，可以快速随机访问，那么如果是字符串数组呢？内存怎么分配和快速随机访问？（不懂C语言，所以问了这么个小白的问题）</div> <span class="time">2018-11-13</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/3a/b3/97945ef8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Hansen</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我在Xcode试了下无限循环的C语言代码，可能xcode开启了堆栈保护，我也不知道在哪关闭。。。然后我在执行完a[3]就崩溃了。看了很多留言都说是a[3]的地址会覆盖i地址，但是我打印地址的时候数组的地址分配是从高到低分配的，而i的地址总是高于arr的首地址，如果一直往下溢出，a[n]的地址也不会覆盖i的地址啊（如果往下分配到0的时候，会从首地址往上进行分配地址？）。我觉得我肯定哪里理解错了！ 求解</div> <span class="time">2018-11-13</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿官(^･ｪ･^)</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">王老师，你好<br>我是极客小透明<br>关于上节课数组越界无限循环的问题，看了其他同学分享的解答和资料，自己也上网找了一些，大概都能理解。我想自己尝试用java做一下实验，看一下局部变量栈的分配，应该怎么查看呢？网路上找了半天没找着，不知道是不是我的关键词没选对：如何查看java局部变量内存地址？？</div> <span class="time">2018-11-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">直接把地址打印出来看呢？</p> <p class="reply-time">2018-11-12</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">cw</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">地址=base_adress+（i*n+j）*count_adress<br>标记回收 分为两步：标记，回收。如果没有引用乐，就会被回收、常用于老年代。先标记，当内存（也可以当作数组没有空间时）触发回收算法。</div> <span class="time">2018-11-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/07/3f/53ae01f6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Kevin.zhang🌏</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">那个死循环程序可以有多种解决办法(deepin linux15.5下gcc编译测试通过)：<br>１．错开地址法<br>   改之前：<br>　　　　　　int i = 0;　 <br>　　　　　　int arr[3] = {0};<br>　改之后：　int i=0, j=8;　 &#47;&#47; 增加一个变量，使　i　不再占用　arr[3]<br>　　　　　　int arr[3] = {0};<br> 2 .   修改循环变量法<br>   改之前：   <br>                       for(; i&lt;=3; i++){<br>                                  arr[i] =0;<br>　改之后：　<br>                        for(; i&lt;=3; i++){<br>                                  arr[i] =8;   &#47;&#47; &gt;=3的数都可以 </div> <span class="time">2018-11-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/eb/e4/dabff318.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">邵峰</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">假如一个长为10的数组，我要删除第2，4，8个元素，怎样用一次搬移删除，哪位大佬用代码实现下？</div> <span class="time">2018-11-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/62/a7/a86da59a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">K战神</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">评论中卧虎藏龙，我看不懂</div> <span class="time">2018-11-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/53/ab/6c07638a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">MissSunday</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这章就是讲了数组的相关内容。结构（连续内存空间）特点（查询快）缺点（插入和删除）。有趣的问题数组下标为何是由0开始的？jvm标记清除的思想由来。</div> <span class="time">2018-11-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">无名</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">jdk 1.8中的ArrayList源码实现中，看到了扩容机制，但为何没有看到缩容算法啊？是我没看懂还是？</div> <span class="time">2018-11-05</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">应该是没有缩容</p> <p class="reply-time">2018-11-06</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/4b/d6/cf5d806b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">日拱一卒</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不太明白数组压栈的顺序先是a[2]、再是a[1]、最后才是a[0]，希望老师能解答下。</div> <span class="time">2018-11-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/48/de/9fdad383.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">CHEN川</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">大部分留言关于垃圾回收算法的说法都是正确的，但有一点请注意，这是原则性问题。垃圾回收算法中被标记的对象都是活的，是活的，被删除的对象不是这些“活”的对象，只是通过标记“活”的对象，找到“死的”对象，然后清理。</div> <span class="time">2018-11-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0c/30/a2e7728a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Allen</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于文中提到的实例，数组越界为什么会循环打印helo world，这是栈布局结构有关，一般的栈的压栈顺序是函数参数，按照倒序压栈，接着是函数返回值，再次是局部变量，局部变量的压栈顺序是后定义的先压栈，所以变量i的地址是在a[3]的高地址，当数组a越界，就会指向i的地址，因此会出现循环打印，如果把变量i的定义个数组位置变换一下，结果也就不一样了</div> <span class="time">2018-11-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/de/5d/307b4ee7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Kim</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">还是不太明白数组中删除时标记算法的含义，到最后难道不需要数组数据搬移么？</div> <span class="time">2018-10-31</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">需要的 这里多次搬移优化为一次搬移</p> <p class="reply-time">2018-11-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/07/08/0fc1bba6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Walton</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组寻址方式<br>第一步<br>a[k]_address = base_address + k*type_size<br>第二步<br>a[k][i]_address =a[k][0]_address  + i*type_size</div> <span class="time">2018-10-31</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/42/9d/c36b7ef7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">顾骨</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">无限循环的很有意思：   <br>0x0000000000400574 &lt;+8&gt;:     movq   $0x0,-0x10(%rbp)<br>0x000000000040057c &lt;+16&gt;:    movl   $0x0,-0x8(%rbp)<br>0x0000000000400583 &lt;+23&gt;:    movl   $0x0,-0x4(%rbp)<br>a[0]的地址是-0x10(%rbp)<br>a[1]的地址是-0xc(%rbp)<br>a[2]的地址是-0x8(%rbp)<br>i的地址是-0x4(%rbp)<br>按照数组内存连续的原则，那么a[3]的地址就是-0x4(%rbp)，和i的地址重合了，i又重新变为0了。<br>这个和缓冲区溢出攻击是同一个道理，有意思<br><br></div> <span class="time">2018-10-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/4e/5a/4c61cd94.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">黑喵酱</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可...<br><br>极客时间版权所有: https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;40961<br>这个例子里的做法 似乎叫 lazy deletion？~</div> <span class="time">2018-10-30</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">哈哈 可以这么叫</p> <p class="reply-time">2018-10-31</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/76/3c/c65912b7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">逾清风</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组是一个线性表结构，用一段连续的内存，来存储具有相同类型的数据。<br>缺点：<br>数组具有低效的插入和删除操作，数组的插入和删除操作的最坏时间复杂度是O(n)，最好是O(1)，平均时间复杂度是O(n)。<br>另外，数组在访问时存在访问越界问题。<br><br>下标从0开始确切的可定义为偏移，a表示首地址，a[k]表示偏移k个type_size的位置。元素位置计算公式：<br>a[k]_address = base_address + k * type_size</div> <span class="time">2018-10-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/84/be/105df233.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">江雨</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。<br>没懂，如果数据没有规律，为何不直接将新插的数据添加到末尾，还要拷贝k位置数据？</div> <span class="time">2018-10-29</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">学到后面就懂了</p> <p class="reply-time">2018-10-29</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">落叶飞逝的恋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，问个问题，看了Java ArrayList源码，其中的add方法，为什么要判断if (index &gt; size || index &lt; 0)。其中index&lt;0判断可以理解，因为索引是不能为负数。但是为什么要判断插入指定的索引不能大于当前数组元素的个数。如果大于了，那么我这个默认为null，不行吗？</div> <span class="time">2018-10-28</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我是不想数组中的数据之间有空隙</p> <p class="reply-time">2018-10-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/d9/c6/a295275b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">o</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">大佬，对于开篇的问题。我有另外一个想法，就是内存最终是按照位来运算的，也就是说，最简单的二进制数字是0，不知道是不是这样也算合理的原因之一？</div> <span class="time">2018-10-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/1f/8f/837a14a7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">拜雨</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">(1+2+…n)&#47;n=O(n)。不明白😭</div> <span class="time">2018-10-27</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">前面的和是n*(n+1)&#47;2 除以n就是(n+1)&#47;2，去掉系数，常数，不就是O(n)吗</p> <p class="reply-time">2018-10-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f9/25/fe4f4172.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">轩月</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">无限循环，到3的地址是变量i，把i改为0</div> <span class="time">2018-10-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/eb/d0/56977a90.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">吴峰</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组的概念：是一种线性表数据结构，用一串连续的内存空间，来存储一组具有相同类型的数据；<br><br>线性表的概念：数据排成像一条线一样的结构。包括数组、链表，队列，栈等；<br><br>非线性表：二叉树、堆、图<br><br>寻址公式：<br>a[i]_address = base_address + i * data_type_size<br>第i个数据的地址等于首地址加上i乘以i个元素的大小<br>data_type_size表示数据中每个元素的大小<br><br><br>插入操作：<br>如果在数组中插入的数据刚好在最后一位，则不需要移动数据，时间复杂度为O(1)；<br>如果在数组中插入的数据刚好在第一位，则需要移动数据，时间复杂度为O(n)；<br>平均则为（1+2+….+n）&#47;n=O(n)；<br>如果只是最简单的插入操作，不考虑排序等问题，则最快的插入操作为，将数据插入第i个位置，将i个位置放到n+1上<br>，则时间复杂度为O(1)<br><br>删除操作：<br>如果删除的数据是第一位，则需要移动数据，时间复杂度为O(n)<br>如果删除的数据是最后一位，则不需要移动数据，时间复杂度为O(1)<br>平均也为（1+2+….+n）&#47;n=O(n)；<br>由于删除的数据可能不是连续性的删除，所以我们可以将需要删除的数据标记下，等到出现连续的内存地址在统一删除，则将减少移动数据，此为标记-清除算法的概念<br>标记清除的缺点：<br>1、效率问题：标记和清除的效率不高；<br>2、碎片化严重，如果出现分配大对象时，无法找到连续内存则不得不执行垃圾收集动作<br>容器能否代替数组：<br>数组必须指定大小，<br>arrayList则包含了数组的基本操作，以及支持扩容，但是arrayList不支持基本类型；<br><br>关于为甚么数组必须从0开始的问题；<br>由于寻址公式为：a[i]_address = base_address + i * data_type_size<br>如果从1开始，则公示为a[i]_address = base_address + （i-1） * data_type_size<br>则相当于多一次减法运算<br>a[i][j]<br>因为二维数组，实际上便是矩阵；<br>假如数组为a*b（a行b列）<br>需要查找第i行第j列的地址，则行地址为(i*b)*data_type_size，列地址为j*data_type_size<br>则公式为base_address+(i*b)*data_type_size+(j*data_type_size)，即base_address+((i*b)+j)*data_type_size</div> <span class="time">2018-10-24</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e0/5e/87b47b4a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">1‰</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">无限循环那个还是不太理解</div> <span class="time">2018-10-24</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">看看留言区大牛们的留言吧</p> <p class="reply-time">2018-10-24</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/fb/06/0e6b6365.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">ForzaJuve</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">访问数组的本质就是访问一段连续内存  <br>a[i]_address = base_address + i * data_type_size<br>课中从复杂度分析方面解析了为什么数组访问快（随机访问，O1，原因见寻址公式）而增删慢（On）<br>编程以来只用容器从没用过数组，但如果确定需要存储数据大小，最好指定ArrayList大小，因为动态扩容需要涉及申请内存和搬迁数据，耗时影响一些效率。<br>数组在有些时候更合适，比如容器存储基本类型还涉及装箱操作<br><br>int main(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\n&quot;);<br>    }<br>    return 0;<br>}<br><br>这段c语言代码会神奇的无限循环，原因评论区藏龙卧虎，已有解释<br>对文中示例的无限循环有疑问的同学，建议去查函数调用的栈桢结构细节（操作系统或计算机体系结构的教材应该会讲到）。<br><br><br>函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。<br><br>例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环。。如果数组本身有4个元素 则这里不会出现死循环。。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了。</div> <span class="time">2018-10-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d6/39/6b45878d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">顾合</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">哈哈，有好多天没来学习了，现在来一波数组的总结~<br>1、什么是数组？<br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。它组不仅是一种编程语言中的数据类型，还是一种最基础的数据结构。<br><br>关键词：<br>1) 线性表(Linear List)：简单来说，数据像线一样的结构，如：数组，链表、队列、栈等；<br>    非线性表：数据之间并不是简单的前后关系；如：二叉树、堆、图等。<br>2) 连续的内存空间和相同类型的数据：正因为这两种限制，因此具有“随机访问”的特性！<br>    但同时也让数组的很多操作变得非常低效。<br><br>链表和数组的区别：链表适合插入、删除，时间复杂度 O(1)；数组适合查找，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br><br>“插入”和“删除”<br>插入：如果数组中存储的数据没有任何规律，要将某个数据插入到第 k 个位置，为避免大规模的数据搬移，可以将第 k 个位置的数据搬移到数组元素的最后，将新的元素之间放到第 k 个位置。<br>删除：若要删除多个数据，为避免剩余数据被多次搬移，我们可以先记录已经删除的数据，每次的删除并不是真正的搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br><br>什么是 JVM ? 记得查找资料了解了解！<br><br>警惕数组的访问越界<br>很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。<br><br>相比于容器，数组的优势：<br>(容器：数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。)<br>1) Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long类，而 <br>   Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，<br>   就可以选用数组。<br>2) 如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList 提供的大部分方法，也可以<br>    直接使用数组。<br>3) 当要表示多维数组时，用数组往往会更加直观。<br>总之，对于业务开发，直接使用容器就足够了，省时省力。但如果你是做一些非常底层的开发，优先选择数组。<br><br>为什么大多数编程语言中，数组要从 0 开始编号，而不是从1 开始呢？<br>从数组存储的内存模型上来看，“下标”最确切的定义应该是&quot;偏移 (offset)&quot;。a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就就表示偏移 k 个 type_size 的位置。<br>如果从 1 开始编号，每次随机访问数组元素都多了一次剪发运算，对 CPU 来说就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</div> <span class="time">2018-10-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d4/b5/b72b83f8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小小鹿</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师您好，java 版本 GenericArray 脚本中 remove函数有点疑问<br>1、为什么进行 size --; 之后执行 data[size] = null; 而不是先进行 data[size] = null;再进行size --; ？<br>2、当index == size 的时候 函数理应一个元素都不会移除，因为超过数组有效元素可读范围了，但是按照逻辑仍然会执行 size--; 这样实际上元素不就移除掉一个了吗？</div> <span class="time">2018-10-22</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">那个是其他同学写的 可能会有bug</p> <p class="reply-time">2018-10-23</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/5d/0b/b80080c3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">类星体Sisi</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组随机访问的时间复杂度是O(1)，插入和删除操作（改变长度）的时间复杂度是O(n)<br>链表随机访问的时间复杂度是O(n)，插入和删除操作的时间复杂度是O(1)</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小和尚笨南北</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">@杰杰 评论中写到将所有存活的对象进行标记。<br>我在深入理解Java虚拟机一书中所写的标记清除算法是标记要回收的对象。<br>老师解答一下。</div> <span class="time">2018-10-22</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">感觉都可以啊</p> <p class="reply-time">2018-10-22</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fb/f8/7fb99855.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">走走停停</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">总结<br>数组支持随机访问，按索引访问的时间复杂度为o1<br>链表更适合插入删除操作，时间复杂度为o1。<br>在数组插入元素的高效方法，用插入元素替换原来元素，将原来的元素放到末尾，这只适合顺序不影响数组本身的情况。<br>在数组高效删除的方法，将要删除的先记下，最后一起操作。<br>做底层开发时最好用数组，做容器时可以用arraylist</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/48/c2/3455f111.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">爱喝水的杯子</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">课后重点总结<br><br>什么是数组<br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br>线性表<br>线性表就是数据排成像一条线一样的结构。<br>常见的线性表结构：数组，链表、队列、栈等。<br><br>数组和链表区别<br>数组支持随机访问, 根据下标随机访问的时间复杂度为O(1), 数组是用一段连续的内存空间, 来存储类型一组类型相同的数据;而链表则相反<br><br>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1开始?<br>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。<br>如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置<br>所以计算 a[k] 的内存地址只需要用这个公式： a[k]_address = base_address + k * type_size;  二维数组寻址公式为: m×n二维数组 a[i][j] 地址 ＝base + （i × n + j）×type_size<br>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为： a[k]_address = base_address + (k-1)*type_size<br>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。<br> 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。<br>另外, 也和早期编程语言实现有关, 比如C语言开始就是从0开始, 后面的编程语言都沿用了这种方式<br>一些提高效率的思想或技巧:<br>例如数组元素可以是无序的, 则插入可以考虑直接插入第k个位置并把第k个位置元素搬移到末尾, 或直接插入末尾<br>标记删除思想(jvm的垃圾回收)可以对删除的元素进行标记,而不是真正删除, 当数组空间不够的时候再集中删除,减少搬移次数</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0c/77/d855bfb2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">L-where🍉</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组的随机性访问利用的是首地址递推法</div> <span class="time">2018-10-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0c/77/d855bfb2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">L-where🍉</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组的随机访问极其便利，且对于无序的数组，插入操作讲原位置元素搬运到最后就可以实现，令其复杂度为O（1），而不是平均时间复杂度的（1+2+3+4+……n）&#47;n的复杂度</div> <span class="time">2018-10-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">godtrue</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">阅过留痕<br><br>学过次节之后，感觉对于数组又加深了一些认识<br>1：数组这种数据类型在平时编程时使用的也挺多的，当然他不仅仅是一种数据类型，还是一种数据结构，这种数据结构的特点如下<br>线性的：元素之间在逻辑上有前后的关系<br>连续的：元素之间的物理内存空间具有连续性<br>相同类型的：每个元素开辟的存储空间大小是一样的<br><br>2：数据结果按照元素的结构特点来分类可以大体分为两类，一是线性表结构，二是非线性表结构，线性表结构的特点是元素之间在逻辑上有前后的逻辑关系，一个个元素拉平来看好像拴在一条绳子之上，比如：数组、链表、队列、栈等数据结构都是线性表结构的。非线性表结构的数据结构元素之间则是另外的一种关系，比如：树、图等元素之间的关系更加的复杂。<br>数组这种线性表结构的数据结构不但逻辑上是线性的连续的物理上也是线性的连续的。<br><br>3：数组的结构特点决定了它的功能特点或者操作特点，这应该就是结构决定功能，内因决定外形的道理吧！数组的最大特点就是能够实现数组元素的随机访问，它能随机访问的本质就是通过数组的元素的寻址公式 a[i]_address = base_address + i*data_type_size，这个寻址公式也暗含了数组这种数据结构的特点，比如：分配的内存是连续的、存储的数据类型是相同的。<br>当然，其他的特点，也是有其结构的特点决定的，比如：插入、删除元素相对较耗性能。但是根据数据的特点也是能够做出一些优化的，比如：插入的时候，如果是尾部，则不需要一定其他元素，如果是其他位置，则可以选择仅移动要插入位置的元素，然后将新元素插入到对应的位置，删除元素时也可以根据情况作出相应的优化，总之，少做事情，又懒又能实现相应的功能就行。<br><br>4：老师文中列举的例子，清楚方法内变量内存分配的很容易理解，不清楚的就费劲了，这个还要看具体的系统环境，是个好玩事情，要求有一定的功底，可以简单理解为，分配了四块内存，分别是<br>a[0]_a[1]_a[2]_i很不幸，当数组越界访问时就是访问a[3]时巧合相当于访问的同时也是i的内存地址，这样就容易理解无限循环的场景了，i的值一直会在0&#47;1&#47;2&#47;3内循环往复<br><br>5：高级编程语言都有对数组的封装，比如：java中有ArrayList，那么什么情况下还会照样使用数组呢？<br>5-1：存储基本类型的时候，因为ArrayList等不支持基本类型，为什么不支持基本类型，因为他们定义的时候，仅支持对象类型的数据，基本类型不是对象<br>5-2：事先已知长度，且操作简单，数组便可满足需要<br>5-3：表示多维的数组结构时<br>5-4：出于性能考量，数组更加的底层和纯粹，性能会更佳，这也是数组下标从0开始的一个原因<br><br>6：为什么数组的下标从0开始而非1或者其他？<br>原因有两个，<br>一是从性能的角度考量，随机访问数组中的某个元素的寻址公式，如果是从0开始，则会少做一次减法操作性能更好一点<br>二是历史原因，最初为什么这样来做，估计也和性能相关，毕竟大牛做事都会倾向于做大极致，把性能问题解决好了，才是真牛逼<br><br>7：数组删除的优化确实很像GC的标记清楚算法，可以将jvm的内存结构相像成为一个一组，最佳的删除元素的算法的核心思想本就是一样的吧！<br><br>8：二维数组，多为数组，本质上都是用一维数组来表现的，画个图自己推到一下公式是怎么样的吧！<br>     一维数组，每个元素的偏移大小是元素的数据类型大小<br>     a[i]_address = base_address + i*data_type_size<br>     二维数组，每个元素的偏移大小有第二维的数组长度加上数组元素类型的大小<br>     a[i][j]_address=base_address + (i*n+j)*data_type_size （对于m*n的数组而言）</div> <span class="time">2018-10-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Alexis何春光</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">那请问在Java具体实现中，array的插入是依次移动每一个还是做了优化呢？在实际编程中，如果是做了优化的话，是不是也不用太考虑数组插入的低效性了呢？</div> <span class="time">2018-10-20</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">怎么优化呢？感觉没啥优化的余地了。</p> <p class="reply-time">2018-10-20</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Alexis何春光</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。<br>这句话真的太棒了！解开了我的疑惑！</div> <span class="time">2018-10-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/66/71/8a5d02ab.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">蓝色~冰*羽</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组寻址公式为什么是address = base_address + ( i * n + j) * type_size啊？百度了半天，始终理解不了</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fd/b6/ccf614f5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">cruzyang</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，您好！文中导致死循环的例子，是因为在函数执行时参数压栈，变量i刚好就是a数组后面，访问时就直接赋值给i 了。<br></div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/2f/0a/abb7bfe3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">chris</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">自己实验了一下固定长度和非固定长度的arraylist的性能，发现在arrayList扩容的阈值内，不指定长度的性能比固定长度的要高，当超出arraylist扩容阈值后，固定长度的arraylist性能优势才会显现出来。</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/24/ff/4647e8a5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Benny</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师您好，<br><br>对a[i]_address = base_address + i * data_type_size有个疑问，麻烦解答下（可能已有相同问题，但是翻了很多没有发现存在）。<br><br>举例中若数组保存的数据类型是int型（或其他基本类型），所需存储空间默认是4个字节是固定不会变的，所以可以按照上面寻址公式根据数组下标随机访问。<br><br>但是在实际场景中数组中存放的可能是自定义类型的对象。例如用户对象User，由于User的信息并不都是一样的，所需的存储空间也并不都是一样的。<br><br>问题1：在往素组中存User对象时，数组已经申请了内存空间了，怎么保证单个元素默认的空间可以支持所有的User对象。<br><br>问题2：公式a[i]_address = base_address + i * data_type_size中data_type_size应该是动态的，那怎么根据公式随机访问。</div> <span class="time">2018-10-19</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">如果是java语言 那存储的就是引用 根本不是对象本身。如果是c语言 那既可以是指针 也可以是user对象 对象大小也确定的 不存在你说的大小不确定</p> <p class="reply-time">2018-10-20</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/42/94d45ca8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">霸王龙</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我给Java开发者拖后腿了 做了这么久的开发并没有详细的了解过JVM 我要去继续好好学习了</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/a0/07/8d91021c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Fisher</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1、JVM标记-清除（mark-sweep）算法是最基础的垃圾收集算法，如同它的名字一样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的缺点有两个。一个是效率问题，一个是空间问题。<br>顺着这条线，一并查看了java的四种引用方式：strong reference,soft reference,weak reference and phantom reference。<br>2、数组的内存存储方式是连续的。java中的数组没有多维数组，不管是几维数组，java都按照一维数组来处理。假设二维数组有m*n个元素，二维数组的寻址公式：a[i][j]_address = base_address+(i*n+j)*data_type_size。</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">朝夕心</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">今日所学：<br>线性表：数据呈直线排列，数据之间的关系只有「前后」就能表示<br>定义：数组，是线性表数据结构，用一组连续的内存空间，存储相同类型的数据<br>使用场景：数组适合随机访问，不适合增删。<br>提高「增」的效率可以将被替换元素放到数组末尾，时间复杂度有O(n)--&gt;O(1)<br>提高「删」的效率可以将多次删除先进行标记，再进行统一删除，将多次O(n)变为一次O(n)操作<br>ArrayList封装了array，好处是自动扩容、增删操作的封装。如果存储的元素个数确定，则直接创建固定长度的ArrayList，减少扩容带来的开销。<br>数组从0开始标记，在随机访问元素时减少了一次减法计算，真真的佩服设计者~，也体现了算法的魅力</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/2c/9d/e5af3fd4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Novapath ☀</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">05 数组<br><br>一. 数组可以实现随机访问<br><br>1.1 数组是一种线性数据结构，用连续的存储空间存储相同类型数据；<br><br>i.线性数据结构：数组、链表、队列、栈；<br>非线性数据结构：树、图；<br>ii. 数组是连续的内存空间、存储着相同类型的数据，所以数组可以随机访问；<br>iii. 对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作<br>1.2 数组如何实现下标随机访问<br><br>引入数组再内存种的分配图，得出寻址公式a[i]_address = base_address + i * data_type_size；其中data_type_size表示每个元素的大小；<br><br>1.3 纠正数组和链表的错误认识<br><br>数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。 正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。<br><br>二. 数组特点：低效的插入和删除<br><br>插入方法1<br>从数组末尾插入数据情况最好，时间复杂度为O(1)；<br>从数组开头插入数据，所有的数据往后移一位，情况最差，时间复杂度为O(n) ；<br>每一位插入的概率一样，所以平均时间复杂度为(1+2+...+n)&#47;n = (1+n)&#47;2 = O(n)<br><br>插入方法2<br>数组若无序，插入新的元素时，可以将第k个位置元素移动到数组末尾，把新的元素插入到第k个位置，此处时间复杂度为O(1)。<br><br>删除方法1<br>删除数组末尾的数据，最好情况时间复杂度O(1)；<br>删除数组开头数据，最坏情况时间复杂度O(n)；<br>平均时间复杂度O(n)<br><br>删除方法2<br>多次删除集中在一起，提高删除效率。<br>记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空，时，再触发一次真正的删除操作，即JVM标记清除垃圾回收算法核心思想。<br>eg.房间里有个垃圾桶（数组），把垃圾（删除记录数据）丢进去垃圾（数据）并不会消失，当垃圾桶（数组）装满之后，再把垃圾拿出去倒掉（真正删除）。<br><br>三. 数组的访问越界问题<br><br>无限循环例题：<br>出现原因：C语言没有规定数组访问越界时编译器会如何处理，如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。<br><br>详细解释：<br>栈从高位到低位增长的；<br>先把变量i分配到最底下格子的内存；变量arr往上以此分配三个内存；i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]；<br>通过寻址公式，当访问到a[3]的时候，计算得到a[3]的地址恰好是变量i的存储地址，相当于i=0<br><br>四. 容器能否完全替代数组<br>相比于数组，Java中的ArrayList封装了数组的很多操作，并支持动态扩容。扩容时比较消耗内存，因为涉及到内存申请和数据搬移。<br>数组适合的场景：<br>Java ArrayList的使用涉及装箱拆箱，有一定的性能损耗，关注性能，或者希望使用基本类型，就可以选用数组；<br>数据大小事先已知，并且涉及的数据操作非常简单，使用数组；<br>表示多维数组时，数组往往更加直观；<br>业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。<br><br>五. 解答开篇问题<br>Q：为什么大多数编程语言从0开始编号，而不是1？<br>A1：从偏移角度理解a[0]，0为偏移量（offset），如果从1计数，每个数组元素会多出1次减法计算，增加cpu负担；<br>A2：一定的历史原因，C语言首先使用，后面Java等效仿；不过如MATLAB就不是从0开始，Python还支持负数下标。<br><br>六.课后思考<br>Q1：说说你理解ed标记清除垃圾回收算法。<br>A1：房间里有个垃圾桶（数组），把垃圾（删除记录数据）丢进去垃圾（数据）并不会消失，当垃圾桶（数组）装满之后，再把垃圾拿出去倒掉（真正删除）。<br><br>Q2：二维数组的寻址公式是怎样的？<br>A2：一维数组a[n]的寻址公式为：a[i]_address = base_address + i * type_size；<br>类比得到，二维数组a[m][n]要找第i行第j列的元素时，a[i][j]_address = base_address + ( i * n + j) * type_size</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Jerry银银</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">今天刚买专栏，看的第一篇就是数组。因为前段时间补了一下算法知识，再加上工作这么多年的沉淀，重新刷新了一下数组知识。<br><br>今天看完作者介绍完数组，从内心深处已经认可了作者的水平，点个👍<br><br>个人认为，算法功底扎实不扎实，对算法理解深不深，聊聊数组和链表就能窥知一二</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/31/46/7e9e2d7e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Zz</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">快速排序中，partition部分那个思想能再清楚一点么。不是很明白，明白数组插入的操作。这个不是太懂。</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/81/ad/7d1a3422.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">大师兄_于硕</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师您好，关于数组删除小节有问题希望您解答一下。<br>数组删除a b c如何进行标记已删除（不进行其他数据的搬移）？<br>为什么不像前面cha入操作一样，把最后的元素覆盖到前面要删除的元素，类似于上一节插入那样，时间复杂度应该也是O(1)</div> <span class="time">2018-10-17</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">也可以的 你说的没错👍</p> <p class="reply-time">2018-10-17</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/ba/01/5ce8ce0b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">HardToGiveaName</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">希望老师多抛点东西出来，评论区大牛好多，受教了</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/57/1a/57e13b4d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">觉良</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">使用寻址公式要通过偏移将量k，从0开始减少计算</div> <span class="time">2018-10-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/cd/e0/242a3250.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">朱雯</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我也来写一些我的感悟<br>1:数组是连续的内存空间，存储一组具有相同的数据类型的数据。关于连续内存存在疑问，比如js数组可以存储不同的数据类型，但是我也可以强行将这个解释为对象。或者干脆认为js的数组并不是传统意义的数组，而是栈或者队列这样的线性表<br>2:数组的查找的时间复杂度并不是O(1),根据下标的随机访问特性才是时间复杂度才是O(1),插入和删除的时间复杂度为O(n)<br>3:为了解决低效的插入和删除操作，将采取特殊的方式解决，比如插入插入，将插入元素插入到某个位置，然后将该位置的数据移动移动到末尾，这样可以降低时间复杂度为O(1),删除操作可以将多次删除的操作计中到一次，提高一定的效率，但是这是特定情况下的操作。比如jvm标记清除算法(不懂java)<br>4：老师给的c语言的例子，再某些cpu或者操作系统可以实现，在另外一些不可以，取决于是否为小端法，压栈方式，编译器是否添加参数等<br>5：java容器arraylist在方法各种操作对数组做了很多封装，非常方便使用，还支持动态扩容，但是使用方便的代价就是牺牲一定的时间复杂度和空间复杂度,如果在性能要求比较高的地方，使用数组就会比较高 <br>6：数组编号从0开始，有一定的道理比如c语言的偏移量，python的切片优雅，但是根本的原因是历史的习惯原因，出自于节约计算机内存。<br><br>7:课后思考题第一题不会，因为不懂java和jvm 第二题大概公式为这个<br>address = base_address + ( i * n + j) * type_size</div> <span class="time">2018-10-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/cd/e0/242a3250.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">朱雯</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我也来写一些我的感悟<br>1:数组是连续的内存空间，存储一组具有相同的数据类型的数据。关于连续内存存在疑问，比如js数组可以存储不同的数据类型，但是我也可以强行将这个解释为对象。或者干脆认为js的数组并不是传统意义的数组，而是栈或者队列这样的线性表<br>2:数组的查找的时间复杂度并不是O(1),根据下标的随机访问特性才是时间复杂度才是O(1),插入和删除的时间复杂度为O(n)<br>3:为了解决低效的插入和删除操作，将采取特殊的方式解决，比如插入插入，将插入元素插入到某个位置，然后将该位置的数据移动移动到末尾，这样可以降低时间复杂度为O(1),删除操作可以将多次删除的操作计中到一次，提高一定的效率，但是这是特定情况下的操作。比如jvm标记清除算法(不懂java)<br>4：老师给的c语言的例子，再某些cpu或者操作系统可以实现，在另外一些不可以，取决于是否为小端法，压栈方式，编译器是否添加参数等<br>5：java容器arraylist在方法各种操作对数组做了很多封装，非常方便使用，还支持动态扩容，但是使用方便的代价就是牺牲一定的时间复杂度和空间复杂度,如果在性能要求比较高的地方，使用数组就会比较高 <br>6：数组编号从0开始，有一定的道理比如c语言的偏移量，python的切片优雅，但是根本的原因是历史的习惯原因，出自于节约计算机内存。<br><br>7:课后思考题第一题不会，因为不懂java和jvm 第二题大概公式为这个<br>address = base_address + ( i * n + j) * type_size</div> <span class="time">2018-10-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1f/99/0c773be9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">fish</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo&#47;blob&#47;master&#47;java&#47;05_array&#47;%08GenericArray.java中的add方法时间复杂度 O(m+n)，怎么理解呢，我的理解是m表示index到数组尾的元素个数，所以m&lt;=n的，所以不管是否扩容，时间复杂度直接就是O（n），不知道理解的对不对<br></div> <span class="time">2018-10-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0b/d0/a5eacd8c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Zherlock</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不熟悉jvm<br>二维数组寻址，肯定是<br>每一行长度为l,每一个元素长度为t<br>Array[a][b] ＝ start ＋(a)l ＋(b)t</div> <span class="time">2018-10-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/0e/7a992528.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小六子</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">“你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？”<br><br>同样的代码在我的电脑上（VS Community2015）只打印了四行，建议老师在“在这段大码的运行结果...”前面增加“在您的电脑上...在其他电脑或者编译器下也许结果会不同”来说明下。</div> <span class="time">2018-10-16</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">好</p> <p class="reply-time">2018-10-16</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e8/c1/e2cc1d04.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">海贼王</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师您好，能提供一版您的代码吗？有错我们可以通过其他分支的方式进行修改，如果每个人都修改您的代码就无法按照您可课件的思路进行理解了，这很容易让新学者产生误区，谢谢🙏</div> <span class="time">2018-10-15</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我考虑一下</p> <p class="reply-time">2018-10-16</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1b/00/aef3202e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">史帅</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，在java中的二维数组中，第一维度数组是必须要指定长度，第二维度数组在声明时非必须，即：二维数组在声明时并不一定初始化；而且在idea中使用DEBUG模式，第二维度的数组的内存地址，跟第一维度的内存地址并没有必然联系。在置顶的留言中address = base_address + ( i * n + j) * type_size这个公式至少是不适合于Java的。</div> <span class="time">2018-10-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/44/81/aa0b0b0e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">lennon</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如果是内存地址递减的方式，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循。有点不明白这一段，为什么递减的时候，就回到了i=0的位置呢，请指教</div> <span class="time">2018-10-15</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">请看下留言区其他同学的解释吧</p> <p class="reply-time">2018-10-15</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/ef/5e/381d043b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">向龙</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">--总结--<br>数组：<br>1. 线性表：数据最多只有前后两个方向，如：（数组，链表，队列，栈）<br>2. 一组连续的内存空间<br>3. 相同类型的数据<br>特点：随机访问<br>数组查找的时间复杂度并不是O(1)，数组的随机访问时间复杂度是O(1)<br>数组排好序，再用二分查找的时间复杂度也是O(logn)<br>非线性表：数据之间并不是简单地前后关系，如（树，堆，图）<br><br>数组的寻址地方计算方式为：a[i]_address = base_address + i * data_type_size<br><br>JVM的标记-清理垃圾回收算法：虚拟机采用可达性分析算法来判断对象是否存活，遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活，标记完成后进行清理工作（这种方式会有内存碎片的问题）<br><br>JVM的标记-整理垃圾回收算法：在标记清理垃圾回收算法的基础上，将所有存活的数据向一端移动，then，清理掉边界以为的内存。</div> <span class="time">2018-10-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/da/c9/ed1ac545.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Brighton王</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这节课干货满满，学到很多，谢谢老师o(^o^)o</div> <span class="time">2018-10-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">kakasi</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">补充: 列表容器与数组的选择。<br>业务开发基本可以选择列表，而底层可能要考虑数组。<br>列表对于数组而言优势是已经封装好，使用起来很方便，动态扩容也封装了。而劣势是，无法使用基本类型作为元素，对于包装类会有自动装箱损耗一些性能。<br>因此很简单的处理，并且知道数据大小，那么用数组吧，其他用列表。</div> <span class="time">2018-10-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/88/3b/d1b3a9e7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">黑化肥</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">有一个疑问，为什么oracle里面定义的数组都是从1开始呢？包括它的一些函数如substr 之类也是从1开始……</div> <span class="time">2018-10-14</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">从1还是0是习惯和喜好的问题 都可以的</p> <p class="reply-time">2018-10-14</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d7/fb/384ef0a1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">黑桃K</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">总结：<br>数组是线性表，区别于二叉树，图等。<br>数组内存连续，支持随机访问，通过下标访问的时间复杂度o（1），同时由于内存连续，插入删除，平均时间复杂度o（n），可以进行优化，例如插入时将插入位置移至最后，删除时，只进行标记，统一删除。<br>数组可能会导致越界访问，有些编译器不会检查，老师讲到的由于局部变量在栈中的内存地址由高到低增长，a（3）即为i的地址，所以会越界修改数据i。<br>容器相较于数组，可以省去很多操作，指定容器大小较好，也可以在需要性能的时候使用数组。<br>关于下标0开始问题，c语言历史遗留，且可以简化cpu运算。<br>问题：<br>jvm垃圾回收，标记阶段，标记可用的对象，清除阶段将不可用的全部清除。和数组删除的优化有异曲同工之妙。<br>二维数组，m行n列，则a[i][j] 地址为 基地址 加 i ✖m ➕ j</div> <span class="time">2018-10-13</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/d2/66/811970de.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">OP_未央</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">int main(int argc, char* argv[...<br>内存覆盖的问题，如果WIN系统是这样的，linux并非如此会按照结构体大小排序。仅个人测试结果，请正哥看一下，帮忙解答一下，谢谢！</div> <span class="time">2018-10-12</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">你可以看看留言区里其他同学的回复，都讲的很好了。</p> <p class="reply-time">2018-10-13</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">djane</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">【笔记】<br>一、如何实现随机访问？<br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>1、线性表：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。<br>（常见的线性表结构：数组，链表、队列、栈等。）<br>非线性表：二叉树、堆、图等。<br>2、连续的内存空间和相同类型的数据。<br>特性：“随机访问”。但让数组的很多操作变得非常低效。比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。<br>（数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。）<br><br>二、低效的“插入”和“删除”<br>1、在数组末尾插入元素，不需要移动数据，最好时间复杂度为 O(1)。<br>在数组开头插入元素，所有的数据都需要依次往后移动一位，最坏时间复杂度是 O(n)。<br>在每个位置插入元素的概率是一样的，平均情况时间复杂度为 (1+2+…n)&#47;n=O(n)。<br>2、删除数组末尾的数据，最好情况时间复杂度为 O(1)。<br>删除开头的数据，则最坏情况时间复杂度为 O(n)。<br>平均情况时间复杂度也为 O(n)。<br>（很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。）<br><br>三、警惕数组的访问越界问题<br>数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。这种情况下，一般都会出现莫名其妙的逻辑错误，debug 的难度非常的大。而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。<br><br>四、容器能否完全替代数组？<br>1、Java ArrayList 无法存储基本类型。特别关注性能，或者希望使用基本类型，就可以选用数组。<br>2、如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。<br>3、表示多维数组时，用数组往往会更加直观。<br>4、对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。<br>5、如果是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。<br><br>五、为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？<br>1、为了减少一次减法操作。如果从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。<br>2、历史原因。C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。<br><br>【思考】<br>1、JS标记清除垃圾回收算法<br>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。<br>（参考资料：https:&#47;&#47;developer.mozilla.org&#47;zh-CN&#47;docs&#47;Web&#47;JavaScript&#47;Memory_Management）<br><br>2、一维数组的内存寻址公式：a[i]_address = base_address + i * data_type_size<br>二维数组(a[m][n])的内存寻址公式：a[i][j] = base_address + (i*n+j) * data_type_size</div> <span class="time">2018-10-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">kakasi</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组的定义：线性表的数据结构。一组连续的内存空间，存储相同数据类型的数据。<br><br>数组的存储空间是连续的，元素的地址计算可以这样表示：address = first_address + i * data_type_size, data_type_size表示一个元素的字节大小，如int就是4个字节。这也是为什么数组一般都是从0开始，因为下标 i 其实代表“偏移量”，如果要从1开始的话就是address = first_address + （i - 1） * data_type_size 那么CPU就会多一次减法指令，是得不偿失的。<br><br>根据留言区大神的发言，也知道了为什么那段代码是无限循环的。不同的编译器分配内存空间时有递增和递减的方式。从这个示例中能看到 i 是在数组相邻的高地址，因此会直接访问到 i</div> <span class="time">2018-10-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/9b/00/8c1b9631.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">王建</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">代码中<br>int insert(struct array *array, int elem)<br><br>1 if (idx &lt; array-&gt;used)<br>2		memmove(&amp;array-&gt;arr[array-&gt;used], &amp;array-&gt;arr[idx],	(array-&gt;used - idx) * sizeof(int));<br>应该是<br>3 if (idx &lt; array-&gt;used)<br>4		memmove(&amp;array-&gt;arr[idx+1], &amp;array-&gt;arr[idx],	(array-&gt;used - idx) * sizeof(int));<br>为什么1，2 也能运行呢，没有看懂。测试了下当数组 元素和数组 相同时是是错的。没有找到原因</div> <span class="time">2018-10-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/cc/33/19f150d9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">城</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">个人对死循环问题，有点不一样的看法。在有堆栈溢出保护的情况下(一般编译器都有这个)，后定义的先入栈，而我们知道，栈的生长方向是从高地址到低地址。所以arr数组的地址是高于i的。因此出现不会死循环。如果堆栈保护关闭，则是先定义的入栈，就会出现死循环问题。</div> <span class="time">2018-10-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/dc/9d/e20b37d7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">马晓光</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">int main(int argc, char* argv[]){<br>    int i = 0;<br>    int arr[3] = {0};<br>    for(; i&lt;=3; i++){<br>        arr[i] = 0;<br>        printf(&quot;hello world\n&quot;);<br>    }<br>    return 0;<br>}<br>你好，我在java里调试此代码没有无限循环</div> <span class="time">2018-10-11</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">再看遍文章吧</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/b2/80/e9223398.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">glbfor.gtw</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">a[m][n] 数组，a[i][j] 的地址写成如下形式<br>更容易理解二维数组的内存存储结构<br>address = base_address + i * n  * type_size +  j * type_size<br>拆解：<br>a[i] 的address_i = base_address + i * n  * type_size<br>设定z = a[i]<br>则 z[j] = address_i  *  j  *  type_size<br>既 a[i][j] = address_i  *  j  *  type_size<br>代入既为最初公式</div> <span class="time">2018-10-11</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d4/4a/e921f579.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">hqx</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组中间没存值，会导致内存碎片，这不理解。<br>既然是数组了，那么整个内存就给数组用了，是业务决定的，不是内存分配器决定的。</div> <span class="time">2018-10-11</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我没说内存碎片呀</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/3a/43/6abf3b7d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">刘榴</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我有一个疑问：i 内存里的值不是一直变吗？因此访问 a[3] 的时候 i 值应该不是 0 ，而是 4。不知道理解对不对</div> <span class="time">2018-10-11</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我的意思是a[3]和i指向了同一个内存空间，a[3]=0就相当于i=0</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f4/3d/ec3d6348.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小白一只</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">评论的大佬好多，大佬们都如此努力，更加有动力学习了</div> <span class="time">2018-10-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">加油💪</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/31/65/15199a06.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Pineleen</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组是一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据。<br><br>线性表：数据排成一条线一样的结构。每个线性表上的数据最多只有前和后两个方向，是为线性表。<br>数组、链表、队列、栈都是线性表结构。<br><br>二叉树（每一个元素有分叉）、堆、图（数据互相有多个关系）是非线性表。<br><br>连续的内存空间，和相同数据类型，导致了数组最重要的特性：  可以随意访问数据。<br><br>随机访问的本质是 a[i]_addr = base_addr + i   *  data_type_size。 本质是地址可以通过下标进行换算，从而一步找到数据的地址。<br><br>对于数组的插入操作， 如果数组是有序的，需要移位， 如果数组是无序的，可以把要插入的元素放在最后，是O(n)的操作， 把要插入的值，赋值给对应的位上就可以了，是O(1)的操作。 如果需要移位的，其实可以用memcpy系统调用来做，不至于去一个个移位。<br><br>数组和链表的区别：<br>数组可以随机访问数据，复杂度是O(1)<br>链表访问数据的复杂度是O（n），链表的插入和删除操作简单，复杂度是O(1)。<br></div> <span class="time">2018-10-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/02/c3/e9026d82.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">张亮</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">面试回答数组适合查找，时间复杂度为O(1)我也干过。</div> <span class="time">2018-10-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">😂 很多人都这么回答</p> <p class="reply-time">2018-10-10</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f5/4b/76588b52.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mr.J</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组的寻址公式：a[k][j]_address = bass_address + k * type_k_size + j * type_j_size</div> <span class="time">2018-10-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">这个寻址公式看着有点奇怪 你可以看看留言区中其他同学的回复</p> <p class="reply-time">2018-10-10</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f5/4b/76588b52.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mr.J</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">JVM的垃圾回收机制，也是标记，他会标记两次，可达性分析之后，没有与GC Roots相连接的引用链，那它将会被第一次标记，第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。经过两次标记后，会执行一次删除操作，根据内存区域不同，执行不同的删除算法。</div> <span class="time">2018-10-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">qinggeouye</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">警惕数组越界问题，关于无限循环分析了讲解内容和留言区，总结如下：<br><br>    int main(int argc, char* argv[]){<br>        int i = 0;<br>        int arr[3] = 0;<br>        for(; i&lt;=3; i++){<br>            arr[i] = 0;<br>            printf(&quot;hello world\n&quot;);<br>        }<br>        return 0;<br>    }<br><br>结论：无限循环打印 &quot;hello world&quot; 。<br><br>原因：<br><br>1. 变量 i 和数组 arr 的数据类型相同<br>2. 变量 i 和数组 arr 申请的内存空间是连续的<br>3. 这里认为，编译器在内存分配时，按照内存地址递增或递减的方式进行分配。<br>4. 例如 栈是由高位向低位增长的，所以 i 和 数组 arr 的数据从高位地址到低位地址依次为 i, arr[2], arr[1], arr[0] 。<br>5. arr[3] 访问越界，通过寻址公式，对应的正好是 i 的存储地址，arr[3] 和 i 的存储地址相同，此时给 arr[3] 赋值 0 就相当于 i=0。<br>6. 数组越界在 C 语言中是一种未决行为，C 语言没有规定数组访问越界时编译器应该如何处理。访问数组本质上是访问一段连继内存，只要数组通过偏移计算得到的内存地址可用，那么程序不会报任何错误。<br></div> <span class="time">2018-10-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f6/28/91f222cb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">现禾霞</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">死循环的理解，可以参照深入理解计算机系统的p128对栈的讲述</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/bf/b5/55ba4cb2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">永远年轻</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1、GC 标记清除法: 对内存中不可达对象进行标记，累积到一定程度触发一次清除操作。<br>缺点：标记和清除的效率不高，会产生不连续的内存碎片。<br>2、<br>假设 int a[][] = new int[3][3]<br>申请了 1000 ~ 1035 的内存空间，因为此二维数组可以看作三个连续的数组:<br>a[0][0] ~ a[0][2]: 1000 ~ 1011<br>a[1][0] ~ a[1][2]: 1012 ~ 1023<br>a[2][0] ~ a[2][2]: 1024 ~ 1035<br>二维数组的内存寻址公式<br>a[i][j]_address = base_address + （i * a[i].length + j)* data_type_size</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d4/4e/5813df2f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Triple Z 💤</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。<br><br>&gt; Java 的 JVM GC 的方式我不是特别了解，但是在 Python 中，GC 同样也有标记清除的方式。当没有空闲内存时，就从寄存器和程序栈上的引用出发，遍历以对象为节点，引用为边构成的图，把所有可以访问到的对象都打上标记，最后清扫一遍内存空间，把没有打上标记的对象释放。<br><br>前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？<br><br>&gt; a[i][j]_address = base_address + (i * max_column_count + j) * type_size<br>&gt;<br>&gt; `max_column_count` 为数组每行的列数值。</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/66/73/fd1e37a2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">良辰美景</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组找地址公式：(base_address + a*type_size) + b*type_size， a为一维偏移量， b为二维偏移量</div> <span class="time">2018-10-09</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">看起来不对呢 你看看其他同学的答案</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/9c/7afa883f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李小草</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不诉离殇：例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环。。如果数组本身有4个元素 则这里不会出现死循环。。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了。     这段话不对吧？编译器64位操作系统下int是4字节，如果数组有四个元素，刚好满足8字节对齐，则编译器依然在紧贴着分配8字节存储i来满足8字节内存对齐啊。请作者回答下看正确与否。。。</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/82/45/981ac8ab.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">lcp</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">go 版本数组<br>func (this *Array) isIndexOutOfRange(index uint) bool {<br>	if this.length != 0 &amp;&amp; index &gt; this.length {<br>		return true<br>	}<br>	return false<br>}<br>想问一下，这里判断是否越界为什么是index &gt; this.length，而不是index &gt;= this.length？</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Geek_e1336f</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">为什么那个死循环原因有从栈结构来讲有从内存字节对齐来讲，本质原因究竟是啥啊？我看老师回复里面也是用感觉来说，不太确定呀</div> <span class="time">2018-10-09</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">看看其他同学的留言吧</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">醉比</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">若考虑性能，则选用数组。若用与一半的业务开发，使用容器即可。<br>数组下标为0是因为从cpu性能考虑。</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/83/25/10dac87c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">舍得</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">Type arr[i][j][k]  == <br>*reinterpret_cast&lt;Type*&gt;(reinterpret_cast&lt;size_t&gt;(&amp;arr) + i*sizeof(arr[0]) + j*sizeof(arr[0][0]) + k*sizeof(arr[0][0][0]));</div> <span class="time">2018-10-09</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍 3维的</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/b9/81/1680ec3f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">冯艳楠</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组是内存连续的，对cpu的缓存非常友好，cpu从主存加载时会一并将相邻的数据加载至cpu的缓存中(cache line)，如果是连续的数组访问，非常快，不用每次都读主存.</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/60/6d/e2576fda.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Rancood</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">jvm 标记清除垃圾回收，是把堆中标记为可回收的对象进行清除，这会造成一个问题，就是堆中内存空间碎片化，如果有个比较大的对象实例被创建，那就得在进行一次垃圾回收了，所以有了标记整理垃圾回收算法，清除完之后，把堆内存空间整理一遍，把未清除的对象实例整理为一个连续存储的形式。<br>二维 a[i][j]=base_address + i*type_size + j*type_size</div> <span class="time">2018-10-08</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">寻址公式不对 看看留言区其他同学的答案</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/02/24/52e7d057.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">威尼斯商人</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于无限循环的问题，查看了一些资料，总结如下：<br>0. 栈增长方向和操作系统加CPU有关，在Linux&#47;x86架构下，是从高地址到低地址生长，其他的不能做假设。栈的生长方向决定了函数调用栈帧的地址相对大小<br>1. 在单个函数栈帧内，局部变量的分配完全由编译器决定，也就是说标准只要求数组空间连续，至于是高地址在前还是低地址在前没有强制要求<br>2. 综上，出现死循环的情况需要特定的架构以及特定的编译器实现<br>求指正<br></div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/8f/c9/833d5060.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">玉皇大亮</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1.垃圾内存回收的机制有四种，分别为标记-清除算法，标记-压缩算法，复制算法和引用计数算法，JVM的垃圾回收机制主要依赖于标记-清除算法，关键点如下：两个核心概念，mutator和collector,其中mutator负责分配内存(new)、读取内存(Read)、写内存(Write),collector负责内存的回收；标记阶段，collector从mutator的根对象开始遍历，将每一个mutator的可达对象都打上一个标识；清除阶段，collector从分配的内存区从头到尾开始线性遍历，对于没有标识的内存区块，将其回收，同时每次collector回收时，都会暂停mutator的工作，这应该也是JVM多次GC时影响性能的原因之一。显然标记-清除算法解决了插入数据、删除数据时的数组移动问题，但是缺点也很明显，由于collector回收时，并不从新组织内存数据，因而造成的内存碎片问题也很严重，所以如果某个数据块的内存刚好不够装入内存碎片，则会触发多次回收，直到out of memory。<br>2.首先逻辑上的二维数组，实际上是一维数组，假设为m行，n列，所以a[i][j] = base_addr + (i * n  + j) * type_size</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/49/a7b56c99.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Effort</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师您好，我在看insert方法中，memmove(&amp;array-&gt;arr[array-&gt;used],&amp;array-&gt;arr[idx],(array-&gt;used - idx)*sizeof(int));如果在需要插曲数据的地方后面存在多个数据。我经过测试会出现bug，所以我修改了方法参数<br>memmove(&amp;array-&gt;arr[idx],&amp;array-&gt;arr[idx+1],(array-&gt;used - idx)*sizeof(int));<br>经过测试可以胜任插曲时候的拷贝工作。这是我的理解，也可能我并没有明白您那段代码有其他更深层次的用意，所以希望您的指正。</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/da/50/c4594897.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">_STone</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">热评第一和第二结合起来看就能懂了</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/71/45/abb7bfe3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Andy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">用VS的编译器并不会出现死循环，实验发现，每个变量中间会预留8个字节的空位，所以在上述代码中a[5]才存放的是i </div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/71/45/abb7bfe3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Andy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我用VS2015测试，发现a[3]并不是i ,  反而在内存中看到a[5]是i 这是为什么呢？</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ef/1b/b2be3e68.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Durian</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">留言里面大佬好啊。本来对于为何能无限循环弄不懂，也自己用python试了一下，也用C在xcode上试了一下，发现都没有无限循环。最后还是留言大佬解答的好。不同编译器会造成不同。<br>JVM：了解得不是太多。但是知道垃圾回收有好几种方法，每个厂商使用的垃圾回收方式也不完全相同，但我了解的大多就是标记清除法<br><br>二维数组寻址方式：a[m][n] = base_iddress + (i*n + j)*data_size</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epx4KyvThXw7Sm1y7p2Mt0KAwADcU0tynbK58Ik6xTibN2dId4PrLfbhpHZ0DIDhVVxJXvTzeSDEicw/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">15221031154</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">通过标记-清除算法，更好的理解了数组的概念</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/88/d0/6e75f766.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">有朋自远方来</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">计算机内存的随机访问<br>是否和您讲的这个是同理呢？</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0f/a8/51ea44ec.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">毛玉娇</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不知道，留言的回复是否是作者：王争大神。希望能官方认证下留言最可取性，说实话留言下的第一和第三我有点分辨不了那个是最正确的说法</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/75/8d/c6a2a048.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Reiser</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组寻址公式<br>a[ j ][ k ] = base_address + j * arrary_size+k * type_size<br></div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/9a/c9/20239acc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Haoz</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">一、什么是数组？<br>数组（Array）是一种「线性表」数据结构，它用一组「连续的内存空间」，来存储一组具有「相同类型」的数据。<br><br>线性表：数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向<br><br>连续的内存空间和相同的数据类型：** 使得数组具有「随机访问」的特性，但也让删除和插入等操作变得非常低效。<br><br>计算机访问数组中某个元素时，所使用的公式：<br>a[i]_address = base_address + i * data_type_size<br><br>二、对数组中的操作进行优化<br><br>2.1 插入操作<br>如果数组中存储的数据并没有任何规律，数组只是被当做一个存储数据的集合，在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们可以直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。<br><br>2.2 删除操作<br>在某些特殊场景下，我们并不一定非得追求数组中数据的连续性，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br><br>三、数组在高级语言中的使用场景<br>1、Java ArrayList 无法存储基本类型，而自动拆装箱会有一定的性能消耗，所以如果需要特别关注性能，或者希望使用基本类型，就可以选用数组。<br><br>2、如果数据大小事先已知，并对数据的操作非常简单，也可以直接使用数组。<br><br>3、在表示多维数组时，用数组会更加直观<br><br><br>四、为什么数组从 0 开始编号？<br>1、如果从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。<br><br>2、历史原因，C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的成本。</div> <span class="time">2018-10-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">木子皿</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">C++版的代码（和老师的java实现完全相同的接口及功能）：<br>#include &lt;iostream&gt;<br><br>using namespace std;<br><br>namespace  LemonDataStructure {<br><br>template<br>&lt; typename T &gt;<br>class Array<br>{<br>private:<br>    int* m_array;<br>    int m_length;<br>    int m_capacity;<br><br>public:<br>    Array(int capacity)<br>    {<br>        m_array = new T[capacity];  &#47;* 这里不判断m_array是否为空，否则又要引入异常以及重载new操作符... *&#47;<br>                                    &#47;* ...（重载new操作符是为了保证new行为在不同编译器下行为一致性）    *&#47;<br>        m_capacity = capacity;<br>        m_length = 0;<br>    }<br><br>    bool find(int index, T&amp; e)<br>    {<br>        bool ret = (0 &lt;= index) &amp;&amp; (index &lt; m_length);<br><br>        if (ret)<br>        {<br>            e = m_array[index];<br>        }<br><br>        return ret;<br>    }<br><br><br>    bool remove(int index)<br>    {<br>        bool ret = (0 &lt;= index) &amp;&amp; (index &lt; m_length);<br><br>        if (ret)<br>        {<br>            for (int i=index; i&lt;m_length-1; i++)<br>            {<br>                m_array[i] = m_array[i+1];<br>            }<br><br>            m_length--;<br>        }<br><br>        return ret;<br>    }<br><br>    bool insert(int index, const T&amp; e)<br>    {<br>        bool ret = (0 &lt;= index) &amp;&amp; (index &lt;= m_length) &amp;&amp; (m_length &lt; m_capacity);<br><br>        if (ret)<br>        {<br>            for (int i=index; i&lt;m_length; i++)<br>            {<br>                m_array[i+1] = m_array[i];<br>            }<br><br>            m_array[index] = e;<br>            m_length++;<br>        }<br><br>        return ret;<br>    }<br><br>    bool insertToTail(const T&amp; e)<br>    {<br>        bool ret = (m_length &lt; m_capacity);<br><br>        if (ret)<br>        {<br>            m_array[m_length++] = e;<br>        }<br><br>        return ret;<br>    }<br><br>    void printAll()<br>    {<br>        for (int i=0; i&lt;m_length; i++)<br>        {<br>            cout &lt;&lt; m_array[i] &lt;&lt; &quot; &quot;;<br>        }<br><br>        cout &lt;&lt; endl;<br>    }<br><br>    ~Array()<br>    {<br>        delete[] m_array;<br>    }<br>};<br>}<br><br></div> <span class="time">2018-10-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/08/8a/94c3f265.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Annie</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不明白数组中删除数据提高效率的思想，文中说是JVM标记清除垃圾回收算法的核心思想？</div> <span class="time">2018-10-06</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">两个的做法很相似，你不觉得吗？</p> <p class="reply-time">2018-10-06</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ff/48/67342109.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">QLing</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看了这篇文章明白了数组的最底层运行方式：分配一个连续的内存地址，带下标存储地址通过：a[i]_address = base_address + i * data_type_size 方式获取，不管是插入、删除都会更改内存地址。在首插入&#47;删除、在尾插入&#47;删除，它们复杂度不一样。有这样一个基本原理就可以运用到实际开发中，根据实际数据进行分析使用的方法优劣程度。</div> <span class="time">2018-10-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/37/e0/23f288ae.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">周平</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于标记删除，mysql的MYISAM引擎也是用的这个方法。 删除数据时，是标记删除，磁盘空间并不释放，以提高删除操作的性能。如果想真正的清理掉数据，需要使用optimize命令，来释放磁盘空间。</div> <span class="time">2018-10-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/11/7f/80d56c1c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">莫问流年</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组地址计算公式：<br>a[i][j]_address = base_address +(i * n + j) * type_size<br>其中，i &lt; m，j &lt; n。</div> <span class="time">2018-10-05</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对的！<br></p> <p class="reply-time">2018-10-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">智慧树叶</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，删除的平均时间复杂度化简为O(n+1&#47;2)，然后就可以直接化简为O(n)吗？虽然常用的是O(n)，但是这个时间复杂度不能写成O(n+1&#47;2)吗？</div> <span class="time">2018-10-05</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我们复杂度那一节讲过可以忽略掉系数、常数、低阶。感觉你还是没对复杂度的定义有个很好在掌握。当然可以表示成O(n+1&#47;2)，但是意义不大，或者说没有意义。我们都是简化成O(n)来表示的。</p> <p class="reply-time">2018-10-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/e8/20/3374ea9e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">茎待佳阴</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">针对于@slvher的回复，补充一点，一般现在的编译器都会插入一些垃圾值来保护，所以未必就会无限循环</div> <span class="time">2018-10-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e9/d8/a94ba376.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李之村</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">用vim试了下死循环那个例子，发现没有死循环。对于数组a，压栈的顺序是a［0］，a［1］，a［2］。所以将代码改为初始化i 为2，循环范围是i ≥-1。这样才能在vim中实现死循环。</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍，就喜欢你这种动手实验的同学！不过，也请看看其他同学的留言。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/38/217ecccb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">大坏蛋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">请教下：<br>https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo&#47;blob&#47;master&#47;java&#47;05_array&#47;Array.java中的insert、delete方法中<br>if (index &lt; 0 || index &gt;= count) return false;<br>是不是应为<br>if (index &lt; 0 || index &gt;=n) return false;<br> n存储的数组length；count存储的数组元素个数，只要index未越界，应该就可以进行insert、delete操作吧。望老师解答，谢谢。</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我定义的数组中的元素是紧密排列，所以不允许任意位置插入。当然，你也可以按照你说的来定义insert方法，只要能满足你的需求就可以。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f1/2f/3ec9fcfb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">缓哟</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组寻址方式，是不是要分为按行优先和按列优先。<br>对于二维数组A[m][n]，求A[i][j](0≤i≤m，0≤j≤n)的地址，按行优先是A[0][0]+(i*n+j)*k，按列优先是A[0][0]+(j*m+i)*k<br><br>那么，如果二维数组越界了，此时的地址要怎么计算呢？？？？<br><br>回复我一下回复我一下回复我一下</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">说的很对，是要分行优先还是列优先。问题没看懂。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ea/b7/1f7316e6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">wean</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这节课主要讲了数组的概念及对应特点的影响，还跟 Java 的 ArrayList 做了比较。<br><br>概念<br>数据是一种线性表数据结构，所谓线性表，就是数据排成像一条线一样的数据结构。<br>这里数组用一组连续的内存空间，来存储相同类型的数据。<br>数组支持随机访问。这个特点也是因为它占有连续的内存空间。数组的寻址公式是 :<br>a[i]_address = base_address + i *data_type_size<br>当面试时，我们不应该说数组的查找时间复杂度是 O(1)，排序好的数组，用二分查找，时间复杂度是 O(logn)。正确的表述是，根据下标随机访问的时间复杂度是 O(1)。<br><br>但是也是因为这个原因，数组的插入和删除非常“低效”。为了保持连续性，需要做大量的数据迁移工作。<br><br>插入<br>如果数据是有序的，每次插入到数组的第 k 个位置，需要把 k~n 这部分数据都往后移以为，若是在每个位置插入元素的概率是一样的，那么平均时间复杂度是 (1+2+...n)&#47;n=O(n)。<br><br>若数据是无序的，数组只是一个存储数据的集合，这种情况下，要把数据插入到第 k 个位置，可以尝试把第 k 个元素移到数组的最后面，把新元素插入到第 k 个位置，这样在特定场景下，插入一个元素到第 k 个位置时间复杂度可以降为 0。<br><br>删除<br>和插入一样，最好情况下时间复杂度是 O(1)，如果删除开头的数据，则是最坏情况时间复杂度 O(n)，平均情况下时间复杂度是 O(n)。<br><br>如果我们将多次删除操作集中在一起删除，就可以提高删除的效率，这也是 jvm 的标记清楚垃圾回收算法。<br><br>容器<br>ArrayList 相比数组，最大的优势就是将许多细节封装起来了，比如前面提到的数组插入、删除时需要搬移其他数据等。另外的优势就是自动扩容了。<br><br>但不是所有情况都需要用到 ArrayList。比如<br><br>ArrayList 无法存储基本类型。自动封箱拆箱需要性能消耗。<br>有些操作较为简单，无需用到 ArrayList。<br>定义多维数组时，若是用 ArrayList 看起来不直观。</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/16/00/fb37baf1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">.                 Rain。</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">（发现不能回复自己的留言）<br>二维数组（m*n）内存地址公式：a[i][j]_address = base_address + (i*n+j) * data_type_size</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对的！</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epxBnhGmLOXwIN0fod3dEHzena2dAATaJqCHEJVDicR09wEKDp4kgxMT0tibMVVzjOmSYB2cr4ha9iaA/0" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Ant</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">你们都是用手打的这么多字吗？   如果手打的话用pad真的不够方便呀。你们是不是在电脑端看的啊？   如果要是用APP并能手打的话。记忆力太好了</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">用手机回复留言都把我搞崩溃很多次了！</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">SunshlnW</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如果是C和C++，用指针表示二维数组，每行都分开申请内存，那这个数组是不连续的，这个时候就不能简单的利用java的那个公式计算吧？希望能老师能解答一下，谢谢！</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">SunshlnW</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">栈的增长方向与架构有关系,x86机器是向下增长，所以先存储i，接着存储数组a，i的地址比数组a的高，同时c语言中是数组起始即a[0]应该放在最低地址。所以有高地址-&gt;低地址。对应i-&gt;a[2]-&gt;a[1]-&gt;a[0],同时评论区大佬指出，64位系统默认是8字节对齐，所以这四个int数据刚好符合，所以访问a[3]时可以访问到i，但是如果数组有四个int元素，则这四个刚好对齐，这时候i的地址就不紧跟着数组a了，所以不一定会无限循环。<br><br></div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/25/25/fb2ba003.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Classtag</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">Jvm使用GCRoot作为根节点进行可达性分析，标记可达对象，标记算法又有很多种，经典的要说三色标记了。在清理阶段不同的算法可能不同实现，新创建对象申请不到内存时，就会gc 这个时候就是作者文中说到的先标记后删除的删除阶段。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/16/00/fb37baf1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">.                 Rain。</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组的定义：数据是一种线性表数据结构。它用一组连续的内存空间，来存储一组相同类型的数据。<br>线性表：数组，链表，队列，栈<br>非线性表：树，堆，图<br>数组特性：随机访问<br>随机访问原理：通过寻址公式，计算被访问元素存储的内存地址<br>寻址公式：a[i]_address = base_address + i * data_type_size<br>数组与链表的区别：链表适合插入与删除，数组具有随机访问的特性<br>有序数组定位插入：<br>无序数组定位插入：k位置元素放入数组末端，待插入元素放入k位置<br> <br>多次删除集中执行：先记录已删除数据（数据未真正删除），当无内存空间存储数据时，触发集中删除操作					（联系  JVM 标记清除垃圾回收算法的核心思想）<br>数组越界：<br>容器与数组的选择：业务开发，选择容器，损耗部分性能，不影响系统整体性能；底层开发，选择数组，优化性能<br>二维数组（m*n）内存地址公式：a[i][j]_address = base_address + ((i-1)*m+j) * data_type_size<br></div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">二维数组寻址公式不对 再想想吧</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e9/ae/8908e32f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">燕明</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">标记清除算法分为两个阶段:标记和清除阶段。首先标记出所有要回收的对象，在标记完成后统一回收所有被标记的对象。一个对象真正被回收至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC ROOTS相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果这个对象被判定为有必要执行finalize()方法，这个对象会被放置在f-Queue的队列之中。稍后GC会对F-Queue中的对象进行第二次小规模标记，判断对象在finalise()方法中是否成功与GC ROOTS建立关键，如果仍没有建立关联，还对象就被真正标记为可回收。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e5/04/4c7d988e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">姚震.Prometheus</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">有个问题就是类似vector&lt;set&gt;这样的结构他到底是顺序存储还是随机的呢</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">你这个是什么呀？c++中的vector容器？limiandeset是啥？</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/61/df/11db20f2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Only U</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">根据内存分配策略及寻址方式，把int i = 0与int a[3] = {0}交换位置就只会输出四次hello world便执行结束。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/sU18jltmXALwsGt5FYeEaMa7SmIMAkbNDgnYQ8xgjCLfj4uFCSEcNh5h7fEYdHwkLfJBP80cRjbX8vvjAAvXMw/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">leo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">Redis的压缩列表就是基于连续型存储结构实现的，由于是在内存中的布局是一块连续的内存空间，所以可以减小内存碎片的产生，是一种用时间换空间的思想。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/82/50/d625ac33.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">katsueiki</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">why numbering should start at zero<br><br><br><br>http:&#47;&#47;note.youdao.com&#47;noteshare?id=7189c5b12a087e7f9a2a141b588aadc1</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/ea/27/846ecf43.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Shanksiscool</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd"># 二维数组寻址公式<br>a[i]_address = base_address + i * a[i].length * data_type_size<br>a[i][j]_address = base_address + (i * a[i].length + j) * data_type_size</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对！</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ef/7e/130923d5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Hello world！</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我觉得标记清除算法在单纯的数组上会很难实现，这个思想是好的，实现的时候可能需要增加空间的消耗，老师能就这个问题示范一下吗？</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/15/78/8298abb8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">MSN</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组的内存寻址，我用坐标系来类比比较好描述，左上角最顶端的数据为首地址，也就相当于坐标系的原点，要去找二维数组中的数据，只要知道要找的数据相对于首地址（即原点）x，y轴方向偏移的值就行了。表述可能不是很好......</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ef/7e/130923d5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Hello world！</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">int〔〕  a   这是作者的伪代码表达吗？cc++应该都没有这个吧？</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/15/69/fc60d1f4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">陈华应</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">jvm标记清除算法会在运行时将不可达对象打上删除标记，但是不做真正删除清理动作。在垃圾回收条件达到时，会stw，将所有被标记对象清除，释放堆内存。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/39/2a/76ff10c4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">源</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">作者提及数组可存储基本数据类型，arraylist不可以，在java中集合都不支持。<br>挺好奇，为什么要这么设计！<br>个人理解：<br>基本数据类型都不存储在堆中，只是在栈中显性显示。没有可操作性。<br>另外更体现java语言面向对象特性。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f9/73/2a0c56d5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">ERROR</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看到有人讲死循环用栈来理解，让我想起来在看链表C#时，找到的文章说了线程栈和托管堆。线程栈存储了值类型和引用类型实例的地址，托管堆存储引用类型实例。搜了一下线程栈的叫法似乎是.NET才有，不知道老师会不会讲到这部分。</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/18/eb/fd0b4a1f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Fly55</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">“标记-清除”（Mark-Sweep）分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1a/ab/b352a655.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">佑强</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">JVM在对象失去引用，或者通过可达性分析算法判断对象可回收之后，标记该对象，标记后的对象还是存活的并没有，只是逻辑删除，当虚拟机为新对象分配内存空间或者为大对象分配空间时没有连续的内存区域可供存储，则会调用垃圾回收器对所有被标记的对象进行真正的删除操作，这就是标记删除算法，由于被标记的对象可能不是在连续的内存空间，所以该算法会产生内存碎片，一般主流的虚拟机会根据不同生命周期的对象用标记整理算法或者复制算法来清除对象</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">liangjf</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">第一篇正式文章就勾引起我对数组的存储方式，特性，例子里同一进程变量入栈特点(为什么刚好出现无限循环的原因)，标准的寻址公式，为啥下标从0开始...<br>谢谢老师</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小老鼠</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如果釆用用标记性删除，那么计算数组中有效元数个数不就变得复杂了？</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">yaya</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">在栈中，地址由高向低，所以arr的空间走完之后就访问到了i，导致无限循环。<br>为什么下标从0开始基于地址计算是由offset决定的。如果从1需要多做一次减法指令操作。历史原因。看了这个解释很疑惑为什么matlab要从1开始呢，有什么原因吗。<br>jvm垃圾回收机制，不是很了解。删除这里没有太明白。他批量删除是把末位元素复制在前吗？还是整个向前复制。<br>作业:a[i][j]的地址:＊(a+i)+j</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小老鼠</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1，在无序的数组中，删除操作的时间复杂度也可为O(1)，具体解释为a[5]={1,2,3,4,5}，现在要刪除3，我们可以把3删除后，把末尾的5移入到3处。即最后a[5]={1,2,5,4, }。<br>2，请教下在python 中数组的insert、del方法的内部具体实现方法及其时间复杂度。<br>a[5]={1,2,3,4,5}<br>a.insert(2,7)：在数组a变量2的位置加入数值7。<br>del a[2]：删除数组a变量2的位置的数值。</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/10/cd/d132bb75.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">星夜幽空</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">日常交流中涉及 第1个元素。那有没有第0个元素。 到底是从第几个开始的，容易造成歧义。 其实我认为下标就应该从1开始！。</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f1/8f/b3273afe.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">梦其不可梦</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对于顶楼的哪位同学的问题(为什么a[3]刚好等于i ？)，我的理解是这样的。<br>这涉及到一点底层的内容:<br>在内存分配时，变量存储在栈中，栈在内存中的增长方向由高到低，<br>假设分配i时地址是100,那么100-103就是i的空间了，然后有分配了数组a[3]，共3个int，需要12个位置，故a就在100-12=88的位置了，<br>a[0]在88-91，a[1]在92-95，a[2]在96-99，<br>而c没有做越界保护，计算a[3]的地址时:88+3×4=100，刚好是i的位置。所以把i给变成0了。</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/12/dd/74fca186.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">陈蒙</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1.老师对数组的分析，加深了我对容器的理解。容器相当于基于数组这种数据结构对CRUD操作的优化的算法封装，容器对于大多数应用场景其时间复杂度都比较好，在没有十足的把握情况下一般就考虑使用容器，但对于一个特定的使用场景，自己写个专门的算法肯定更优（有难度）。<br>2.关于JVM的标记清除算法，JVM有很多的垃圾回收算法，算法本身没有好坏，要对应不同的场景进行区分。垃圾清理的核心思路和方向在于垃圾分类 ：D，老年代、新生代、分区清理等。标记清除适用于垃圾量较少的情况，先行标记，积累到一定量后统一清理，相反适用复制算法。在此基础上再进行细粒度的分区回收。</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/19/88/77bba747.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李奇</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">a[i][j]_address = base_address +i * m * sizeofdata +j     *sizeofdata。其中i表示行，j表示列，m是列数。</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/af/ce/d7ae8da9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">学渣！！！</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">标记清除算法是在标记阶段，标记需要纺一回收的标记对象，在清除阶段进行清除，缺点是标记清除的对象可能是不连续的，容易造成垃圾碎片。jvm还有一种标记整理算法，前面阶段一样，后面在清理的时候会会让所有的存活对象进行移动，然后清理垃圾对象，这样就没有垃圾碎片了。二维数组应该也是一块连续的内存块，每个数组元素里面放的是一个一维数组。</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mr.Panda</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">文章非常棒！留言区也卧虎藏龙，真幸福！总结写在云笔记上了，自律给我自由！共勉</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/2d/53/56ca9a1c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">古月</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">课后思考题2：<br>假设：二维数组可表示为：a[n][m]，要找的元素为a[x][y];则位置为：首地址+{（x-1）*n+m}*地址单元类型大小</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/db/a1/7f9baa17.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">涛</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">总结:<br>1. 什么是数组?<br>数组（Array）是一种线性表数据结构。它用一组连续的内存空间,存储一组相同类型的数据. 注意三个关键点, 线性表的数据结构,内存空间连续,数据结构相同.<br>2. 数组的特点:<br> 2.1 插入和删除低效. 如果是无序数组,只是为了存储数据,可以把插入值与最后一个值交换. 删除低效可以使用标记删除的方法改进.<br> 2.2 警惕数组的访问越界问题<br>3. 容器与数组的对比:<br> 3.1 容器支持动态扩容.容器无法存储基本类型.<br> 3.2 业务开发使用容器就够了,底层,框架开发,优先考虑性能.<br><br><br></div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/02/77/f307372e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">涛</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">一个二维数组被写成m*n我不知道对不对，m*n难道不是m维吗？二维 难道不是 2*n吗？</div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">qpm</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">JVM的标记清除垃圾回收算法：JVM把堆内存空间视为一个长数组进行管理，在一次GC时，把需要清理的位置进行标记，然后再统一清除。优点单次执行比较快，缺点是内存利用率不高，产生碎片。<br><br>类比一维数组：<br>有T[] a = new int[n]，且a的地址为 ADD_a，则a[n] = ADD_a + sizeof(T) * n<br>二维数组：<br>有T[][] b = new int[m][n]，且b的地址为ADD_b，则b[x][y] = ADD_b + sizeof(T) * (n * x + y)<br></div> <span class="time">2018-10-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/98/72/0dccb3e7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">韩</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组寻址:baseAddr + i x lengthOfType + j x lengthOfType<br><br>老师，我有个疑问:上面这个式子是说明了寻址结果的计算方式，而不是底层内部实现吧？因为按照式子来看每次访问二维数组元素都需要两个乘法指令 + 两个加法指令<br><br>如果在二维数组声明时就记录下每一行行首地址，每次的寻址时间就和一维的情况一样了，只是多了点存储开销。实际二维数组底层的实现是这样的吗？</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/9c/81/78107cf1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">sea</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">gc标记是把需要gc的标记好，然后集中gc，这样就可以把连续内存当成一段内存GC，就节省了多次迁移相关内存的性能。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/9c/81/78107cf1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">sea</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">根据一维数据的公式，二维数组内存公式应该是a[k][j]address  =  baseAddress  + (k * jSize + j) * typeSize</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阳仔</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">学习反馈：<br>数组可以说是最简单的数据结构。从它的定义中看出两个重要的方面：<br>1、是一个线性表；<br>2、在一组连续的空间上存储相同的数据类型；<br>数组支持下标随机访问元素，时间复杂度为O(1)；它的“删除”和“插入”操作并不高效，需要移动数据中大规模数据，时间复杂度为O(n)。<br>要访问数组第k个元素的寻址计算公式为：<br>a[k]=a数组首地址+k*数组中的数据类型大小。<br>要注意数组访问越界的问题<br>对于在平时开发过程中，选择数组还是容器的问题<br>1、容器封装了数组操作的细节，且支持动态扩容。因此在做业务开发时，可以牺牲一点点性能，换取编码的效率；在使用容器的时候，可以尽量为容器指定大小，避免做很多无用的扩容操作。<br>2、在开发对性能要求较高的底层框架时，可以考虑选择数组。<br>开篇问题<br>这个问题答案个人觉得不是特别重要，它是一个吸引人注意的话题。从解析这个话题的过程中，我们了解了数组的特点，知道了它的寻址计算方式，以及与其他数组结构的区别。<br></div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/6d/5b/03763d38.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">观望者</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组的寻址，a[i, j] _ address = base_address + type_size * i + j * typesize</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/6d/5b/03763d38.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">观望者</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">@Rain<br>如果你熟悉C语言的话，就会知道C里面的函数在内存中是用“栈”的数据结构把变量压入的。<br>所以编译器会把main翻译成，将变量i入栈，然后再把数组入栈，结果你访问越界数组的时候，正好就访问到了i的内存地址上。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1b/86/22a9362f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">六六六</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1. 标记清除垃圾回收算法分为标记和清除两个阶段。标记：使用根搜索算法，遍历GC Roots，将所有GC Root可达的对象标记为存活对象。清除：遍历所有对象，将没有标记的对象全部清除<br>2. 二维数组的寻址公式：二维数组的地址也是连续地址，所以假设数组大小为a[m][n],则a[i][j]_address = base_address + i * n * type_size + j * type_size  </div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1b/91/66f0d38a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">花生</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">高赞有个关于 无限循环 的回答很好啊，补充一下，可以看编译原理对这部分的解释。编译原理 虎书 活动记录那一部分<br><br></div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/98/72/0dccb3e7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">韩</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">另外再赞一个，我觉得这个课程的内容简直太好了。如果我大学的时候数据结构学的是这个课程，恍然大悟的估计还会更早一些。我觉得课程可以考虑和校方合作，这么优质的课程，现在大学里的大学生可能都不知道！</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/30/2c/333d7080.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Northern</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址。最后一句话怎么理解？</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ec/95/9ac3d611.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">HouShangLing</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不知道java还有装箱拆箱的概念。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/12/93/3470fc43.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mr.钧👻</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组，是一种线性存储的数据结构，是内存中一块连续的内存空间，存储相同类型的元素。<br>数组的删除，可以先对被删除的元素进行标记，然后当数组满容量后再触发删除操作，这样更加高效。而jvm就是这样的运行原理。<br>索引越界的危害，不太懂</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">安静的boy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">问题回答：<br> 问题一：JVM会先标记所有要清除的对象，然后同意清除。和数组删除优化的思路是一样的。<br>问题二：如果查找二维数组的元素是 arr[i][j]。那么寻址公式是先找出arr[i]的内存地址：arr[i]_address = (base_address + i * data_type_size)。arr[i]内存地址中存的是arr[i][j]的内存首地址。如果记为arr[j]_address，那么arr[i][j]的寻址公式为arr[i][j]_address = arr[j]_address + j * data_type_size。<br>回答的结果请老师审阅一下。又错误的话指出一下。谢谢！</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">虎虎❤️</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">gc 分为 minor gc 和 full gc。<br><br>重点说下Minor gc，分为survivor1 survicor2 和老生代。当survivor1中的内存满了之后，把没有被标记的内存顺序拷贝到survivor2中，反之亦然。新生代为什么分为两个区呢?你可以考虑一下如果只有一个区，做内存整理的难度。举个例子，比如磁盘整理算法中，需要把磁盘分页。然后，把若干次minor gc中一直存活的对象copy的老生代中。<br><br>full gc会清理老生代。一般会产生比较大的开销，java会停下其他的进程，出现卡死的状态。如果你的程序经常出现full gc，你该考虑一下原因啦。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/eb/81/43f4b52c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">杨伟</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">留言的人还挺多的啊，点赞</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/11/11/52a78856.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">D→_→M</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师我想问一下为何数组查找操作的时间复杂度是O(logn);<br>还有就是一点小建议，可否将每节课后面的思考题，在下一节课中解析一下。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">1. 有序数组用二分查找的时间复杂度是O(logn)，不过建议再看一下我文章中表述<br>2. 我在周末的时候写篇文章可以集中答疑一下</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/01/58/1788a7e6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">TheTingTings</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">声明二维数组int[a][b]<br>a[i][j]ad=(base+i*b*type_size)+j*type_size。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对！但公式的格式可以再优化下</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/37/d0/d60767cf.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">geektime learn</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">标记清除算法，JVM将把要回收的对象做标记，等到没有连续可用空间时全部将标记对象回收，最大的缺点就是会产生很多不连续的内存空间。<br><br>二维数组因为需要两个下标才能确定一个元素，可以看成一个矩阵matrix，如果是把行下标和列下标直接相加或相乘肯定是不行的，比如1 * 2 等于 2 * 1。推断一下，a[i][j]_address = (base_address + i * data_type_size) * j</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">后面二维数组的不对 再想想</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/e0/13/08735b5d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">$Jason</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">“数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。”<br>数组在javascript中是可以存储不同类型的数据的。只是说明下。<br>另外期待老师讲解上面大家都提到的问题<br>“根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。”</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d4/cd/8b155b74.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">胡军</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">二维数组元素寻址公式：<br><br>设a为一个二维数组a[m][n]<br>a的成员占用内存大小为type_size<br>a的起始位置为base_address<br><br>a[k][j]_address = base_address + k * (type_size * n) + j * type_size</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对的！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">勤劳的小胖子-libo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组地址也是连在一起的，低维的一个一个类型长度连在一起，高维的是一个一个低一级维度的连在一起。<br><br>二维数组计算公式，假设二维数组为Array[n][m]<br>则Array[i][j]=Base_Address+(i*m+j)*type_size;<br>i&lt;n,j&lt;m;</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">回答正确✅</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">落叶飞逝的恋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组插入时间复杂度推导过程:<br>最后一个元素往后移动1次。<br>倒数第二个元素往后移动2次<br>...<br>第一个元素往后移动n位<br><br>假设每个位置插入元素的概率是一样的为1&#47;n。那么移动的时间复杂度为：1*1&#47;n+2*1&#47;n+3*1&#47;n+..n*1&#47;n=(1+2+3+4...+n)&#47;n=n(n+1)&#47;2n。去除常数、及低次项所以为O(n)<br>老师我讲的对吗？</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对的👍</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">落叶飞逝的恋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。其实就是int[] a=new int[]。a[index]=?这种访问方式把。而不是Arrays.binarySearch这种访问</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">是的 你理解的没错</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">来碗绿豆汤</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组最大的优势就是随机访问，不足就是插入，删除数据比较耗时，因为要移动数据。所以如果我们能想办法把劣势消除，那就完美了。在有些情况下确实可以做到。插入的时候如果不需要维护之前数组的顺序，就可以将要插入位置的数据移走，然后直接插入，快速排序就是这样干的;如果是删除操作，可以先标记，等最后一次性删除，也可以减少移动次数，jvm就是这样做的。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/95/96/0020bd67.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">夏洛克的救赎</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">“所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。”<br><br>这句话是否可以进一步理解为：CPU寻址的时间复杂度为 O(1)？ 如果是，那CPU寻址的时间复杂度又如何计算？需要进一步深入了解操作系统？</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">好像没有这么说的。你说的这块可以看看操作系统、计算机组成原理</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f9/12/0e6620cd.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">三景页</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。<br><br>个人觉得在编译器未定义的情况下，说a[3]的地址被定位到i的地址是不严谨的。而且int i定义在数组定义的前面，所以就算可以访问也应该是a[-1]才是。班门弄斧一下</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/d0/b4/a6c27fd0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">John</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师好，有几个疑问请解答下？1.如果数组采用标记删除的话，这个数组按下标查找就不对了啊，也就没有随机访问的优势了。2.垃圾回收是因为里面维护了内存的使用情况的信息表，不需要随机访问，且维护效率才采用标记清除的吧。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">为什么说按照下标查找会不对呢？</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/b8/55/b7634bca.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">钟衍辉</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1、我是这样理解标记清除垃圾回收算法的，确定对象要回收，会将该对象占用内存空间标记为可回收，但并不会马上执行内存的释放。等申请内存空间不够时，才会对已标记的内存空间进行清除。这种方式会造成内存碎片比较多，当需要申请较大内存空间时，可能因为连续可用的空间不够，再次造成GC。<br>2、仿造老师的公式，二维数组内存寻址公式为：a[k][n]_address = base_address + (k * N + n) * type_size;<br>其中N为二维数组中数组元素的长度。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/27/d0/7e18e9a2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Tenderness</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回答下思考，不知道描述的准不准确<br>1.标记-清楚算法<br>    分为两个阶段，首先是标记出所有需要回收的对象，标记方法有引用计数法和可达性分析，个人局的一般都是用可达性分析吧，毕竟涉及到互相引用问题。其次就是同意对标记的对象进行回收。<br>2.二维数组寻址<br>    一维数组地址分别是 a , a+i<br>    二维数组a[m][n]的地址表示为：a+i为二位数组第i行的首地址，a[i][j] 元素的地址为 *(a+i) + j , address = base_address + (i*m+j） *  type_size 。地址分配是连续的，逐行分配。 </div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/27/d0/7e18e9a2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Tenderness</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回答下思考，不知道描述的准不准确<br>1.标记-清除算法<br>    分为两个阶段，首先是标记出所有需要回收的对象，标记方法有引用计数法和可达性分析，个人觉得一般都是用可达性分析吧，毕竟涉及到互相引用问题。其次就是统一对标记的对象进行回收。<br>2.二维数组寻址<br>    一维数组地址分别是a ，a+i<br>    二维数组地址表示为 a+i为二维数组第i行的首地址，a[i][j]元素的地址为*(a+i)+j，address=base_address+(i*m+j)*type_address，m为数组的行数。地址分配是连续的，一行接一行。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d6/bc/026ac6b1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">windliang</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">尝试了先定义 i 再定义数组，先定义数组再定义 i ，发现都不是无限循环。把地址输出，也没有发现 i 的地址和数组的地址有什么联系。<br><br>求老师讲一下这块的意思。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。<br>2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。<br>3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.<br>4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Smallfly</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于死循环的例子，int 类型占 4 个字节，理论上来说 i 的地址不会跟在 3 个元素的 arr 后面，因为一般计算机内存是字节对齐的，会按 8 的整数倍来分配内存。<br><br>我在 Xcode 里面测试了下这段代码，越界直接奔溃了，i 的栈地址也比 arr 小，老师举这个例子可能只是为了说明数组随机访问的风险，至于什么风险是未知的，不同计算机上的表现也不一定一致，没必要死扣为什么第 4 个元素刚好是 i 的地址吧……</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/17/93/981dc959.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李恒达</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，你讲到“而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，”<br>这个是为什么？为什么正好是这个地址？</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。<br>2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。<br>3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.<br>4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/5d/8f/16e1da5d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">程</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">无限打印helloworld那个在Ubuntu14.04里面实现过了，arr[i]和i的定义调过来也是，都是只打印4行。arr[i]的位置碰巧是i的位置的机率很小的吧</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">1. 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。至于你熟悉的语言是怎么处理的，请行百度。<br>2. C语言中，数组访问越界的处理是未决。并不一定是错，有同学做实验说没问题，那并不代表就是正确的。<br>3. 我觉得那个例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.<br>4. 大家有不懂的多看看留言，留言区还是有很多大牛的！我可能有时候回复的不及时，或者同样的问题只回复一个同学！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/30/86/c4e4d753.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">优雅一点</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">定义，就相当于给了我们一个标准。标记回收算法则相当于在规则之内更有效率的使用数据结构。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/10/f1/ba7a4d86.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">简单</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1.数组越界的问题<br>i的内存有可能和数组的内存是连续的（测试时没有复现）<br>那么此时的地址有可能 ox ---- --FF   &#47;1515           array[0] <br>                                   ox ---- --FC  &#47;1512            array[1]<br>                                                        &#47;1509           array[2]<br>                                                          1506           i<br>array[3]越界时，访问到紧接着的i了，并且把i = 0；所以就死循环了<br><br>2.2维数组的问题<br>因为内存是一维的，所以问题转化为怎么求偏移量<br>这里就需要考虑行优先还是列优先的问题  ，如果是行优先的话<br>int a[3][3] = {0};<br>a[1][1]   offset = baseaddr + （1 * 列数 + 1） * sizeof(int);<br>因此&amp;a[i][j] = &amp;a + sizeof(type)*(列数+j);<br><br>因为不会看汇编，不太清楚是先算出行地址,比如a[1]的地址，在去加j，还是直接通过<br>首地址a[0][0]来计算偏移量。<br><br></div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e3/32/087ceaa2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">于前鹏</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，你讲的这个适合python语言么？</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">适合啊 有什么疑问吗</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e7/b1/5c63be67.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">非礼勿言-非礼勿听-非礼勿视</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">标记清楚算法:通过可达性分析算法将不可达对象标记出来，然后进行清楚，这种方式会产生内存碎片，常用于老年代垃圾回收。但一般都是用标记整理算法，就是在标记清楚的基础上来一次内存整理。像CMS这种提供可配置方式，可以每次回收后都进行整理，也可以在执行多次回收后来一次整理</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/34/49/6b27feb1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Riordon</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">标记-清除：标记阶段O(logn)和清除阶段O(1),清除后产生大量不连续内存碎片，下次有大对象过来还得触发gc。标记-整理：整理阶段把活对象移向一端，清除边界外空间。</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/06/17/9e6ec02e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">蔷薇骑士</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">a[i][j]=baseAddr+i*len*typeSize+j*typeSize，len为第二维的长度，对否？</div> <span class="time">2018-10-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对！</p> <p class="reply-time">2018-10-01</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/b6/79/22e582a5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">刘岚乔月</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">标记清理gc会有空间碎片的问题 在fullgc的时候会导致卡顿时间过长 不知道java11中的新gc策略怎么样 <br>其实可以根据具体的业务场景来选择适合的gc策略</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/11/25/1bf50430.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">橙子ちゃん</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师你好，我是一名JS开发者。JS中的array和其他语言的不太相同，array既没有固定长度，也没有固定type。js作为当前最流行的语言之一，希望老师可以稍微提一下，要不然js的初学者会很疑惑🤔比如我🤣🤣</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/b6/79/22e582a5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">刘岚乔月</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">标记回收gc会产生空间碎片 需要整理<br></div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/04/eb/5abae178.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Ace</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">感觉讲解非常清楚，学到了。🙏</div> <span class="time">2018-10-01</span>
	<div class="reply">
	
	</div>
</div>
</li></ul></div></div></div></div><div id="translate-man-app" class="content-3WfBL_0" style="background-color: rgb(255, 255, 255); display: none;"><div data-v-ea0bd11e="" class="outputBox-qe9A4_0"><div data-v-ea0bd11e="" class="outputBox-3oESn_0"><span data-v-ea0bd11e="" class="outputBox-13Ovx_0"></span></div><div data-v-ea0bd11e="" class="outputBox-1GLb__0"><div data-v-ea0bd11e="" class="outputBox-onVZH_0"><img src="chrome-extension://fapgabkkfcaejckbfmfcdgnfefbmlion/static/sound.svg"            class="icon-tprjJ_0"></div></div><div data-v-ea0bd11e="" class="outputBox-2sJgr_0"></div><div data-v-ea0bd11e="" class="outputBox-17RAm_0" style="display: none;"><div data-v-ea0bd11e=""></div></div></div></div><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({        showProcessingMessages: false,        messageStyle: "none",        tex2jax: {          inlineMath: [['$','$'], ['\\(','\\)']],          displayMath: [ ["$$","$$"] ],          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a']        }      });      MathJax.Hub.Register.MessageHook("End Process", function (message) {        var eve = new Event('mathjaxfini')        window.dispatchEvent(eve)      })</script></body></html>