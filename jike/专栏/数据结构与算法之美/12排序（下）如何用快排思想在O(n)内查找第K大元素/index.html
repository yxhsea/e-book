<html class="cye-disabled cye-lm"><head><meta charset="utf-8"><link rel="apple-touch-icon" sizes="180x180" href="http://static001.geekbang.org/static/icon/time/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="http://static001.geekbang.org/static/icon/time/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="http://static001.geekbang.org/static/icon/time/favicon-16x16.png"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover"><meta name="format-detection" content="telephone=no"><title>12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？</title><link href="https://static001.geekbang.org/static/time/css/app.b230db929e53af87acd535637f5011b8.css" rel="stylesheet"><style id="nightModeStyle">    html.cye-enabled.cye-nm:not(*:-webkit-full-screen) body,html.cye-enabled.cye-nm:not(*:-webkit-full-screen) #cye-workaround-body {-webkit-filter:contrast(91%) brightness(84%) invert(1);}</style><style id="cyebody">html.cye-enabled.cye-lm body{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyediv">html.cye-enabled.cye-lm div{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyetable">html.cye-enabled.cye-lm th{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}html.cye-enabled.cye-lm td{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyetextInput">html.cye-enabled.cye-lm input[type=text]{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}html.cye-enabled.cye-lm textarea{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyeselect">html.cye-enabled.cye-lm select{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyeul">html.cye-enabled.cye-lm ul{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyeChangeByClick">html.cye-enabled.cye-lm .cye-lm-tag,html.cye-enabled.cye-lm.cye-lm-tag{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style type="text/css">    .hljs-ln {      border-collapse: collapse    }    .hljs-ln td {      padding: 0    }    .hljs-ln-n:before {      content: attr(data-line-number)    }</style><style type="text/css">    #iv-container {      position: fixed;      background: #0d0d0d;      width: 100%;      height: 100%;      top: 0;      left: 0;      display: none;      z-index: 1000    }    .iv-container {      overflow: hidden    }    .iv-close {      width: 26px;      height: 26px;      position: absolute;      right: 20px;      top: 20px;      cursor: pointer;      text-align: center;      overflow: hidden;      text-shadow: 0 0 3px #6d6d6d;      -webkit-transition: all .2s ease;      -moz-transition: all ease .2s;      -o-transition: all ease .2s;      transition: all .2s ease    }    .iv-close:after,    .iv-close:before {      content: "";      height: 2px;      width: 26px;      background: #fff;      position: absolute;      left: 0;      top: 50%;      margin-top: -2px;      border-radius: 2px    }    .iv-close:before {      -webkit-transform: rotate(45deg);      -moz-transform: rotate(45deg);      -ms-transform: rotate(45deg);      -o-transform: rotate(45deg);      transform: rotate(45deg)    }    .iv-close:after {      -webkit-transform: rotate(-45deg);      -moz-transform: rotate(-45deg);      -ms-transform: rotate(-45deg);      -o-transform: rotate(-45deg);      transform: rotate(-45deg)    }    .iv-close:hover {      -webkit-transform: rotate(90deg);      -moz-transform: rotate(90deg);      -ms-transform: rotate(90deg);      -o-transform: rotate(90deg);      transform: rotate(90deg)    }    .iv-image-view {      position: absolute;      height: 100%;      width: 100%    }    .iv-image-wrap {      display: inline-block    }    .iv-image-wrap:active {      cursor: move    }    .iv-large-image {      cursor: move;      max-width: 100%;      max-height: 100%;      background-color: #ececec;      -moz-transform: translateZ(0);      -o-transform: translateZ(0)    }    .iv-large-image,    .iv-loader {      position: absolute;      -webkit-transform: translateZ(0);      -ms-transform: translateZ(0);      transform: translateZ(0)    }    .iv-loader {      top: 50%;      left: 50%;      border-radius: 50%;      width: 32px;      height: 32px;      z-index: 100;      margin-top: -16px;      margin-left: -16px;      font-size: 5px;      text-indent: -9999em;      border-top: 1em solid hsla(0, 0%, 100%, .2);      border-right: 1em solid hsla(0, 0%, 100%, .2);      border-bottom: 1em solid hsla(0, 0%, 100%, .2);      border-left: 1em solid #fff;      -webkit-animation: load8 1.1s infinite linear;      animation: load8 1.1s infinite linear    }    .iv-loader:after {      width: 10em;      height: 10em;      border-radius: 50%    }    @-webkit-keyframes load8 {      0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg)      }      to {        -webkit-transform: rotate(1turn);        transform: rotate(1turn)      }    }    @keyframes load8 {      0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg)      }      to {        -webkit-transform: rotate(1turn);        transform: rotate(1turn)      }    }</style><style type="text/css">    .vue-pull-to-wrapper[data-v-12abd9fb] {      display: -webkit-box;      display: -webkit-flex;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -webkit-flex-direction: column;      flex-direction: column;      height: 100%    }    .scroll-container[data-v-12abd9fb] {      -webkit-box-flex: 1;      -webkit-flex: 1;      flex: 1;      overflow-y: auto;      -webkit-overflow-scrolling: touch    }    .vue-pull-to-wrapper .action-block[data-v-12abd9fb] {      position: relative;      width: 100%    }    .default-text[data-v-12abd9fb] {      height: 100%;      line-height: 50px;      text-align: center    }</style><style type="text/css">    .button-cancel[data-v-87ffcada] {      color: #888;      border: 1px solid #888;      border-radius: 3px;      margin-right: 12px    }    .button-cancel[data-v-87ffcada],    .button-primary[data-v-87ffcada] {      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      height: 35px;      display: inline-block;      font-size: 15px;      text-align: center;      line-height: 36px    }    .button-primary[data-v-87ffcada] {      color: #fff;      background-color: #ff5a05;      border-radius: 3px    }    .article[data-v-87ffcada] {      max-width: 46.25rem;      margin: 0 auto    }    .article .article-unavailable[data-v-87ffcada] {      color: #fff;      text-align: center;      font-size: .875rem;      font-weight: 400;      width: 100%;      -webkit-box-sizing: border-box;      box-sizing: border-box;      padding: 0 15%;      height: 4.9rem;      background-image: url(data:image/jpeg;base64,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);      background-position: 0 0;      background-repeat: no-repeat;      background-size: cover;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: center;      -ms-flex-pack: center;      justify-content: center    }    .article .main[data-v-87ffcada] {      padding: 1.25rem 1.375rem;      margin-top: 52px;      margin-bottom: 52px    }    .article-title[data-v-87ffcada] {      color: #353535;      font-weight: 400;      line-height: 1.65rem;      font-size: 1.34375rem    }    .article-info[data-v-87ffcada] {      color: #888;      font-size: .9375rem;      margin-top: 1.0625rem    }    .article-content[data-v-87ffcada] {      margin-top: 1.0625rem    }    .article-content.android video[data-v-87ffcada]::-webkit-media-controls-fullscreen-button {      display: none    }    .audio-player[data-v-87ffcada] {      width: 100%;      margin: 20px 0    }    .to-comment[data-v-87ffcada] {      overflow: hidden;      margin-bottom: -30px    }    .to-comment a.button-primary[data-v-87ffcada] {      float: right;      height: 20px;      font-size: 12px;      line-height: 20px;      padding: 4px 8px;      cursor: pointer    }    .article-comments[data-v-87ffcada] {      margin-top: 2rem    }    .article-comments h2[data-v-87ffcada] {      text-align: center;      color: #888;      position: relative;      z-index: 1;      margin-bottom: 1rem    }    .article-comments h2[data-v-87ffcada]:before {      border-top: 1px dotted #888;      content: "";      position: absolute;      top: 56%;      left: 0;      width: 100%;      z-index: -1    }    .article-comments h2 span[data-v-87ffcada] {      font-size: 15.25px;      font-weight: 400;      padding: 0 1rem;      background: #fff;      display: inline-block    }    .article-sub-bottom[data-v-87ffcada] {      z-index: 10;      cursor: pointer    }    @media (max-width:769px) {      .article .breadcrumb[data-v-87ffcada] {        padding: 10px 0      }    }</style><style type="text/css">    .share-poster-wrapper {      position: fixed;      background-color: #fff;      left: 0;      bottom: 0;      z-index: 100;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      overflow: hidden;      width: 100%;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -moz-user-select: -moz-none;      -webkit-user-select: none;      -ms-user-select: none;      user-select: none    }    .share-poster-wrapper .poster-bottom,    .share-poster-wrapper .poster-middle,    .share-poster-wrapper .poster-top {      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .poster-middle {      padding: 16px 32px;      -webkit-box-sizing: border-box;      box-sizing: border-box    }    .share-poster-wrapper .poster-middle .poster-userinfo {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      padding-bottom: 18px    }    .share-poster-wrapper .poster-middle .poster-userinfo .poster-avatar {      min-width: 45px;      min-height: 45px;      width: 7vw;      height: 7vw;      border-radius: 50%;      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .poster-middle .nickname {      font-size: 5vw;      font-weight: 400;      margin-left: 18px    }    .share-poster-wrapper .poster-middle .time {      font-size: 3.2vw    }    .share-poster-wrapper .poster-middle .poster-middle-content {      font-size: 4vw;      font-weight: 400;      white-space: normal;      word-wrap: break-word;      word-break: break-word;      letter-spacing: 1px    }    .share-poster-wrapper .poster-middle .poster-middle-content p {      margin-bottom: 22px    }    .share-poster-wrapper .poster-middle .quote-content {      font-size: 3.7vw;      padding: 32px 0    }    .share-poster-wrapper .poster-middle .quote-content p {      margin-bottom: 22px    }    .share-poster-wrapper .poster-middle .quote-info {      border-left: 1px solid #000;      padding-left: 10px;      margin-top: 38px    }    .share-poster-wrapper .poster-middle .quote-info p {      font-size: 3.2vw;      line-height: 1.5    }    .share-poster-wrapper.theme0 .poster-top {      width: 100%;      height: 25px;      margin-top: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/top.png") no-repeat 15px 1px    }    .share-poster-wrapper.theme0 .poster-middle {      width: 100%;      padding-left: 56px;      padding-right: 56px;      background-image: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/middle.png");      background-repeat: repeat-y;      background-position: 15px 0    }    .share-poster-wrapper.theme0 .poster-middle .time {      margin-bottom: 45px    }    .share-poster-wrapper.theme0 .poster-middle .quote-content {      border-top: 1px solid #e3e1dc;      margin-top: 30px    }    .share-poster-wrapper.theme0 .poster-bottom {      width: 100%;      height: 25px;      margin-bottom: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/bottom.png") no-repeat 15px -10px    }    .share-poster-wrapper.theme1 .poster-top {      width: 100%;      height: 25px;      margin-top: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/top.png") no-repeat 38px 1px    }    .share-poster-wrapper.theme1 .poster-middle {      width: 100%;      padding: 0 42px 10px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/middle.png") repeat-y 38px 0    }    .share-poster-wrapper.theme1 .poster-middle .poster-userinfo {      border-bottom: 1px solid #b5a899    }    .share-poster-wrapper.theme1 .poster-middle .poster-userinfo .poster-avatar {      margin-left: 38px    }    .share-poster-wrapper.theme1 .poster-middle .poster-middle-wrapper {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      min-height: 260px;      border-bottom: 1px solid #b5a899    }    .share-poster-wrapper.theme1 .poster-middle .time {      max-width: 65px;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -webkit-box-pack: center;      -ms-flex-pack: center;      justify-content: center;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      text-align: center;      vertical-align: middle;      border-right: 1px solid #b5a899    }    .share-poster-wrapper.theme1 .poster-middle .time span {      white-space: nowrap;      -webkit-transform: rotate(90deg);      transform: rotate(90deg)    }    .share-poster-wrapper.theme1 .poster-middle .poster-middle-content {      padding: 30px    }    .share-poster-wrapper.theme1 .poster-middle .quote-content {      font-size: 3.7vw;      margin-left: 36px;      margin-right: 36px    }    .share-poster-wrapper.theme1 .poster-middle .quote-info {      margin-left: 36px;      margin-right: 36px    }    .share-poster-wrapper.theme1 .poster-middle .footer {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      margin-right: 30px    }    .share-poster-wrapper.theme1 .poster-bottom {      width: 100%;      height: 25px;      margin-bottom: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/bottom.png") no-repeat 38px -10px    }    .share-poster-wrapper .share-poster {      background: #fefdf8;      -webkit-box-sizing: border-box;      box-sizing: border-box;      color: #9b8d73;      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      overflow: auto;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -webkit-overflow-scrolling: touch;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center    }    .share-poster-wrapper .share-poster.color0 {      background-color: #fefdf8    }    .share-poster-wrapper .share-poster.color1 {      background-color: #4d4d4d    }    .share-poster-wrapper .share-poster .footer {      margin-top: 2rem;      position: relative;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-pack: end;      -ms-flex-pack: end;      justify-content: flex-end;      -webkit-box-align: end;      -ms-flex-align: end;      align-items: flex-end    }    .share-poster-wrapper .share-poster .footer p {      margin: 0;      line-height: 1.4;      margin-left: 20px;      text-align: right;      padding-right: 20px    }    .share-poster-wrapper .controls {      background: #fff;      border-top: 1px solid #f5f5f5;      width: 100%;      padding-top: 5px;      -webkit-box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, .1);      box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, .1);      z-index: 1;      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .controls>div {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-pack: center;      -ms-flex-pack: center;      justify-content: center;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      padding: 10px 0    }    .share-poster-wrapper .controls>div span {      font-size: .85rem    }    .share-poster-wrapper .controls>div button {      width: 100px;      height: 24px;      background: #eee;      margin: 0 10px;      border-radius: 5px;      border: 2px solid #b2b2b2;      outline: none    }    .share-poster-wrapper .controls>div button.on {      border: 2px solid #ff5a05    }    .share-poster-wrapper .controls .controls-themes button {      color: #b2b2b2;      font-size: 12px;      background: #fff;      text-align: center    }    .share-poster-wrapper .controls .controls-themes button.on {      color: #ff5a05    }    .share-poster-wrapper .buttons {      background: #fff;      border-top: 1px solid #f5f5f5;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .buttons a {      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      text-align: center;      color: #000;      font-weight: 400;      height: 3rem;      line-height: 3rem    }    .share-poster-wrapper .buttons a:last-child {      border-left: 1px solid #f5f5f5    }    .share-poster-wrapper img {      max-width: 100%    }    .share-poster-wrapper.android .poster-middle .nickname {      font-size: 10vw    }    .share-poster-wrapper.android .poster-middle .time {      font-size: 6.4vw    }    .share-poster-wrapper.android .poster-middle .poster-middle-content {      font-size: 8vw    }    .share-poster-wrapper.android .poster-middle .quote-content {      font-size: 7.4vw    }    .share-poster-wrapper.android .poster-middle .quote-info p {      font-size: 6.4vw    }</style><style type="text/css">    .mobile-tips {      width: 100%;      height: 51px;      background: rgba(0, 0, 0, .8);      position: fixed;      top: 0;      left: 0;      z-index: 20;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: justify;      -ms-flex-pack: justify;      justify-content: space-between;      -webkit-box-sizing: border-box;      box-sizing: border-box;      padding: 0 12px;      -webkit-transition: opacity .35s;      transition: opacity .35s;      opacity: 0;      pointer-events: none    }    .mobile-tips.istop {      opacity: 1;      pointer-events: auto    }    .mobile-tips .mobile-tips-info {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: start;      -ms-flex-pack: start;      justify-content: flex-start    }    .mobile-tips .mobile-tips-info i {      width: 36px;      height: 36px;      background-image: url(data:image/png;base64,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);      background-position: 0 0;      background-repeat: no-repeat;      background-size: contain;      border-radius: 7px    }    .mobile-tips .mobile-tips-info h2 {      font-size: 15px;      color: #fff;      font-weight: 400;      margin-left: 6px    }    .mobile-tips .mobile-tips-info h2 span {      font-size: 11px    }    .mobile-tips a {      width: 72px;      height: 31px;      text-align: center;      border: 1px solid #ff5a05;      border-radius: 3px;      font-size: 13px;      color: #ff5a05;      line-height: 31px    }</style><style type="text/css">    .mini-audio-player {      width: 100%;      height: 5.25rem;      border: 1px solid #d9d9d9;      background: #fafafa;      -webkit-box-sizing: border-box;      box-sizing: border-box;      padding: 1rem;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: justify;      -ms-flex-pack: justify;      justify-content: space-between;      margin: 1rem 0    }    .mini-audio-player>a {      border: none;      -ms-flex-negative: 0;      flex-shrink: 0    }    .mini-audio-player .btn-play {      background-image: url(data:image/png;base64,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)    }    .mini-audio-player .btn-pause,    .mini-audio-player .btn-play {      width: 2.6875rem;      height: 2.6875rem;      background-repeat: no-repeat;      background-position: 0 0;      background-size: contain;      text-decoration: none    }    .mini-audio-player .btn-pause {      background-image: url(data:image/png;base64,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)    }    .mini-audio-player .audio-info {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      margin-left: .6875rem;      min-width: 0    }    .mini-audio-player .audio-info h3 {      color: #353535;      font-size: 15.25px;      margin: 0;      white-space: nowrap;      overflow: hidden;      text-overflow: ellipsis    }    .mini-audio-player .audio-info p {      margin: 0;      margin-top: .125rem;      font-size: 11px;      line-height: 1rem    }    .mini-audio-player .audio-info p span {      color: #888    }    .mini-audio-player .btn-download {      width: 1.25rem;      height: 1.25rem;      position: relative;      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA+CAYAAACbQR1vAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+IEmuOgAAA4hJREFUaIHtm8lOFFEUhr9qCWGHGxcaY1joK2h0YRzAtYmsWbAGGidEXOACbAYRxfgAPoEPoInGxJgg86gsJTHMw86EhS7O7TDk3uqq6qo6HahvQ7pOce7//1U0feve9vr6+lAiD3QC/4AC8FZDRJXGoMB14PWB1yPANPA1bSG5tAc0XLEcu5y6CvQCOGU5pnI3agVQMWQBaAvQJgtAW4A2WQDaArTJAtAWoE0WgLYAbbIAtAVokwWgLUCbLABtAdpkAfjU6oC7wKV0pCTCRcRDnesEVwDNwC/gg/nZHbeyFOgGltj30Gw7yRZALfAOqDavPeA50BO7xOToQTR75nU14qn26Im2AM4DNZbjz4DeePQlSi+i9Sg1iLdD2AJYApYdzbuo7BBeIBptLCPeDmELYA9oBHYdjbqQpaxKowA8ddR2gXuIt0O43gRHgTu4Q+ikskIoIJps7AINwA9b0e/fYJAQ1FZWD9CP2/wOUI/DPJT+IDRqGrhCeGIEaNEPdDhqO8iVH/NrEOST4BgSwo6j3gEMBOgTNwP4m6+nhHkI/lG4VAiPgcGAveJg0IxpYxvROh6kUZi5wLhpvO2oPyKdEF6asWyEMg/hJ0PjyN+VXwhDIXuGYQh46KhtIeYnwjSMMhss3glbjvoDkglhyPS2Eck8RJ8OTyB3gl8IryL2tjGM2/wmYn4ySuNyngdMmIE3HfX7iHDPUQ+CZ3q0O+qbyIWIZB7KfyAyaQS4QmhH7oQoIZQyv0EZV75IHE+EJvG/E9oJfyd4yC6yvKO+gQQ/FaKnlbgeiU0hIWw46nnEUJAQiubbHPV1M1bZ5iHeZ4KlQmgD3uAfgofsGfQz34DsKYyFuLemTSMhfATOWOqtiMk/llrRfIuj9zpwG5gtX+Y+SezNK4bwCXsILdgDaAXOOnomYh6Seyw+gwhed9TPWY75mb9FAuYh2XWBWUS4K4QgrAE3gblYFFlIemFkDjEQJYQ1JMD5WBUdIY2VoXkkhLUQv7NqfidR85De0liYEFaRK7+QqCJDmmuDC0gIqz7nrJhzUjEP6S+O+oWwglz5xTQFaawOLwI3gO8Hjo2ZY6maB72vzPwErgEXkO8MuVaiEkcrgCK/lcfPNkhkAWgL0KYKmZiMIG9Ktn0Bx5G/wDcgXwW8R6avJ41G4HQOufInlas5ZO5+UpnJAU3AFyy7J44xe8BnoOk/JruwYo92bigAAAAASUVORK5CYII=);      background-repeat: no-repeat;      background-position: 0 0;      background-size: contain;      text-decoration: none;      padding-right: .25rem    }    .mini-audio-player .btn-download .icon-download-done {      width: .45rem;      height: .45rem;      position: absolute;      bottom: 0;      right: 0;      display: inline-block;      background-image: url(data:image/png;base64,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);      background-repeat: no-repeat;      background-position: 0 0;      background-size: contain    }</style><style type="text/css">    .MathJax_Display {      overflow: auto    }    .poster {      position: fixed;      left: -10000px;      top: -10000px;      overflow: hidden;      padding: 1rem;      background: #ececec    }    .richcontent-pre-copy {      font-size: 13px;      color: #888;      position: absolute;      right: 1em;      top: .2em;      cursor: pointer;      -webkit-user-select: none;      -moz-user-select: none;      -ms-user-select: none;      user-select: none    }    .richcontent-pre-copy .iconfont {      font-size: 12px;      margin-right: .2em    }</style><style type="text/css">    .comment-item {      list-style-position: inside;      width: 100%;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      margin-bottom: 1rem    }    .comment-item a {      border-bottom: none    }    .comment-item .avatar {      width: 2.625rem;      height: 2.625rem;      -ms-flex-negative: 0;      flex-shrink: 0;      border-radius: 50%    }    .comment-item .info {      margin-left: .5rem;      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1    }    .comment-item .info .hd {      width: 100%;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-pack: justify;      -ms-flex-pack: justify;      justify-content: space-between;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center    }    .comment-item .info .hd .username {      color: #888;      font-size: 15.25px;      font-weight: 400;      line-height: 1.2    }    .comment-item .info .hd .control {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center    }    .comment-item .info .hd .control .btn-share {      color: #888;      font-size: .75rem;      margin-right: 1rem    }    .comment-item .info .hd .control .btn-praise {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      font-size: 15.25px;      text-decoration: none    }    .comment-item .info .hd .control .btn-praise i {      color: #888;      display: inline-block;      font-size: .75rem;      margin-right: .3rem;      margin-top: -.01rem    }    .comment-item .info .hd .control .btn-praise i.on,    .comment-item .info .hd .control .btn-praise span {      color: #ff5a05    }    .comment-item .info .bd {      color: #353535;      font-size: 15.25px;      font-weight: 400;      white-space: normal;      word-break: break-all;      line-height: 1.6    }    .comment-item .info .time {      color: #888;      font-size: 9px;      line-height: 1    }    .comment-item .info .reply .reply-hd {      font-size: 15.25px    }    .comment-item .info .reply .reply-hd span {      margin-left: -12px;      color: #888;      font-weight: 400    }    .comment-item .info .reply .reply-hd i {      color: #ff5a05;      font-size: 15.25px    }    .comment-item .info .reply .reply-content {      color: #353535;      font-size: 15.25px;      font-weight: 400;      white-space: normal;      word-break: break-all    }    .comment-item .info .reply .reply-time {      color: #888;      font-size: 9px    }</style><style type="text/css">    .breadcrumb {      padding: 30px 0;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -ms-flex-wrap: wrap;      flex-wrap: wrap;      background: #fff    }    .breadcrumb a.title {      color: #e57c39;      font-size: 15px;      font-weight: 400    }    .breadcrumb span.title {      color: #888;      font-size: 15px;      font-weight: 400    }    .breadcrumb .split {      color: #ccc;      font-size: 10px;      margin-right: 5px    }</style></head><body style=""><div id="app"><div data-v-87ffcada="" class="article"><div data-v-87ffcada="" class="main main-app" style="margin-top: 0px;"><h1 data-v-87ffcada="" class="article-title">          12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？</h1><div data-v-87ffcada="" class="article-info"><span data-v-87ffcada="">2018-10-17</span><span data-v-87ffcada="">王争</span></div><div data-v-87ffcada="" class="article-content typo common-content"><img data-v-87ffcada="" src="https://static001.geekbang.org/resource/image/d0/ec/d05de7616d91d99c3afe11ebd66497ec.jpg"><div data-v-87ffcada="" class="mini-audio-player"><a href="javascript:;" class="btn-play"></a><div class="audio-info"><h3>12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？</h3><p><span>朗读人：秭明&nbsp;&nbsp;&nbsp;</span><span>00:21:58 | 9026</span></p></div><audio title="12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？" src="https://res001.geekbang.org/resource/audio/a9/26/a96b4a35f61ffc7663f1ef6440bb4f26.mp3" controls="controls"></audio></div><div data-v-87ffcada="" id="article-content" class=""><div class="text">              <p>上一节我讲了冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是O(n<sup>2</sup>)，比较高，适合小规模数据的排序。今天，我讲两种时间复杂度为O(nlogn)的排序算法，<strong>归并排序</strong>和<strong>快速排序</strong>。这两种排序算法适合大规模的数据排序，比上一节讲的那三种排序算法要更常用。</p><p>归并排序和快速排序都用到了分治思想，非常巧妙。我们可以借鉴这个思想，来解决非排序的问题，比如：<strong><span class="orange">如何在O(n)的时间复杂度内查找一个无序数组中的第K大元素？</span></strong> 这就要用到我们今天要讲的内容。</p><h2>归并排序的原理</h2><p>我们先来看<strong>归并排序</strong>（Merge Sort）。</p><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p><img src="https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg" alt=""></p><p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p>从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>，这两者并不冲突。分治算法的思想我后面会有专门的一节来讲，现在不展开讨论，我们今天的重点还是排序算法。</p><!-- [[[read_end]]] --><p>前面我通过举例让你对归并有了一个感性的认识，又告诉你，归并排序用的是分治思想，可以用递归来实现。我们现在就来看看<strong>如何用递归代码来实现归并排序</strong>。</p><p>我在<a href="https://time.geekbang.org/column/article/41440">第10节</a>讲的递归代码的编写技巧你还记得吗？写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。</p><pre><code>递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p &gt;= r 不用再继续分解
</code></pre><p>我来解释一下这个递推公式。</p><p>merge_sort(p…r)表示，给下标从p到r之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q)和merge_sort(q+1…r)，其中下标q等于p和r的中间位置，也就是(p+r)/2。当下标从p到q和从q+1到r这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从p到r之间的数据就也排好序了。</p><p>有了递推公式，转化成代码就简单多了。为了阅读方便，我这里只给出伪代码，你可以翻译成你熟悉的编程语言。</p><pre><code>// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p &gt;= r  then return

  // 取p到r之间的中间位置q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}
</code></pre><p>你可能已经发现了，merge(A[p…r], A[p…q], A[q+1…r])这个函数的作用就是，将已经有序的A[p…q]和A[q+1…r]合并成一个有序的数组，并且放入A[p…r]。那这个过程具体该如何做呢？</p><p>如图所示，我们申请一个临时数组tmp，大小与A[p…r]相同。我们用两个游标i和j，分别指向A[p…q]和A[q+1…r]的第一个元素。比较这两个元素A[i]和A[j]，如果A[i]&lt;=A[j]，我们就把A[i]放入到临时数组tmp，并且i后移一位，否则将A[j]放入到数组tmp，j后移一位。</p><p>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组tmp中的数据拷贝到原数组A[p…r]中。</p><p><img src="https://static001.geekbang.org/resource/image/95/2f/95897ade4f7ad5d10af057b1d144a22f.jpg" alt=""></p><p>我们把merge()函数写成伪代码，就是下面这样：</p><pre><code>merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组
  while i&lt;=q AND j&lt;=r do {
    if A[i] &lt;= A[j] {
      tmp[k++] = A[i++] // i++等于i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }
  
  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j&lt;=r then start := j, end:=r
  
  // 将剩余的数据拷贝到临时数组tmp
  while start &lt;= end do {
    tmp[k++] = A[start++]
  }
  
  // 将tmp中的数组拷贝回A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}
</code></pre><p>你还记得<a href="https://time.geekbang.org/column/article/41149">第7讲</a>讲过的利用哨兵简化编程的处理技巧吗？merge()合并函数如果借助哨兵，代码就会简洁很多，这个问题留给你思考。</p><h2>归并排序的性能分析</h2><p>这样跟着我一步一步分析，归并排序是不是没那么难啦？还记得上节课我们分析排序算法的三个问题吗？接下来，我们来看归并排序的三个问题。</p><p><strong>第一，归并排序是<strong><strong>稳定</strong></strong>的排序算法吗？</strong></p><p>结合我前面画的那张图和归并排序的伪代码，你应该能发现，归并排序稳不稳定关键要看merge()函数，也就是两个有序子数组合并成一个有序数组的那部分代码。</p><p>在合并的过程中，如果A[p…q]和A[q+1…r]之间有值相同的元素，那我们可以像伪代码中那样，先把A[p…q]中的元素放入tmp数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p><p><strong>第二，归并排序的<strong><strong>时间复杂度</strong></strong>是多少？</strong></p><p>归并排序涉及递归，时间复杂度的分析稍微有点复杂。我们正好借此机会来学习一下，如何分析递归代码的时间复杂度。</p><p>在递归那一节我们讲过，递归的适用场景是，一个问题a可以分解为多个子问题b、c，那求解问题a就可以分解为求解问题b、c。问题b、c解决之后，我们再把b、c的结果合并成a的结果。</p><p>如果我们定义求解问题a的时间是T(a)，求解问题b、c的时间分别是T(b)和 T( c)，那我们就可以得到这样的递推关系式：</p><pre><code>T(a) = T(b) + T(c) + K
</code></pre><p>其中K等于将两个子问题b、c的结果合并成问题a的结果所消耗的时间。</p><p>从刚刚的分析，我们可以得到一个重要的结论：<strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p><p>套用这个公式，我们来分析一下归并排序的时间复杂度。</p><p>我们假设对n个元素进行归并排序需要的时间是T(n)，那分解成两个子数组排序的时间都是T(n/2)。我们知道，merge()函数合并两个有序子数组的时间复杂度是O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</p><pre><code>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n&gt;1
</code></pre><p>通过这个公式，如何来求解T(n)呢？还不够直观？那我们再进一步分解一下计算过程。</p><pre><code>T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......
</code></pre><p>通过这样一步一步分解推导，我们可以得到T(n) = 2^k<em>T(n/2^k)+k</em>n。当T(n/2^k)=T(1)时，也就是n/2^k=1，我们得到k=log<sub>2</sub>n 。我们将k值代入上面的公式，得到T(n)=C<em>n+n</em>log<sub>2</sub>n 。如果我们用大O标记法来表示的话，T(n)就等于O(nlogn)。所以归并排序的时间复杂度是O(nlogn)。</p><p>从我们的原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是O(nlogn)。</p><p><strong>第三，归并排序的<strong><strong>空间复杂度</strong></strong>是多少？</strong></p><p>归并排序的时间复杂度任何情况下都是O(nlogn)，看起来非常优秀。（待会儿你会发现，即便是快速排序，最坏情况下，时间复杂度也是O(n<sup>2</sup>)。）但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。</p><p>这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。这一点你应该很容易理解。那我现在问你，归并排序的空间复杂度到底是多少呢？是O(n)，还是O(nlogn)，应该如何分析呢？</p><p>如果我们继续按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是O(nlogn)。不过，类似分析时间复杂度那样来分析空间复杂度，这个思路对吗？</p><p>实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过n个数据的大小，所以空间复杂度是O(n)。</p><h2>快速排序的原理</h2><p>我们再来看快速排序算法（Quicksort），我们习惯性把它简称为“快排”。快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。我们待会会讲两者的区别。现在，我们先来看下快排的核心思想。</p><p>快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。</p><p>我们遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。经过这一步骤之后，数组p到r之间的数据就被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。</p><p><img src="https://static001.geekbang.org/resource/image/4d/81/4d892c3a2e08a17f16097d07ea088a81.jpg" alt=""></p><p>根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。</p><p>如果我们用递推公式来将上面的过程写出来的话，就是这样：</p><pre><code>递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)

终止条件：
p &gt;= r
</code></pre><p>我将递推公式转化成递归代码。跟归并排序一样，我还是用伪代码来实现，你可以翻译成你熟悉的任何语言。</p><pre><code>// 快速排序，A是数组，n表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r为下标
quick_sort_c(A, p, r) {
  if p &gt;= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}
</code></pre><p>归并排序中有一个merge()合并函数，我们这里有一个partition()分区函数。partition()分区函数实际上我们前面已经讲过了，就是随机选择一个元素作为pivot（一般情况下，可以选择p到r区间的最后一个元素），然后对A[p…r]分区，函数返回pivot的下标。</p><p>如果我们不考虑空间消耗的话，partition()分区函数可以写得非常简单。我们申请两个临时数组X和Y，遍历A[p…r]，将小于pivot的元素都拷贝到临时数组X，将大于pivot的元素都拷贝到临时数组Y，最后再将数组X和数组Y中数据顺序拷贝到A[p…r]。</p><p><img src="https://static001.geekbang.org/resource/image/66/dc/6643bc3cef766f5b3e4526c332c60adc.jpg" alt=""></p><p>但是，如果按照这种思路实现的话，partition()函数就需要很多额外的内存空间，所以快排就不是原地排序算法了。如果我们希望快排是原地排序算法，那它的空间复杂度得是O(1)，那partition()分区函数就不能占用太多额外的内存空间，我们就需要在A[p…r]的原地完成分区操作。</p><p>原地分区函数的实现思路非常巧妙，我写成了伪代码，我们一起来看一下。</p><pre><code>partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] &lt; pivot {
      swap A[i] with A[j]
      i := i+1
    }
  }
  swap A[i] with A[r]
  return i

</code></pre><p>这里的处理有点类似选择排序。我们通过游标i把A[p…r-1]分成两部分。A[p…i-1]的元素都是小于pivot的，我们暂且叫它“已处理区间”，A[i…r-1]是“未处理区间”。我们每次都从未处理的区间A[i…r-1]中取一个元素A[j]，与pivot对比，如果小于pivot，则将其加入到已处理区间的尾部，也就是A[i]的位置。</p><p>数组的插入操作还记得吗？在数组某个位置插入元素，需要搬移数据，非常耗时。当时我们也讲了一种处理技巧，就是交换，在O(1)的时间复杂度内完成插入操作。这里我们也借助这个思想，只需要将A[i]与A[j]交换，就可以在O(1)时间复杂度内将A[j]放到下标为i的位置。</p><p>文字不如图直观，所以我画了一张图来展示分区的整个过程。</p><p><img src="https://static001.geekbang.org/resource/image/08/e7/086002d67995e4769473b3f50dd96de7.jpg" alt=""></p><p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个6的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p><p>到此，快速排序的原理你应该也掌握了。现在，我再来看另外一个问题：快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？</p><p><img src="https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg" alt=""></p><p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为O(nlogn)的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><h2>快速排序的性能分析</h2><p>现在，我们来分析一下快速排序的性能。我在讲解快排的实现原理的时候，已经分析了稳定性和空间复杂度。快排是一种原地、不稳定的排序算法。现在，我们集中精力来看快排的时间复杂度。</p><p>快排也是用递归来实现的。对于递归代码的时间复杂度，我前面总结的公式，这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是O(nlogn)。</p><pre><code>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n&gt;1
</code></pre><p>但是，公式成立的前提是每次分区操作，我们选择的pivot都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p><p>我举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如1，3，5，6，8。如果我们每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约n次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约n/2个元素，这种情况下，快排的时间复杂度就从O(nlogn)退化成了O(n<sup>2</sup>)。</p><p>我们刚刚讲了两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均情况时间复杂度是多少呢？</p><p>我们假设每次分区操作都将区间分成大小为9:1的两个小区间。我们继续套用递归时间复杂度的递推公式，就会变成这样：</p><pre><code>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。

T(n) = T(n/10) + T(9*n/10) + n； n&gt;1
</code></pre><p>这个公式的递推求解的过程非常复杂，虽然可以求解，但我不推荐用这种方法。实际上，递归的时间复杂度的求解方法除了递推公式之外，还有递归树，在树那一节我再讲，这里暂时不说。我这里直接给你结论：T(n)在大部分情况下的时间复杂度都可以做到O(nlogn)，只有在极端情况下，才会退化到O(n<sup>2</sup>)。而且，我们也有很多方法将这个概率降到很低，如何来做？我们后面章节再讲。</p><h2>解答开篇</h2><p>快排核心思想就是<strong>分治</strong>和<strong>分区</strong>，我们可以利用分区的思想，来解答开篇的问题：O(n)时间复杂度内求无序数组中的第K大元素。比如，4， 2， 5， 12， 3这样一组数据，第3大元素就是4。</p><p>我们选择数组区间A[0…n-1]的最后一个元素A[n-1]作为pivot，对数组A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p><p>如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1, 说明第K大元素出现在A[p+1…n-1]区间，我们再按照上面的思路递归地在A[p+1…n-1]这个区间内查找。同理，如果K&lt;p+1，那我们就在A[0…p-1]区间查找。</p><p><img src="https://static001.geekbang.org/resource/image/89/91/898d94fc32e0a795fd65897293b98791.jpg" alt=""></p><p>我们再来看，为什么上述解决思路的时间复杂度是O(n)？</p><p>第一次分区查找，我们需要对大小为n的数组执行分区操作，需要遍历n个元素。第二次分区查找，我们只需要对大小为n/2的数组执行分区操作，需要遍历n/2个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为1。</p><p>如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于2n-1。所以，上述解决思路的时间复杂度就为O(n)。</p><p>你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行K次，找到的数据不就是第K大元素了吗？</p><p>不过，时间复杂度就并不是O(n)了，而是O(K * n)。你可能会说，时间复杂度前面的系数不是可以忽略吗？O(K * n)不就等于O(n)吗？</p><p>这个可不能这么简单地划等号。当K是比较小的常量时，比如1、2，那最好时间复杂度确实是O(n)；但当K等于n/2或者n时，这种最坏情况下的时间复杂度就是O(n<sup>2</sup>)了。</p><h2>内容小结</h2><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和merge()合并函数。同理，理解快排的重点也是理解递推公式，还有partition()分区函数。</p><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是O(n)。正因为此，它也没有快排应用广泛。</p><p>快速排序算法虽然最坏情况下的时间复杂度是O(n<sup>2</sup>)，但是平均情况下时间复杂度都是O(nlogn)。不仅如此，快速排序算法时间复杂度退化到O(n<sup>2</sup>)的概率非常小，我们可以通过合理地选择pivot来避免这种情况。</p><h2>课后思考</h2><p>现在你有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB，你有什么好的解决思路，能“快速”地将这10个日志文件合并吗？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p><hr></hr><p><span class="orange">我已将本节内容相关的详细代码更新到GitHub，<a href="https://github.com/wangzheng0822/algo">戳此</a>即可查看。</span></p><p><img src="https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg" alt=""></p></div></div></div><div data-v-87ffcada="" class="article-comments"><h2 data-v-87ffcada=""><span data-v-87ffcada="">精选留言</span></h2><ul data-v-87ffcada="">            <li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">峰</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>26</span></a></div>
	</div>
	<div class="bd">每次从各个文件中取一条数据，在内存中根据数据时间戳构建一个最小堆，然后每次把最小值给写入新文件，同时将最小值来自的那个文件再出来一个数据，加入到最小堆中。这个空间复杂度为常数，但没能很好利用1g内存，而且磁盘单个读取比较慢，所以考虑每次读取一批数据，没了再从磁盘中取，时间复杂度还是一样O(n)。</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d6/c1/3f86c56a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Light Lin</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>168</span></a></div>
	</div>
	<div class="bd">伪代码反而看得费劲，可能还是对代码不够敏感吧</div> <span class="time">2018-10-17</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">那我以后还是写代码吧</p> <p class="reply-time">2018-10-17</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d2/7e/bd8c372a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">你有资格吗？</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>85</span></a></div>
	</div>
	<div class="bd">建议还是写源码吧，伪代码不能体现细节，基础不好的同学看起来也费劲，还有一个问题课后思考能不能在下一节课开头讲一下，因为感觉您每次留的课后思考都很精辟，想知道以您的维度怎么来思考和解决这个问题</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/3a/4d/a3237b34.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李建辉</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>65</span></a></div>
	</div>
	<div class="bd">先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O（n），空间复杂度是O（1）,几乎不占用内存，这是我想出的认为最好的操作了，希望老师指出最佳的做法！！！</div> <span class="time">2018-10-28</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">你回答的不错 思路是正确的</p> <p class="reply-time">2018-10-29</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/dc/fa/3975f8da.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">王先统</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>51</span></a></div>
	</div>
	<div class="bd">可以为每个文件分配一个40M的数组，再另外分配一个400M的数组储存归并结果，每个文件每次读取40M，对十个数组做归并排序直到其中某个数组的数据被处理完，这时将归并结果写入磁盘，处理完的数组继续读入40M继续参与归并，以此类推，直到所有文件都处理完</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/f9/98/f11c9b8b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">侯金彪</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>27</span></a></div>
	</div>
	<div class="bd">老师，有个问题没懂，在一个数组中找第k大的数这个问题中，为什么如果p+1=k，a[p]就是要查找的结果呢？</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/15/69/fc60d1f4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">陈华应</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>15</span></a></div>
	</div>
	<div class="bd">坚持初衷，死磕就行，不退缩，不放弃！</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/e8/1b/9d1c6077.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">曹源</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>13</span></a></div>
	</div>
	<div class="bd">先取得十个文件时间戳的最小值数组的最小值a，和最大值数组的最大值b。然后取mid=(a+b)&#47;2，然后把每个文件按照mid分割，取所有前面部分之和，如果小于1g就可以读入内存快排生成中间文件，否则继续取时间戳的中间值分割文件，直到区间内文件之和小于1g。同理对所有区间都做同样处理。最终把生成的中间文件按照分割的时间区间的次序直接连起来即可。</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/13/35/45391914.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">冷笑的花猫</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>12</span></a></div>
	</div>
	<div class="bd">老师您好，最后的思考题思路基本都是先拆成小文件，然后取出topK，最后再合并。疑惑的是内存不够，怎么读到内存中。如果不读到内存中该怎么实现，读不读到内存中的标准是什么？如果每个文件都是3g，内存只有1g，思路类似。老师能提供下详细的代码吗？相信绝大部分同学都有疑惑，谢谢。</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f2/67/fd7c8a97.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">周茜(Diane)</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>11</span></a></div>
	</div>
	<div class="bd">看了十几节课，第一次留言竟然是支持老师写伪代码。捂脸。不希望被代表。另外希望总结的同学，尽量少写一点吧，翻着太累了。我也写总结，在自己的笔记应用里。默写。写完再查漏补缺。感觉效果很好，也能检查自己到底学进去多少。</div> <span class="time">2018-10-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">我来也</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>10</span></a></div>
	</div>
	<div class="bd">我觉得最后的思考题，[曹源]同学的策略是较优的。<br>该策略的最大好处是充分利用了内存。<br>但是我还是会这么做：<br>1.申请10个40M的数组和一个400M的数组。<br>2.每个文件都读40M，取各数组中最大时间戳中的最小值。<br>3.然后利用二分查找，在其他数组中快速定位到小于&#47;等于该时间戳的位置，并做标记。<br>4.再把各数组中标记位置之前的数据全部放在申请的400M内存中，<br>5.在原来的40M数组中清除已参加排序的数据。[可优化成不挪动数据，只是用两个索引标记有效数据的起始和截止位置]<br>6.对400M内存中的有效数据[没装满]做快排。<br>将排好序的直接写文件。<br>7.再把每个数组尽量填充满。从第2步开始继续，知道各个文件都读区完毕。<br>这么做的好处有：<br>1.每个文件的内容只读区一次，且是批量读区。比每次只取一条快得多。<br>2.充分利用了读区到内存中的数据。曹源 同学在文件中查找那个中间数是会比较困难的。<br>3.每个拷贝到400M大数组中参加快排的数据都被写到了文件中，这样每个数只参加了一次快排。</div> <span class="time">2018-10-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d5/f0/1f86793d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">sherry</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>9</span></a></div>
	</div>
	<div class="bd">还是觉得伪代码更好，理解思路然后可以写成自己写练练手，看完代码后就没啥想写的欲望了。</div> <span class="time">2018-10-21</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">真是众口难调啊😢</p> <p class="reply-time">2018-10-23</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/07/57/4afabdcb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Lx</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>8</span></a></div>
	</div>
	<div class="bd">合并函数借助哨兵简化方法<br>传入的后两个数组各在尾部多放一个和原有最后值相同的值。循环改为：while i&lt;=q or j&lt;=r do{    if A[i] &lt;= A[j] and i&lt;=q {        tmp[k++] = A[i++]    }    else{        tmp[k++] = A[j++]    }}可以在while循环里完成两个数组的清空，不需要专用部分完成。</div> <span class="time">2018-10-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">yaya</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>8</span></a></div>
	</div>
	<div class="bd">以前写快排的时候总是喜欢用第一个元素作为k值，partion喜欢用找到左右不符合规则的元素再对调，第k大总是纠结于，下次递归应该是第几大，😂这些其实只要把最后一个元素作为key就可以简化代码了。这门课让我懂了以前好多不懂得小细节。应该说曾经认为自己懂了吧，尤其是排序这里。<br>思考题，由于本来十个部分就是有序的，利用十个index，把这十个读入内存比较，在里面选择最小的一个index增1，如果一个部分放完了，就继续放剩下的九个部分，直到只剩一个部分，再复制。</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/31/f4/7faa6f42.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">陈晨</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>7</span></a></div>
	</div>
	<div class="bd">懵逼了，智商欠费，今天晚上死磕这篇了</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">朱月俊</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>7</span></a></div>
	</div>
	<div class="bd">假设这十个文件都在本地，同时打开这十个文件，每个文件加一个offset，每次比较十个文件中每个文件最新的一条日志，按照时间戳获取时间戳最小的一条日志，然后对应文件offset加1，按照这种方法可以把在内存很小的情况下读完文件，积累一定大小记录在内存后flush到磁盘。 </div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/dc/a1/59b9d589.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">见贤思齐</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>6</span></a></div>
	</div>
	<div class="bd">我测试出，伪代码中<br>&#39;<br>partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br>&#39;<br><br>&#39;  for j := p to r-1 do &#39;<br><br>中的 r-1 应该是 r</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/52/53/a30b1eb2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">lovedebug</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>6</span></a></div>
	</div>
	<div class="bd">建议为github上代码示例都加上最好&#47;最坏&#47;平均时间复杂度，方便自己分析</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">spark</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>5</span></a></div>
	</div>
	<div class="bd">用java来写吧，估计这里90％都是java开发！伪代码看的蛋疼</div> <span class="time">2018-10-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/4c/8f/a90b3969.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">oldman</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>5</span></a></div>
	</div>
	<div class="bd">我用python实现了归并排序和快速排序，代码如下：<br>归并排序：https:&#47;&#47;github.com&#47;lipeng1991&#47;testdemo&#47;blob&#47;master&#47;45_merge_sort.py<br>快速排序： https:&#47;&#47;github.com&#47;lipeng1991&#47;testdemo&#47;blob&#47;master&#47;23_quick_sort.py<br>欢迎一起探讨。今天又回想了一下上一节的三个排序和今天的两个排序，自己又动手画了一下图，实现了一下代码，确切来讲，要想很深的掌握这些东西是需要不断的回想，不断的训练来加深印象的，想想以前学习算法为什么会感觉那么的难，其实就是练的不够，不要太着急的一下子把所有的算法都实现一遍，温故而知新，跟着老师的这个专栏来，一点一点的啃，啃着现在的复习前面的，你会越来越有成就感，你会越来越自信，这就是建立在不断的训练的基础上的。</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">煦暖</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>5</span></a></div>
	</div>
	<div class="bd">对于“为什么如果p+1=k，a[p]就是要查找的结果呢？”的问题感到不解的同学，我想你是从小到大排序的，所以不理解p+1=k，a[p]就是要查找的结果，如果你是从大到小排序的就不难理解了。</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">伟忠</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>4</span></a></div>
	</div>
	<div class="bd">日志文件本身在各个机器上是拆好，并且有序的，利用归并排序思想，只要合并文件就行。<br>可以两两合并最终成一个文件。<br>还有一个更省内存的办法，所有日志都打开按行读取，比较n个文件第一行，得到哪个最小，直接写入最小的到汇总结果文件中，对应文件读下一行，如此一直到所有文件读完，也就合并完了</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/4c/63/f5988a98.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">斗米担米</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">当 T(n&#47;2^k)=T(1) 时，也就是 n&#47;2^k=1<br>这个为什么会等于T(1)啊</div> <span class="time">2018-11-05</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">最后数据区间变成1的时候排序就完成了 我们看n经过了多少次分解会变成1</p> <p class="reply-time">2018-11-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/a3/ee/636415d8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">永昌</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">开始进入课程深水区，看一遍是没那么容易明白滴</div> <span class="time">2018-11-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/22/af/1a31bc11.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">The Sword of Damocles</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">王道考研书上看到的快排算法，利用哨兵减少了交换两个元素的复杂步骤，效果更好一些<br>private static void quickSort(int[] a, int head, int tail) {<br><br>        int low = head;<br>        int high = tail;<br>        int pivot = a[low];<br>        if (low &lt; high) {<br><br>            while (low&lt;high) {<br>                while (low &lt; high &amp;&amp; pivot &lt;= a[high]) high--;<br>                a[low] = a[high];<br>                while (low &lt; high &amp;&amp; pivot &gt;= a[low]) low++;<br>                a[high]=a[low];<br>            }<br>            a[low] = pivot;<br><br>            if(low&gt;head+1) quickSort(a,head,low-1);<br>            if(high&lt;tail-1) quickSort(a,high+1,tail);<br>        }<br><br>    }</div> <span class="time">2018-11-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/57/64/7e956620.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">陶瓷杯</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">请问merge() 合并函数如何借助哨兵进行优化处理？<br></div> <span class="time">2018-10-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">姜威</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">三、快速排序<br>1.算法原理<br>快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。然后遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将povit放到中间。经过这一步之后，数组p到r之间的数据就分成了3部分，前面p到q-1之间都是小于povit的，中间是povit，后面的q+1到r之间是大于povit的。根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。<br>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)<br>终止条件：p &gt;= r<br>2.代码实现（参见下一条留言）<br>3.性能分析<br>1）算法稳定性：<br>因为分区过程中涉及交换操作，如果数组中有两个8，其中一个是pivot，经过分区处理后，后面的8就有可能放到了另一个8的前面，先后顺序就颠倒了，所以快速排序是不稳定的排序算法。比如数组[1,2,3,9,8,11,8]，取后面的8作为pivot，那么分区后就会将后面的8与9进行交换。<br>2）时间复杂度：最好、最坏、平均情况<br>快排也是用递归实现的，所以时间复杂度也可以用递推公式表示。<br>如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并的相同。<br>T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。<br>T(n) = 2*T(n&#47;2) + n； n&gt;1<br>所以，快排的时间复杂度也是O(nlogn)。<br>如果数组中的元素原来已经有序了，比如1，3，5，6，8，若每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的，需要进行大约n次的分区，才能完成整个快排过程，而每次分区我们平均要扫描大约n&#47;2个元素，这种情况下，快排的时间复杂度就是O(n^2)。<br>前面两种情况，一个是分区及其均衡，一个是分区极不均衡，它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均时间复杂度是多少呢？T(n)大部分情况下是O(nlogn)，只有在极端情况下才是退化到O(n^2)，而且我们也有很多方法将这个概率降低。<br>3）空间复杂度：快排是一种原地排序算法，空间复杂度是O(1)<br>四、归并排序与快速排序的区别<br>归并和快排用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？<br>1.归并排序，是先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。何为自下而上？就是先解决子问题，再解决父问题。<br>2.快速排序，是先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。何为自上而下？就是先解决父问题，再解决子问题。<br>五、思考<br>1.O(n)时间复杂度内求无序数组中第K大元素，比如4，2，5，12，3这样一组数据，第3大元素是4。<br>我们选择数组区间A[0...n-1]的最后一个元素作为pivot，对数组A[0...n-1]进行原地分区，这样数组就分成了3部分，A[0...p-1]、A[p]、A[p+1...n-1]。<br>如果如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1，说明第K大元素出现在A[p+1...n-1]区间，我们按照上面的思路递归地在A[p+1...n-1]这个区间查找。同理，如果K&lt;p+1，那我们就在A[0...p-1]区间查找。<br>时间复杂度分析？<br>第一次分区查找，我们需要对大小为n的数组进行分区操作，需要遍历n个元素。第二次分区查找，我们需要对大小为n&#47;2的数组执行分区操作，需要遍历n&#47;2个元素。依次类推，分区遍历元素的个数分别为n、n&#47;2、n&#47;4、n&#47;8、n&#47;16......直到区间缩小为1。如果把每次分区遍历的元素个数累加起来，就是等比数列求和，结果为2n-1。所以，上述解决问题的思路为O(n)。<br>2.有10个访问日志文件，每个日志文件大小约为300MB，每个文件里的日志都是按照时间戳从小到大排序的。现在需要将这10个较小的日志文件合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述任务的机器内存只有1GB，你有什么好的解决思路能快速地将这10个日志文件合并？</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1f/bb/c488d5db.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">刘远通</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">老师 这个地方我没看懂...<br>“第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n&#47;2 的数组执行分区操作，需要遍历 n&#47;2 个元素。依次类推，分区遍历元素的个数分别为、n&#47;2、n&#47;4、n&#47;8、n&#47;16.……直到区间缩小为 1。”<br>这里讨论的是最平均的情况吗？ 最坏的情况可以n,n-1,...,1啊</div> <span class="time">2018-10-17</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">平均。你说的没错。最坏情况是你说的那样</p> <p class="reply-time">2018-10-17</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/4f/7b/47be4ead.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">趁风卷</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">快排的partition函数的空间复杂度是O(1)，但整个排序过程是递归的，最多会有O(logn)个函数放在栈里。这一部分不算空间复杂度么？</div> <span class="time">2018-10-17</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">也算的 不过低阶会被忽略</p> <p class="reply-time">2018-10-17</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1f/a7/d379ca4f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">jon</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">归并时间复杂度推导时当 T(n&#47;2^k)=T(1) 时。  这里没看懂能解释一下吗</div> <span class="time">2018-10-17</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">终止条件是T（1）。我们要不这个公式最终化简成T（1）的函数。当n&#47;2^k=1时 那就化简成T（1）的函数了</p> <p class="reply-time">2018-10-17</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/cc/33/19f150d9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">城</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">快排的伪代码写的过于简单，能否按照面试级别给我们写个实例代码呢</div> <span class="time">2018-10-17</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">就这么简单啊 面试级别是啥样子的啊</p> <p class="reply-time">2018-10-17</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/9c/06/f09b6248.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">vate</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">感觉如果是一次读取一批数据出来的话，最后计算出来的结果都会有问题，因为你无法预料某个文件下一批的日志是不是时间戳在当前这一批数据之中，所以基本上运算的单元都只能像那位同学说的一样，一次每个日志只能取出一条数据，然后十条进行排序取出最小的，但是如果单纯这样处理会导致磁盘IO大幅度的提升，极度影响性能，建议是分批读取数据到内存中(数据量暂未考虑),然后对内存中的这一批数据一条一条取出来进行计算，如果某一IO流对应的数据计算完了则继续从日志中再取出一批，这样既减少了磁盘IO提升效率，也保证了数据的准确性。</div> <span class="time">2018-12-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/94/db/abb7bfe3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">adrian-jser</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">看到好多同学说建议不要为代码的。<br>我觉得专栏文章就是教你分析问题和解决问题的思路，具体的代码不是有作者贴出的github地址吗</div> <span class="time">2018-11-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/6f/5d/f0a19f09.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">ldd</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">归并排序的merge操作使用哨兵解法：<br>用两个数组存着左右已经排序好的数，然后在后面各自都加上哨兵（这边可以放一个无限大的值），最后两个数组分别对比，替换掉p-q的数据，代码如下：<br><br>    &#47;&#47; 哨兵解法<br>    func mergeWithPlaceholder(_ items: inout Array&lt;Int&gt;, _ start: Int, _ mid: Int, _ end: Int) {<br>        var leftArr: Array&lt;Int&gt; = Array()<br>        var rightArr: Array&lt;Int&gt; = Array()<br>        var i = 0<br>        var j = 0<br>        <br>        &#47;&#47; 在两个数组后面各加上哨兵(最大值)，当一个数组到达哨兵位置后，就再也不会往后移动了，因为已经是最大的数值了<br>        for index in start...mid {<br>            leftArr.append(items[index])<br>        }<br>        leftArr.append(Int(INT_MAX))<br>        <br>        for index in mid+1...end {<br>            rightArr.append(items[index])<br>        }<br>        rightArr.append(Int(INT_MAX))<br>        <br>        for index in start...end {<br>            if leftArr[i] &lt; rightArr[j] {<br>                items[index] = leftArr[i]<br>                i += 1<br>            } else {<br>                items[index] = rightArr[j]<br>                j += 1<br>            }<br>        }<br>    }</div> <span class="time">2018-11-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ef/1d/64951154.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">stephenlee</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">老师，快排原地分区函数实现的伪代码里 <br> 把   if A[j] &lt; pivot  改成    if A[j] &lt;= pivot  的话，遇到相同值也不会把顺序颠倒吧。<br>那能不能这么理解，在这种情况下的话，快排就是稳定算法 ? <br>谢谢<br>    <br></div> <span class="time">2018-10-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ef/a7/07dce4a9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">梁成志（鹏金所）</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">学伪代码好，我可以按照老师的思路再实现出来，自己还有成就感，又可以学习。</div> <span class="time">2018-10-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Kudo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">Python实现：<br>1.归并排序：<br>def merge_sort(ls, idx_start, idx_end):<br>    if idx_end - idx_start == 0:<br>        return ls[idx_start:idx_end+1]<br>    mid = (idx_start + idx_end) &#47;&#47; 2<br>    left = merge_sort(ls, idx_start, mid)<br>    right = merge_sort(ls, mid+1, idx_end)<br>    i, j = 0, 0<br>    res = []<br>    while i &lt; len(left) and j &lt; len(right):<br>        if left[i] &lt;= right[j]:<br>            res.append(left[i])<br>            i += 1<br>        else:<br>            res.append(right[j])<br>            j += 1         <br>    if i &lt; len(left):<br>        res += left[i:]<br>    if j &lt; len(right):<br>        res += right[j:]  <br>    return res<br><br>2.快速排序：<br>def quick_sort(ls, idx_start, idx_end):<br>    if idx_end - idx_start &lt;= 0:<br>        return<br><br>    pivot = idx_end<br>    i = idx_start <br>    for j in range(i, idx_end+1):<br>        if ls[j] &lt;= ls[pivot]:<br>            ls[i], ls[j] = ls[j], ls[i]<br>            if j == pivot:<br>                pivot = i<br>            i += 1<br>    quick_sort(ls, idx_start, pivot-1)<br>    quick_sort(ls, pivot+1, idx_end)</div> <span class="time">2018-10-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mr.Panda</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">自己本地实现归并排序后，觉得归并排序终止条件p==r就可以了，没必要大于等于，因为p只存在小于等于r的情况，请作者指导下，我是不是哪里没考虑到？</div> <span class="time">2018-10-18</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">貌似是的</p> <p class="reply-time">2018-10-18</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/4e/3a/a7bd1801.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">walor</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">课后思考<br>1.申请 10 个数组，每个数组 30M。再申请个临时数组，大小 300M。<br>2.每个文件每次读取 30M 数据分别存入 30M 的数组中。<br>3.比较 10 个数组的最大时间戳，获取它们中的最小值<br>4.合并排序 10 个数组。排序完成后，取出数组前 30M 存入磁盘（硬盘上的最终日志文件），后 270M 存入文件<br>5.循环至 300M 文件读取结束，生成 10 个新的 270M 文件<br>6.重复步骤 1。<br>7.终止条件：生成的新文件大小 0M。</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/c9/a4/f5341299.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">夏天🔆</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">每个文件切成100M的区块，对比每个区块的起止时间，区块间按照起止时间排序有时间交集的load进内存进行快排成一个大文件，记录成一个大区块，最后没有时间交集的区块按照时间顺序用脚本拼接</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/03/a2/ceb37046.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">crazyone</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">曹源<br>先取得十个文件时间戳的最小值数组的最小值a，和最大值数组的最大值b。然后取mid=(a+b)&#47;2，然后把每个文件按照mid分割，取所有前面部分之和，如果小于1g就可以读入内存快排生成中间文件，否则继续取时间戳的中间值分割文件，直到区间内文件之和小于1g。同理对所有区间都做同样处理。最终把生成的中间文件按照分割的时间区间的次序直接连起来即可。<br>---------------<br>这种做法貌似不能保证最终有序，因为已经排序落盘的数据的时间戳不能保证一定比还在文件中未参与排序数据的小。只是保证了读到缓存中的数据有序。</div> <span class="time">2018-12-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/14/a1/107910b4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">OnClickListener</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">老师，关于解答开篇，在O(n)的时间复杂度内找到第K大的数，我的纠结点在于每次选择pivot的时候，应该不能保证选择到的pivot就是数组中排名中间大小的数吧。如果每次取得的pivot都是排名中间大小的元素，那我能理解第一次分区，要遍历n个元素，第二次要遍历n&#47;2个元素，第三次遍历n&#47;4...以此类推。但是pivot不可能每次都是中间大小的数吧。<br><br>极端情况下，如果是一个升序的有序数组呢，我要找到第k大的数值。每次都取数组第一个数为pivot。那么第一次分区我遍历了n个元素，第二次，我遍历了n-1个元素，第三次我遍历了n-2个元素。那是不是时间复杂度就变成O(n2)了？<br><br>反过来想，我现在要找第n-1大的数，也就是最小的数，那我是不是分区的时候遍历一遍就够了，所以时间复杂度就是O(n)?<br><br><br></div> <span class="time">2018-12-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">beiliu</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">老师，我想问一个问题，为什么快排是不稳定的，如果我们每次都取最后一个做分区点，然后0到n-1，当遍历到的数据小于等于分区点数据时就进行交换，遍历完之后再改变分区点的位置，我觉得这样快排是稳定的呀</div> <span class="time">2018-11-28</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">看下我举的例子吧</p> <p class="reply-time">2018-11-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/de/5d/307b4ee7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Kim</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">相比之前的三个排序算法理解起来比较困难，还得琢磨琢磨......</div> <span class="time">2018-11-14</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">本身就比较复杂 所以要难懂点</p> <p class="reply-time">2018-11-15</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/78/f5/915d5442.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">xr</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？<br><br>应该是每次取数组中的最“大”值放到前面吧，因为找的是第k大元素？</div> <span class="time">2018-11-14</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">嗯嗯 感谢指出</p> <p class="reply-time">2018-11-15</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/97/44/52b5e2e2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">cweioo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">分配10个50M的数组和一个500M的数组用来存前面10个数组排序后的结果，将排好序得前50M写入文件，然后再读取50M（哪个数组中数据被排序后写入文件了，就从对应原日志文件再读取）写入那10个数组中。如果其中有一个文件先读取完了，可以动态增加读取和写入的大小，只要加起来不过1G就可以了。</div> <span class="time">2018-10-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/4e/d6/3f13ee78.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">richardcao</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。<br><br>我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。<br><br>如果 p+1=K，那 A[p] 就是要求解的元素；<br><br>想问，这里p是随机选取下标？为什么p+1=K就是要求解的元素？</div> <span class="time">2018-10-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/08/c7/6b0cb046.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小花小黑的铲屎官</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">有个疑问：如果 p+1=K，那 A[p] 就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。<br>既然是无序的数组，怎么能确认K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间呢？</div> <span class="time">2018-10-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">姜威</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">代码实现<br>1.归并排序<br>&#47;&#47; 归并排序算法, A 是数组，n 表示数组大小<br>merge_sort(A, n) {<br>  merge_sort_c(A, 0, n-1)<br>}<br>&#47;&#47; 递归调用函数<br>merge_sort_c(A, p, r) {<br>  &#47;&#47; 递归终止条件<br>  if p &gt;= r  then return<br>  &#47;&#47; 取 p 到 r 之间的中间位置 q<br>  q = (p+r) &#47; 2<br>  &#47;&#47; 分治递归<br>  merge_sort_c(A, p, q)<br>  merge_sort_c(A, q+1, r)<br>  &#47;&#47; 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]<br>  merge(A[p...r], A[p...q], A[q+1...r])<br>}<br>merge(A[p...r], A[p...q], A[q+1...r]) {<br>  var i := p，j := q+1，k := 0 &#47;&#47; 初始化变量 i, j, k<br>  var tmp := new array[0...r-p] &#47;&#47; 申请一个大小跟 A[p...r] 一样的临时数组<br>  while i&lt;=q AND j&lt;=r do {<br>    if A[i] &lt;= A[j] {<br>      tmp[k++] = A[i++] &#47;&#47; i++ 等于 i:=i+1<br>    } else {<br>      tmp[k++] = A[j++]<br>    }<br>  }<br>  &#47;&#47; 判断哪个子数组中有剩余的数据<br>  var start := i，end := q<br>  if j&lt;=r then start := j, end:=r<br>  &#47;&#47; 将剩余的数据拷贝到临时数组 tmp<br>  while start &lt;= end do {<br>    tmp[k++] = A[start++]<br>  }<br>  &#47;&#47; 将 tmp 中的数组拷贝回 A[p...r]<br>  for i:=0 to r-p do {<br>    A[p+i] = tmp[i]<br>  }<br>}<br>注：merge()合并函数如果借助哨兵代码就会简洁很多<br><br>2.快速排序<br>&#47;&#47; 快速排序，A 是数组，n 表示数组的大小<br>quick_sort(A, n) {<br>  quick_sort_c(A, 0, n-1)<br>}<br>&#47;&#47; 快速排序递归函数，p,r 为下标<br>quick_sort_c(A, p, r) {<br>  if p &gt;= r then return<br>  q = partition(A, p, r) &#47;&#47; 获取分区点<br>  quick_sort_c(A, p, q-1)<br>  quick_sort_c(A, q+1, r)<br>}<br>&#47;&#47;分区函数<br>partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br>}<br>分区函数代码说明：通过游标i把A[p...r-1]分成2部分，A[p...i-1]的元素都是小于pivot的，我们暂且叫它“已处理区间”，A[i+1...r-1]是“未处理区间”。我们每次都从未处理区间取出一个元素A[j]，与poivt相比，如果小于pivot，则将其加入到已处理区间的尾部，也就是A[i]位置。</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">姜威</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">总结：归并排序和快速排序<br>一、分治思想<br>1.分治思想：分治，顾明思意，就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。<br>2.分治与递归的区别：分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。<br>二、归并排序<br>1.算法原理<br>先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。这就是归并排序的核心思想。如何用递归实现归并排序呢？写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。递推公式怎么写？如下<br>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))<br>终止条件：p &gt;= r 不用再继续分解<br>2.代码实现（参见下一条留言）<br>3.性能分析<br>1）算法稳定性：<br>归并排序稳不稳定关键要看merge()函数，也就是两个子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，那我们就可以像伪代码中那样，先把 A[p…q] 中的元素放入tmp数组，这样 就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一种稳定排序算法。<br>2）时间复杂度：分析归并排序的时间复杂度就是分析递归代码的时间复杂度<br>如何分析递归代码的时间复杂度？<br>递归的适用场景是一个问题a可以分解为多个子问题b、c，那求解问题a就可以分解为求解问题b、c。问题b、c解决之后，我们再把b、c的结果合并成a的结果。若定义求解问题a的时间是T(a)，则求解问题b、c的时间分别是T(b)和T(c)，那就可以得到这样的递推公式：T(a) = T(b) + T(c) + K，其中K等于将两个子问题b、c的结果合并成问题a的结果所消耗的时间。这里有一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。套用这个公式，那么归并排序的时间复杂度就可以表示为：<br>T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。<br>T(n) = 2*T(n&#47;2) + n； n&gt;1，其中n就是merge()函数合并两个子数组的的时间复杂度O(n)。<br>T(n) = 2*T(n&#47;2) + n<br>     = 2*(2*T(n&#47;4) + n&#47;2) + n = 4*T(n&#47;4) + 2*n<br>     = 4*(2*T(n&#47;8) + n&#47;4) + 2*n = 8*T(n&#47;8) + 3*n<br>     = 8*(2*T(n&#47;16) + n&#47;8) + 3*n = 16*T(n&#47;16) + 4*n<br>     ......<br>     = 2^k * T(n&#47;2^k) + k * n<br>     ......<br>当T(n&#47;2^k)=T(1) 时，也就是 n&#47;2^k=1，我们得到k=log2n。将k带入上面的公式就得到T(n)=Cn+nlog2n。如用大O表示法，T(n)就等于O(nlogn)。所以，归并排序的是复杂度时间复杂度就是O(nlogn)。<br>3）空间复杂度：归并排序算法不是原地排序算法，空间复杂度是O(n)<br>为什么？因为归并排序的合并函数，在合并两个数组为一个有序数组时，需要借助额外的存储空间。为什么空间复杂度是O(n)而不是O(nlogn)呢？如果我们按照分析递归的时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是O(nlogn)，但这种分析思路是有问题的！因为，在实际上，递归代码的空间复杂度并不是像时间复杂度那样累加，而是这样的过程，即在每次合并过程中都需要申请额外的内存空间，但是合并完成后，临时开辟的内存空间就被释放掉了，在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时空间再大也不会超过n个数据的大小，所以空间复杂度是O(n)。</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e1/43/7b4a11cc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">梦总被尿憋醒</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">分区找第K大元素用排序吗？</div> <span class="time">2018-10-22</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">不用排序的 用的快排思想</p> <p class="reply-time">2018-10-22</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ea/58/2aa56c18.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">蓝艺</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">自己用go写了下快排算法：<br><br>package main<br><br>import (<br>	&quot;fmt&quot;<br>	&quot;strconv&quot;<br>)<br><br>func QuickSort(A []int, p int, r int) {<br>	if p &gt;= r {<br>		return<br>	}<br>	q := Partition(A, p, r)<br>	QuickSort(A, p, q-1)<br>	QuickSort(A, q+1, r)<br><br>}<br>&#47;&#47;将数组A重排<br>func Partition(A []int, p int, r int) int {<br>	key:=A[r] &#47;&#47;最后一位作为key<br>	i:=p<br>	j:=p<br>	for j&lt;r{<br>		if A[j]&lt;key{<br>			temp:=A[i]<br>			A[i] = A[j]<br>			A[j] = temp<br>			i++<br>		}<br>		j++<br>	}<br>	temp2:=A[i]<br>	A[i] = key<br>	A[r] = temp2<br>	return i<br>}<br><br>func main() {<br>	A:=[] int{18,23,14,35,32,11,24,1,7,15,22,19,8,3,9}<br><br>	QuickSort(A,0,14)<br>	for _,a :=range A{<br>		s:=strconv.Itoa(a)+&quot;,&quot;<br>		fmt.Print(s)<br>	}<br>}<br></div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f1/02/862b6faa.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Liam</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">归并排序真的不能原地吗？</div> <span class="time">2018-10-18</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">可以原地 非常复杂 时间代价就高了</p> <p class="reply-time">2018-10-18</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ea/b7/1f7316e6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">wean</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">对课后思考，考虑到硬盘读取速度较慢，选择每次读取每个文件一部分数据到内存中排序后再刷入新文件。<br><br>每个新文件分配 40 MB 的内存空间，另开 400 MB 的待刷入空间。<br><br>每轮处理数据，首先从各个文件读取数据，补满分配的 40 MB 内存空间。然后找出十个内存空间缓冲区中，共同包含的时间戳范围内的最大时间戳，这个时间戳就是每个缓冲区可以在本轮刷入新文件的最大时间戳，定义为可刷入最大时间戳。定义每个缓冲区从开头到可刷入最大时间戳的数据区间，叫做这个缓冲区的可用数据区间。<br><br>对十个缓冲区的可用数据区间进行多路归并排序，整理到 400 MB 的待刷入区域，然后刷入新文件。<br><br>注意处理好边界条件。有文件已经读取到末尾的情况、还有所有文件都读取到末尾的情况。<br><br>循环执行以上步骤，即可完成合并。</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f0/2d/ab05d7b4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Yeni</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">正在准备面试，看了老师的课很多以前不理解的问题现在都能想通了，课讲得非常好</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">biepa</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">没有代码还是差很多的，因为有很多实现细节需要注意，talk is cheap这个不是大佬们的口头禅吗<br></div> <span class="time">2019-02-13</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/4fVe2SyIuSsGKHqPDWq5dzwuB4vqG4piaXriaWEmoJrTdpibaZibtgfmth8sd8KiaDr2DTeccJB37Xic6CpzQx2Gf3HQ/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿水</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">分析归并排序时间复杂度时为什么要让T(n&#47;2^k)=T(1)，这是什么意思？</div> <span class="time">2019-02-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ee/df/b8f18bc9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">NetworkCavalry</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">几个月前第一次看的时候，一头雾水，迷迷糊糊的了解大概的思想，代码也没有具体实现，今天要写一个快排算法的时候突然想起来这个订阅。。然后果断又把文章看了一遍，觉得老师这次讲的十分通透，一遍就过了。非常感谢！！</div> <span class="time">2019-02-11</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Pre-Y</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">今日份的打卡。<br>这类复杂的算法还是边听边写到纸上，在纸上操作数据感觉稍微轻松点。😂</div> <span class="time">2019-02-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/c1/cc/6b6bbd41.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">周小成</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">寻找第K大的值用快排分区递归的思想是很妙的解法，但是有个小问题是，会改变原来的顺序。</div> <span class="time">2019-02-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/08/d6/4b0506bb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">lonelyandrew</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">解答开篇这一小节，第五段，最后一行：<br>分区遍历元素的个数分别为(貌似这里少了一个n)、n&#47;2、n&#47;4、n&#47;8、n&#47;16……直到区间缩小为1。</div> <span class="time">2019-01-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">海军上校</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">mark不足</div> <span class="time">2019-01-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0c/a4/a5f3bb1f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">S.A.N</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">在李建辉的回答上，做些优化：<br>1. 开10个文件通道，初始每个通道加载100M的日志到内存，充分利用内存，实现高速读写<br>2. 创建一个数组，容量为10，读取内存中每个文件的首位记录，放入数组并升序排序<br>3. 取数组首位记录，写入新文件<br>4. 从数组首位记录所属文件读取首位记录，使用二分查找插入有序数组<br>5. 重复步骤三<br>6. 如果内存中的某个文件内存记录读取完毕，则遍历所有文件内存，从磁盘中加载日志记录到内存，保持每个文件100M内存记录，直至整个文件读取完毕</div> <span class="time">2019-01-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/61/c1/93031a2a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Aaaaaaaaaaayou</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">找第k大的元素还可以使用一个size为k的最小堆，把数据遍历一遍入堆，最后堆顶的元素就是所求值。这个的时间复杂度是O(nlogk)，空间复杂度是O(k)。</div> <span class="time">2019-01-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/a6/07/8580137c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">snapshot</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">后面的题目，我觉得应该用快速排序来做，而不是归并排序，因为归并一定有个merge过程，内存肯定不够，而用快速排序的话，对内存没有太大要求。<br>前期内存不够，可以用快速排序，将文件按照区块分开来，保证分出得子文件小于1g，因为是快速排序，每个文件从全局上看是有序的，然后对这些小于1g的文件，你想用那个排序就哪个排序，子文件有序后，输出到一个文件即可。<br><br>前面的回答，都没考虑merge这个过程。最优解应该是先快速排序，让子文件小于1g，然后加载到内存排序。最后合并输出。</div> <span class="time">2019-01-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/d0/4a/187721e0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">明月关</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">解答有个疑问<br>分区不一定正好分成2半吧 <br>最坏的时间复杂度应该是还是O(n^2)吧<br>分区有可能是最大的在最后面 </div> <span class="time">2019-01-19</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我们后面有讲到，可以做到基本上平均分区</p> <p class="reply-time">2019-02-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/44/74/f98299ee.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">黄均鹏</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">自己按照老师的图思路手写了一遍，还跑通了！不知道大家是不是都觉得自己要比别人聪明一点，我也同样，其实这是不是因为大家智力水平都差不多的情况才有这种想法</div> <span class="time">2019-01-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f1/74/9fb2eae8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">ab</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">   &#47;&#47;java解答开头题目，如果想要快速排序稍微快改改就好<br><br> public int findKthLargest(int[] nums, int k) {<br>        &#47;&#47;寻找数组中第k大元素，使用快速排序<br><br>        int len = nums.length;<br>        if (nums.length&lt;k){<br>            return 0;<br>        }<br>        if (nums.length&lt;=0){<br>            return 0;<br>        }<br><br>        int j = quickSort(nums, k, 0, len - 1);<br>        return nums[k-1];<br><br>    }<br>    &#47;&#47;快速排序递归<br>    private int quickSort(int[] nums, int k, int start, int end) {<br>        &#47;&#47;中间点的数。<br>        int q = nums[end];<br>        &#47;&#47;排序,获得q点在数组中的位置。。<br>        int j = sort(nums, start, end, q) ;<br><br><br>        if(j+1&lt;k) {<br>            return quickSort(nums, k, j + 1, end);<br><br>        }else if(j+1&gt;k){<br>            return quickSort(nums, k, start, j - 1);<br>        }else{<br>            return nums[j];<br>        }<br>    }<br>    private int sort(int[] nums, int start, int end, int q) {<br>        &#47;&#47;原地排序，用i来划分，i指向区间的尾部，如果nums[j]大于q则交换i区间的尾部,但是不稳定。<br>        int i = start, j = start;<br>        for (; j &lt;= end; j++) {<br>            if (nums[j] &gt;= q) {<br>                &#47;&#47;交换i和j<br>                int temp = nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = temp;<br>                i++;<br>            }<br>        }<br>        return i-1 ;<br>    }</div> <span class="time">2019-01-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/08/cd/ff5d4d46.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">张浩东</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">快排的java代码：<br><br> &#47;**<br>     *<br>     * @param arr<br>     * @param start_index<br>     * @param end_index<br>     * @param pivot<br>     *&#47;<br>    public static int shuaxin(int[] arr, int start_index, int end_index, int pivot) {<br>        if (pivot &lt; start_index || pivot &gt; end_index) {<br>            return 0;<br>        }<br>        for (int j = start_index; j &lt;= end_index; j++) {<br>            if (j &lt; pivot &amp;&amp; arr[j] &gt; arr[pivot]) {<br>                swap(arr, pivot, j);<br>                pivot = j;<br>            } else if (j &gt; pivot &amp;&amp; arr[j] &lt; arr[pivot]) {<br>                swap(arr, pivot, j);<br>                int temp = pivot;<br>                pivot = j;<br>                j = temp;<br>            }<br>        }<br>        return pivot;<br>    }<br><br>    &#47;**<br>     * 快速排序：原地排序，时间复杂度O(n*longN)，稳定排序<br>     *<br>     * @param arr<br>     * @return<br>     *&#47;<br>    public static void kuaisu(int[] arr, int start_index, int end_index) {<br>        if (start_index &gt;= end_index) {<br>            return;<br>        }<br>        int pivot = partition(start_index, end_index);<br>        System.out.println(&quot;start_index:&quot; + start_index + &quot;,end_index:&quot; + end_index + &quot;,pivot:&quot; + pivot);<br>        &#47;&#47;将小于arr[pivot] 的数放在左边，大于arr[pivot] 的数放在右边<br>        pivot = shuaxin(arr, start_index, end_index, pivot);<br><br>        kuaisu(arr, start_index, pivot - 1);<br>        kuaisu(arr, pivot + 1, end_index);<br>    }<br>&#47;**<br>     * 从小到大顺序排序<br>     *<br>     * @param args<br>     *&#47;<br>    public static void main(String[] args) {<br>        int[] arr = {1, 4, 2, 6, 9, 4, 102, 5, 6, 8, 2, 34, 54, 12, 3, -10, -8, 100, 99};<br>        kuaisu(arr, 0, arr.length - 1);<br>       System.out.println(Arrays.toString(arr));<br>}</div> <span class="time">2019-01-11</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/4d/42/8fd7c2e2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">朋朋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">膜拜 github链接上数据结构居然有这么多版本 php go c++ java 看来总有一款适合我！</div> <span class="time">2019-01-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">泉</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">归并排序，快排都可以用递归来实现。<br>归并的合并算法可以用游标需研究？<br>快排的分区算法可以参照选择排序思想。<br></div> <span class="time">2019-01-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/68/73/3cda533e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">乔良qiaoliang</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">伪代码的变量写啰嗦一点感觉更好懂<br>partition(A, left, right){<br>  pivot = A[right]<br>  boundary = left<br>  for i = letf to right-1 {<br>    if A[i] &lt; pivot {<br>      swap A[i] A[boundary]<br>      boundary++<br>    }<br>  }<br>  swap A[boundary] A[right]<br>  return boundary<br>}</div> <span class="time">2019-01-09</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">会有同学说我写的不够简洁的 众口难调啊</p> <p class="reply-time">2019-01-10</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/9a/ff/c8f9a6e2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">[Stranger,Lover)</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">例如是个日志文件时间如下：1-20   4-10   6-17  8-25  15-40  20-30  18-27.。。。因为每个日志文件都是有序的，可以先找到最小的那一段日志  第二小的那几段日志（找到后合并） 第三小的那几段日志（合并）。。。比如这几段最小的一段是 1-4，放入result，日志变为4-20 4-10 6-17 8-25 15-40 20-30 18-27，最小的一段日志为4-6，并且有两段4-6，合并。日志变为6-20   6-10  6-17 8-25 15-40 20-30，最小的一段为6-8 且有三段，合并。以此类推，而且是稳定排序,空间复杂度O（1），时间复杂度求解，麻烦老师</div> <span class="time">2019-01-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e1/69/0db70c84.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">那样的月色</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">曹源童鞋的也不行啊，按照1G来划分，每次取中间，把前面的部分合并成1G，归并排序后读到文件，问题就在这个mid，比如A文件的mid前一个是4，B文件的mid前一个是2，C文件mid前是3，先比较然后读到文件，此时读写到文件最后的是4，下一次读取的时候，B文件如果开始是3，岂不就错了吗。</div> <span class="time">2019-01-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">MOK_CHEN</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我个人觉得用什么语言来实现不是我们应该关注的重点，不管是伪代码，还是c亦或者java,对于某一些人来说可能都不熟悉。特别是我看别人的代码就会觉得很无聊，所以我都是看完动态过程分析，然后自己实现，最后才来做比对，看看有没有可以简化的东西。</div> <span class="time">2019-01-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">大大。</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">为什么归并排序不用奇数数组来做例子？</div> <span class="time">2019-01-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/39/5f/45085f93.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">冰菓㍿</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">from typing import List<br>def merge(left:List[int],right:List[int]):<br>    i,j = 0,0<br>    tmp = []<br>    while i &lt; len(left) and j &lt; len(right):<br>        if left[i] &lt; right[j]:<br>            tmp.append(left[i])<br>            i += 1<br>        else:<br>            tmp.append(right[j])<br>            j += 1<br>    tmp += left[i:]<br>    tmp += right[j:]<br>    return tmp<br>def merge_sort(a:List[int]):<br>    if len(a) &lt;= 1:<br>        return a<br>    mid = len(a)&#47;&#47;2<br>    left = merge_sort(a[:mid])<br>    right = merge_sort(a[mid:])<br>    return merge(left,right)<br>请问下这个写法中为什么tmp循环append后还要再    tmp += left[i:]<br>    tmp += right[j:]，我想的是while循环中已经逐个append的，为什么结束后还要再拼接？</div> <span class="time">2018-12-31</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/6a/6c/f1f3def2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">zhenwei</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">非递归快排实现：<br><br>def quick_sort(array):<br>	stack = []<br>	_p = 0<br>	_r = len(array) - 1<br>	stack.append([_p, _r])<br>	while True:<br>		if 0 &gt;= stack.__len__():<br>			break<br>		p, r = stack.pop()<br>		if p &gt;= r: <br>			continue<br>		pivot = r<br>		h = p<br>		while h &lt; pivot:<br>			if array[h] &gt; array[pivot]:<br>				tmp = array[pivot]<br>				array[pivot] = array[h]<br>				array[h] = array[pivot - 1]<br>				array[pivot - 1] = tmp<br>				pivot = pivot -1<br>			else:<br>				h = h + 1<br>		stack.append([p, pivot - 1])<br>		stack.append([pivot + 1, r])<br></div> <span class="time">2018-12-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/5f/67/8552dab9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Yeir</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">partition函数的伪代码和示意图不匹配吧. 伪代码j是不会动的, 而图里面i和j都会移动</div> <span class="time">2018-12-28</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f9/9e/e316690f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">槑槑</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">临时忽略一些代码本身消耗的空间，将1G &#47;10 = 100M，<br>开10个IO去读每一个日志文件，那每个IO读3次左右。<br>先merge 10个100M的，然后再merge 3次的。<br>记每个文件需要读m次，每一次需要读n个文件。<br>merge_m(m){<br>if (m ==2){<br>merge(2,1)<br>}<br>return  merge_m(m-1) + merge_m(m-2)<br>}<br><br>&#47;&#47; 生成n个文件的merge结果，被调用m次<br> mergn_n(n){<br>if (n ==2){<br>merge(2,1)<br>}<br>return mergn_n(n-1) + mergn_n(n-2)<br>}<br>}<br><br><br><br><br></div> <span class="time">2018-12-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Ben</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd"><br># 用快速排序查找第K大元素 1=&lt;K&lt;=len(arr)<br>def QuickSortPosK(arr, K):<br>    # 基准值为数组首位,末位,中间位数字的平均值<br>    if len(arr) == 1 : return arr[0]<br>    pivot = arr[-1]<br>    # 推导式简单实现[i, pivot]<br>    less = [i for i in arr[:] if i &lt;= pivot]<br>    greater = [i for i in arr[:] if i &gt; pivot]<br>    lenLess = len(less)<br>    if lenLess == K:<br>        return less[-1]<br>    elif lenLess &gt; K:<br>        return QuickSortPosK(less[:-1], K)<br>    elif lenLess &lt; K:<br>        return QuickSortPosK(greater, K-lenLess)<br> <br>print(&#39;QuickSortPosK&#39;,QuickSortPosK([90, 0, -1, 22, 3,3,3],4))<br><br># 编程珠玑实现<br># 双向排序: 提高非随机输入的性能<br># 不需要额外的空间,在待排序数组本身内部进行排序<br># 基准值通过random随机选取<br># 入参: 待排序数组, 数组开始索引 0, 数组结束索引 len(array)-1<br>import random<br><br>def swap(arr, l, u):<br>    arr[l],arr[u] = arr[u],arr[l]<br>    return arr<br><br>def QuickSort_Perl(arr, l, u):<br>    # 小数组排序i可以用插入或选择排序 <br>    # if u-l &lt; 50 : return arr<br>    # 基线条件: low index = upper index; 也就是只有一个值的区间<br>    if l &gt;= u:<br>        return arr<br>    # 随机选取基准值, 并将基准值替换到数组第一个元素        <br>    swap(arr, l, int(random.uniform(l, u)))<br>    temp = arr[l]<br>    # 缓存边界值, 从上下边界同时排序<br>    i, j = l, u<br>    while True:<br>        # 第一个元素是基准值,所以要跳过<br>        i+=1<br>        # 在小区间中, 进行排序<br>        # 从下边界开始寻找大于基准值的索引<br>        while i &lt;= u and arr[i] &lt;= temp:<br>            i += 1<br>        # 从上边界开始寻找小于基准值的索引<br>        # 因为j肯定大于i, 所以索引值肯定在小区间中<br>        while arr[j] &gt; temp:<br>            j -= 1<br>        # 如果小索引仍小于大索引, 调换二者位置<br>        if i &gt;= j:<br>            break<br>        arr[i], arr[j] = arr[j], arr[i]<br>    # 将基准值的索引从下边界调换到索引分割点<br>    swap(arr, l, j)<br>    QuickSort_Perl(arr, l, j-1)<br>    QuickSort_Perl(arr, j+1, u)<br>    return arr<br><br>print(&#39;QuickSort_Perl([-22, -21, 0, 1, 2, 22])&#39;,<br>      QuickSort_Perl([-22, -21, 0, 1, 2, 22], 0, 5))<br></div> <span class="time">2018-12-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Ben</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">大牛好, 在推导归并排序时间复杂度的过程中有个疑问. <br><br>T(n) = 2*T(n&#47;2) + n； n&gt;1. 这里最后的n和参数中的n是同样的意义吗? <br>这个位置的意义是一个常量值吧,应该是和参数n有关联,但是决不能简单用n来代替.<br>等式左右代表的是估计的时间, n应该是C(n).<br>非常不理解为什么直接用n表示常量, 而且后面的推导结果很大程度上依赖于此.<br><br><br></div> <span class="time">2018-12-26</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">c*n也可以的 没有区别 表示两个有序数组合并的时间复杂度</p> <p class="reply-time">2018-12-26</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/9e/b5/17ff83e6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Leo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">在内容小结里面说归并排序是不稳定排序？应该是写错了</div> <span class="time">2018-12-25</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">内容小姐里 没有写啊 写了不是原地排序</p> <p class="reply-time">2018-12-26</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/b3/3b/1104b8e6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">XinghaiVictorStarseaSingHoy星海</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这个表述想了好久……是找顺序排列的第K个元素，而不是第k大吧……第k大是 kth largest, 说的是从大到小排列第K个元素。你看，如果代K为1，第一大的的元素，岂不是最小的元素了吗</div> <span class="time">2018-12-25</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">嗯嗯 👍 我语文没学好 </p> <p class="reply-time">2018-12-26</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/07/8c/51401220.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小美</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">网名我来也得解题思路欠妥，按40兆分割，怎么保证第二个文件除去40兆后剩下的一定比第一个文件40兆内的大</div> <span class="time">2018-12-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">左瞳</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">快排的元素交换不是也要申请空间吗？为啥空间复杂度是1</div> <span class="time">2018-12-24</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">ban</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">把取出来的 10 个订单放到优先级队列中，取出最大值（也就是大顶堆堆顶数据），就是全局金额最大的订单。然后再从这个全局金额最大订单对应的数据库中，取出下一条订单（按照订单金额从大到小排列的），然后放到优先级队列中。一直重复上面的过程。<br><br>老师这段话我看到好多遍，想了好多次一直没搞懂，为什么取出最大金额的数据库查到下一条订单放到队列能理解，但是下次重复这个过程还是从队列中取出最大金额的下一个订单，这样每次最大的金额不是同一个吗，取出的订单还是同一个？<br><br>还有另外一个问题就是全部取出来后怎么判断这个队列是top k的订单金额？<br><br>求老师讲解，自己研究好久没搞透</div> <span class="time">2018-12-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/87/0491e9e5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Lisa Li</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">“第二次分区查找，我们只需要对大小为 n&#47;2 的数组执行分区操作，需要遍历 n&#47;2 个元素。依次类推，分区遍历元素的个数分别为、n&#47;2、n&#47;4、n&#47;8、n&#47;16.……直到区间缩小为 1。” 这个没有明白怎么算出来的。比如，一共16个数，所以是16+8+4+2+1。按公式1*(1-2^5)&#47;(1-2)=31 和给出的2*n-1=31是一样的。我想知道等比数列的一共有多少项是怎么求的。</div> <span class="time">2018-12-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f8/87/0491e9e5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Lisa Li</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">文章里提到了数据规模。数据规模叫做大，多大叫做小。是10万以内的叫小，还是放不进内存的叫大。</div> <span class="time">2018-12-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/78/c6/8ec68307.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李乐</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师能否再解释一下你的例子中哪里说明了快排一定不是稳定的排序方式，我没发现不稳定啊<br>6&#39;876&#39;&#39;359 4<br>3 4 6&#39;876&#39;&#39;59<br>      6&#39;876&#39;&#39;5     9<br>      5 6&#39;876&#39;&#39;<br>         6&#39; 6&#39;&#39; 87<br>                  7 8<br>3 4 5 6&#39; 6&#39;&#39; 7 8 9</div> <span class="time">2018-12-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/c7/67/0077314b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">田佳伟</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">T(n) = 2*T(n&#47;2) + n<br>     = 2*(2*T(n&#47;4) + n&#47;2) + n = 4*T(n&#47;4) + 2*n<br>     = 4*(2*T(n&#47;8) + n&#47;4) + 2*n = 8*T(n&#47;8) + 3*n<br>     = 8*(2*T(n&#47;16) + n&#47;8) + 3*n = 16*T(n&#47;16) + 4*n<br>     ......<br>     = 2^k * T(n&#47;2^k) + k * n<br>     ......<br>老师，这个推导公式里边，每一行都多加了 n 2*n 3*n …… 这个是为了凑规律吗？ </div> <span class="time">2018-12-17</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">当然不是凑啊 本来就有的</p> <p class="reply-time">2018-12-18</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">匆匆</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">归并排序（稳定）：最好最快平均时间复杂度均为O(nlogn)，空间复杂度为O(n)。由于不是原地排序算法，所以应用度不如快排。<br><br>快速排序（不稳定）：最好时间复杂度O(nlogn),最快时间复杂度O(n^2),平均O(nlogn)，是原地排序算法。<br><br>总结：归并排序和快排都是利用了分治的思想，分而治之，不过归并是由下到上处理，先处理小的，然后合并。快排是由上到下处理，先分区，在处理子问题。快排可利用多种方法将最坏情况概率降到很低，由于不占用更多内存空间，所以使用更多。</div> <span class="time">2018-12-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/34/b0/21542648.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Cmder</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">要明白一点的是，第k个数，在数组里面，下标是k-1。比如，第一个数，下标是0</div> <span class="time">2018-12-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/4e/f47fcbc2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">唯她命</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">随机数快排 非常慢。。。</div> <span class="time">2018-12-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/27/06/b38cdd37.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Brandon</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">分治是一种解决问题的处理思想，递归是一种编程技巧<br>非原地排序，是稳定排序，时间复杂度O(nlogn),空间O(n)<br><br>归并：从小到大，非原地空间复杂度O(n)<br>快速：从大到小，有可能退化为时间复杂度O(n*n)<br><br>快排的方式找到第K大和冒泡方式的时间复杂度是<br>O(n) 和 O(kn) 解答 了我的疑问<br><br>问答：</div> <span class="time">2018-12-11</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/76/9d/bfcdbdda.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">大悲</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">归并排序也可以原地实现，这样的话时间复杂度虽然也是n(lgn)，但系数比较高。请问可以这样理解么？</div> <span class="time">2018-12-11</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">可以的</p> <p class="reply-time">2018-12-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/1b/e2/399084b1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">xia哈</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">归并-哨兵-java<br>    private void mergeData(int[] data, int start, int middle, int end) {<br><br>        int[] temp = new int[data.length + 2];<br>        int index = 0;<br>        for (int i = start; i &lt;= middle; i++) {<br>            temp[index++] = data[i];<br>        }<br>        temp[index++] = Integer.MAX_VALUE;<br>        for (int i = middle + 1; i &lt;= end; i++) {<br>            temp[index++] = data[i];<br>        }<br>        temp[index] = Integer.MAX_VALUE;<br>        int i = 0;<br>        int j = middle - start + 2;<br>        int k = start;<br>        while (temp[i] != Integer.MAX_VALUE || temp[j] != Integer.MAX_VALUE) {<br>            if (temp[i] &lt; temp[j]) {<br>                data[k++] = temp[i++];<br>            } else {<br>                data[k++] = temp[j++];<br>            }<br>        }<br>        System.out.println(Arrays.toString(temp));<br>        System.out.println(&quot;start=&quot;+start+&quot; middle=&quot;+middle+&quot; end=&quot;+end);<br>        System.out.println(Arrays.toString(data));<br>        System.out.println();<br>    }</div> <span class="time">2018-12-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/f5/36/54ac6e4b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">henghhh</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">没找到没想到merge函数中带哨兵的方法，但想到了以下这种方法来减少使用循环<br><br>while (i &lt;= q || j &lt;= r) {<br>    &#47;&#47; &lt;= 决定这是个稳定的排序<br>    if (j &gt; r || (i &lt;= q &amp;&amp; nums[i] &lt;= nums[j])) {<br>        temp[inx ++] = nums[i ++];<br>    } else {<br>        temp[inx ++] = nums[j ++];<br>    }<br>}</div> <span class="time">2018-12-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/2b/1b/e88e33ba.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Chang</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">写一个最小堆，把10个文件接口的第一个文件（最小文件）放进堆。把堆的文件依次pop出来，每pop出一个，就把该文件所在的接口的下一个文件放进堆。这样可以把内存控制在10*size(文件). 不太能用归并排序，因为不管怎么分治，感觉最后一次归并都必须把所有文件都放进内存。归并排序空间复杂度是O(n)</div> <span class="time">2018-12-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/4e/21/700586eb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">王鸿运</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">快排优化主要几种思路:<br>1.pivot的选择，才用随机法或者中位取值法（从随机概率分布来说，可以尽量避免极端情况）<br>2.防止递归太深，可以在深度达到一定时，对子集采用堆排<br>3.当子集小于一定次数时，基本有序了，采用插入排序<br>4.对和pivot相同的元素进行聚集，来减少子集大小<br><br>求数组第k的数，可以用来解决topk问题，时间复杂度会比采用小顶堆方式要稍微好一点</div> <span class="time">2018-12-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ee/e3/65c9b259.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">heting</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">10个文件， 首先从每个文件读取100M放入内存，总共1G。<br>将这100个100M文件进行排序，由于每个100M数据都是已经排序的，因此排序时不需要使用快排方案，只要使用类似快排的partition函数，即找到待排序100M数据中最大的元素作为pivot，扫描一遍即可。使用这种方案将内存中的1G数据排序完成后，我们能够推断最小的100M数据一定是当前未排序的数据中最小的一部分数据，将这部分数据从内存写入到文件。再从任意文件再次读取100M加入排序。<br>以上方案不知可行，请老师指教。</div> <span class="time">2018-12-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/14/a1/107910b4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">OnClickListener</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">贴一下我自己的代码(写代码一定要细心)<br>   public static void mergeSort(int[] arr,int[] tmp){<br>       mergeSort(arr,0,arr.length-1,tmp);<br>   }<br><br>   public static void mergeSort(int[]arr,int p,int r,int[] tmp){<br>       if(p&gt;=r)return;<br><br>       int q = (p+r)&#47;2;<br>       mergeSort(arr,p,q,tmp);<br>       mergeSort(arr,q+1,r,tmp);<br>       merge(arr,p,q,r,tmp);<br>   }<br><br>   public static void merge(int[] arr,int p,int q,int r,int[] tmp){<br>       int i=p;<br>       int j=q+1;<br>       int k=0;<br>       while (i&lt;=q &amp;&amp; j&lt;=r){<br>           if(arr[i]&lt;=arr[j]){<br>               tmp[k++]=arr[i++];<br>           }else {<br>               tmp[k++]=arr[j++];<br>           }<br>       }<br><br>       int start = i;<br>       int end = q;<br>       if(j&lt;=r){<br>           start = j;<br>           end = r;<br>       }<br><br>       while (start&lt;=end){<br>           tmp[k++] = arr[start++];<br>       }<br><br>       for (int m=0;m&lt;=r-p;m++){<br>           arr[m+p]=tmp[m];<br>       }<br>   }</div> <span class="time">2018-12-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">落叶飞逝的恋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">哈哈，刚看到这章的下一章，忽然发现这章的思考题。其实这个解决方案就是使用桶排序，是最优解决方案。根据时间戳的范围进行划分到不同的桶里。然后每个桶使用本章介绍的快速排序，这样时间复杂度就为近乎O(n)，空间复杂度为O(1)。</div> <span class="time">2018-12-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">落叶飞逝的恋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，我是按照数组头元素作为参考指标，实现了快速排序，麻烦老师看下。  <br>public static void sort(int[] arr) {<br>        int length = arr.length;<br>        _sort(arr, 0, length - 1);<br>    }<br><br>    &#47;**<br>     * 获取比较分区元素的索引位置<br>     *<br>     * @param arr<br>     * @param l<br>     * @param r<br>     * @return 返回分区索引，使得arr[l,par]&lt;referVal，arr[par+1,r]&gt;referVal<br>     *&#47;<br>    private static int partition(int[] arr, int l, int r) {<br>        int referVal = arr[l];<br>        int par = l;<br>        for (int i = l + 1; i &lt;= r; i++) {<br>            if (arr[i] &lt; referVal) {<br>                par++;<br>                int temp = arr[par];<br>                arr[par] = arr[i];<br>                arr[i] = temp;<br>            }<br>        }<br>        &#47;&#47;这边的是将之前referVal的值交换到正确位置<br>        int tmp = arr[par];<br>        arr[par] = arr[l];<br>        arr[l] = tmp;<br>        return par;<br>    }<br><br>    &#47;**<br>     * 递归处理数组排序<br>     *<br>     * @param arr<br>     * @param l<br>     * @param r<br>     *&#47;<br>    private static void _sort(int[] arr, int l, int r) {<br>        &#47;&#47;递归结束条件<br>        if (l &gt;= r) {<br>            return;<br>        }<br>        int par = partition(arr, l, r);<br>        &#47;&#47;排序左边的部分<br>        _sort(arr, l, par);<br>        &#47;&#47;排序右边的部分<br>        _sort(arr, par + 1, r);<br>    }</div> <span class="time">2018-12-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/9b/c8/d6e6730e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">周曙光爱学习</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师你写的golang版本的快排partition方法有bug，如果arr［low］=arr［high］就会进入死循环了</div> <span class="time">2018-12-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">golang不是我写的 是其他同学写的</p> <p class="reply-time">2018-12-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/e5/50/29af37cf.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Fff</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">快排的分区函数看不懂的，可以下本算法导论的pdf，里面有整个分区流程的详细图文描述</div> <span class="time">2018-12-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">个人觉得 算法导论上的也并不会更好懂😄</p> <p class="reply-time">2018-12-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/18/e9/4242ee4a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Martin </span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师你好，我在阅读快速排序小节时，使用 java版本的partition() 分区函数打印结果的时候发现和图上画的顺序有出入,是分区函数写错了吗？我把代码贴在下面：<br>@Test<br>    public void testPartition()<br>    {<br>        int[] data = {8,10,2,3,6,1,5};<br>        QuickSort.partition(data, 0, data.length-1); &#47;&#47; 获取分区点<br>        printAll(data);<br>    }<br><br>IDE打印结果：2 3 1 5 6 8 10<br><br>虽然对分区函数的分区职责没有什么影响，但是感觉顺序的理解上有问题，请指正。<br><br><br><br></div> <span class="time">2018-11-30</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">java的partition函数的代码你看了吗 建议自己读一下</p> <p class="reply-time">2018-12-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">马哲富</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">哎~一行字一行字看吧，太费劲了！</div> <span class="time">2018-11-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/24/a5/d1d28c4d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Pitt‮口一你了亲‭</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">&quot;通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n&#47;2^k)+kn。当T(n&#47;2^k)=T(1) 时，也就是 n&#47;2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。归并排序的时间复杂度是 O(nlogn)。&quot;<br><br>老师,这里k值代入之后,T(n)=Cn+nlog2n. 我代入之后是T(n)=2*T(n&#47;2)+nlog2n. 为什么这里的Cn可以直接忽略  我有点懵<br><br><br><br><br><br><br></div> <span class="time">2018-11-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/dd/eb/80f9d212.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">lttzzlll</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">第6行的代码是否可以在swap之间做个判断：<br><br>if i != j or A[i] != A[j]: swap A[i], A[j]</div> <span class="time">2018-11-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">落叶飞逝的恋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师这章将的归并排序的代码跟配图有所不同，一些地方不甚理解的好生辛苦。然后琢磨的出了下面的自己理解写了下面的代码，终究了解了深意！<br>public class Merge {<br>    public static void sort(int[] arr) {<br>        &#47;&#47;临时数组<br>        int[] tmp = new int[arr.length];<br>        &#47;&#47;开始排序<br>        sort(arr, tmp, 0, arr.length - 1);<br>    }<br><br>    &#47;**<br>     * 使用分治方式进行排序<br>     *<br>     * @param arr   原始数组<br>     * @param tmp   临时数组<br>     * @param start 指定排序的开始位置<br>     * @param end   指定排序的结束位置<br>     *&#47;<br>    private static void sort(int[] arr, int[] tmp, int start, int end) {<br>        &#47;&#47;递归结束条件，就是数组索引从头到尾遍历完毕。<br>        if (start &gt;= end) {<br>            return;<br>        }<br>        &#47;&#47;分治思想递归实现<br>        &#47;&#47;递归公式：merge(start...end)=merge(start...mid),merge(mid+1...end)<br>        int mid = (start + end) &#47; 2;<br>        sort(arr, tmp, start, mid);<br>        sort(arr, tmp, mid + 1, end);<br>        &#47;&#47;开始合并分治后的结果<br>        merge(arr, tmp, start, mid, end);<br>    }<br><br>    &#47;**<br>     * 开始合并分治后的结果<br>     *<br>     * @param arr   原始数组<br>     * @param tem   临时数组<br>     * @param start 开始排序的元素位置<br>     * @param mid   元素中间位置<br>     * @param end   指定排序的结束位置<br>     *&#47;<br>    private static void merge(int[] arr, int[] tem, int start, int mid, int end) {<br>        &#47;&#47;k用来进行标记临时数组的下标<br>        &#47;&#47;进行拷贝原来的数据<br>        for (int k = start; k &lt;= end; k++) {<br>            tem[k] = arr[k];<br>        }<br><br>        &#47;&#47;将数据拷贝会原来的数组<br>        int x = start;<br>        int y = mid + 1;<br>        for (int k = start; k &lt;= end; k++) {<br>            &#47;&#47;判断分出的第一个数组是否越界<br>            if (x &gt; mid) {<br>                arr[k] = tem[y];<br>                y++;<br>            }<br>            &#47;&#47;判断分出的第二个数组是否越界<br>            else if (y &gt; end) {<br>                arr[k] = tem[x++];<br>                x++;<br>            }<br>            &#47;&#47;真正开始比较两个元素大小<br>            else if (tem[y] &lt; tem[x]) {<br>                arr[k] = tem[y];<br>                y++;<br>            } else {<br>                arr[k] = tem[x];<br>                x++;<br>            }<br>        }<br>    }<br>}<br></div> <span class="time">2018-11-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Geek_987169</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题解决思路：<br>1：一次加载两个300M文件到内存首先快排，待2个300M有序后，归并排，最终将归并排的600M结果写到一个新文件，重复这个过程，最终生成5个已排序600M文件<br>2：取2个文件，分别读取300M内容到内存，进行归并排序，将排序结果写到一个新文件，一旦某个文件的内存300M耗尽，则继续读取剩下的，重复这个过程，最终生成一个1200M的已排序新文件<br>3：重复2，将剩下的3个600M文件选择2个文件生成一个1200M已排序文件，最终3个已排序文件大小分别为1200M,1200M,600M<br>4：重复2，最终合并为一个已排序文件，大小3000M<br></div> <span class="time">2018-11-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">落叶飞逝的恋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师有个问题：就是关于排序里面的，public void sort(int[] a,int n){...}。你在备注里面说a表示为数组，n表示数组的大小。我觉得n应该是数组元素的个数更为妥当。比如，数组是这样定义的int[] a=new int[10]; a[0]=3;a[1]=5,a[2]=4。就定义三个元素，那么我觉得循环10次不合理，应该循环当前元素的个数。请老师解惑。</div> <span class="time">2018-11-28</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">这里数据多少就开多大数组</p> <p class="reply-time">2018-11-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/38/217ecccb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">大坏蛋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，看完内容后，对开篇问题时间复杂度为O（n）有点疑问：每次分区查找时间复杂度为O(n) ,分区次数k，2^k = n，k=logn；所以求解问题的时间复杂度不应该也是O(nlogn) 吗？求老师和同学解答。</div> <span class="time">2018-11-27</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">每次分区查找的时间复杂度并不是O(n)，因为每次都折半查找。</p> <p class="reply-time">2018-11-27</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/b2/61/3156ba36.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">丁丁</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">分别取十个文件的最大时间戳和最小时间戳(由于文件有序，读开头一行和最后一行即可)，保留每个时间戳对应在的每个文件位置。对二十个时间戳排序，然后从小往大读文件即可。时间复杂度O(1)，空间使用每次均小于300M，应该是最快的办法。</div> <span class="time">2018-11-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿官(^･ｪ･^)</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">求解文中哨兵的解题思路</div> <span class="time">2018-11-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/2b/45/7a87fe2f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Smile</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，快速排序的过程是不是有点问题，如果是[6,3,8]的话，i和j都是一直增加，最终导致q永远都是2，然后进行死循环，我的解决方案是，如果<br>&#47;&#47;当前面的元素都比最后一个元素小时，i向前移动一位<br>        if(i==r){<br>            i=i-1;<br>        }<br>        return i; 这样可以实现，但是不知道理解的对不对？？？</div> <span class="time">2018-11-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">allean</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O（n），空间复杂度是O（1）,几乎不占用内存，这是我想出的认为最好的操作了，希望老师指出最佳的做法！！！<br>2018-10-28<br> 作者回复<br>你回答的不错 思路是正确的<br>------------------<br>来自归并排序的启发</div> <span class="time">2018-11-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">allean</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">昨天说老师代码跑完数据乱序是我愚昧自己写错了，抱歉哈。</div> <span class="time">2018-11-22</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">😂 没事</p> <p class="reply-time">2018-11-22</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">allean</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">归并排序的代码跑了一下，为什么是乱序的？😭，难道是我的姿势不对？</div> <span class="time">2018-11-20</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">把数据给我 我来跑下</p> <p class="reply-time">2018-11-21</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">allean</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我把老师得代码跑了一下，为什么是乱序的？😭</div> <span class="time">2018-11-20</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">哪个代码啊</p> <p class="reply-time">2018-11-22</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/87/dd/4f53f95d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">进阶的码农</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">归并排序 空间复杂度不能是O（1）吗 我看网上有实现的</div> <span class="time">2018-11-20</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">可以是 比较复杂</p> <p class="reply-time">2018-11-21</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">asnail</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">PHP 的快排<br>function q_sort(&amp;$data, $q, $r)<br>{<br>    if ($q &gt;= $r) {<br>        return;<br>    }<br>    $p = q_sort_c($data, $q, $r);<br>    q_sort($data, $q, $p - 1);<br>    q_sort($data, $p + 1, $r);<br>}<br>function q_sort_c(&amp;$data, $q, $r)<br>{<br>    $i = $q;<br>    for ($j = $q; $j &lt; $r; $j++) {<br>        if ($data[$j] &lt; $data[$r]) {<br>            $temp = $data[$j];<br>            $data[$j] = $data[$i];<br>            $data[$i] = $temp;<br>            $i++;<br>        }<br>    }<br>    $temp = $data[$i];<br>    $data[$i] = $data[$r];<br>    $data[$r] = $temp;<br>    return $i;<br>}</div> <span class="time">2018-11-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Laughing_Lz</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看到深夜两点，课后题的回答基本分为两种，例如王先统和李建辉的两种回答。我实在不太理解，还请老师解惑。我的直观想法也是既然十个文件各自都排好序了，我每次单独从中取出各自最小的一条记录相比较，得出十中之一的最小记录，写入新的文件里，然后再补充一条记录，如此往复，最终新的文件中不就是排好序的了吗？可是看了王先统等人的那种分为30，40M不等的更小的数组，并新建300，400M的数组来存储临时有序的文件，感觉需要多次比较才能合并成完整的文件。第一次评论，我的计算机知识太差，我实在想不通为什么他们这么考虑？和1G内存究竟有什么关系？还请老师解惑！</div> <span class="time">2018-11-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/f4/7e/15520e73.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">赵传真</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">java 归并：<br>public void simpleSort(int[] param) {<br>        split(param, 0, param.length - 1);<br>    }<br><br>    private void split(int[] param, int p, int r) {<br>        if (p &gt;= r) {<br>            return;<br>        }<br><br>        int q = (p + r) &#47; 2;<br>        split(param, p, q);<br>        split(param, q + 1, r);<br>        merge(param, p, q, r);<br>    }<br><br>    private void merge(int[] param, int p, int q, int r) {<br>        int i = p;<br>        int j = q + 1;<br>        int k = 0;<br>        int[] tmp = new int[r - p + 1];<br><br>        while (i &lt;= q &amp;&amp; j &lt;= r) {<br>            if (param[i] &lt; param[j]) {<br>                tmp[k++] = param[i++];<br>            } else {<br>                tmp[k++] = param[j++];<br>            }<br>        }<br><br>        while (i &lt;= q) {<br>            tmp[k++] = param[i++];<br>        }<br><br>        while (j &lt;= r) {<br>            tmp[k++] = param[j++];<br>        }<br><br>        for (int x = 0; x &lt; tmp.length; x++) {<br>            param[x + p] = tmp[x];<br>        }<br>    }<br>========================================<br>java 快排：<br>public void simpleSort(int[] param) {<br>        if (param.length &lt;= 1) {<br>            return;<br>        }<br><br>        quickSort(param, 0, param.length - 1);<br>    }<br><br>    private void quickSort(int[] param, int p, int r) {<br>        if (p &gt;= r) {<br>            return;<br>        }<br><br>        int q = partition(param, p, r);<br>        quickSort(param, p, q - 1);<br>        quickSort(param, q + 1, r);<br>    }<br><br>    private int partition(int[] param, int p, int r) {<br>        int value = param[p];<br>        int i = p;<br>        int j = r;<br><br>        while (i &lt; j) {<br>            while (i &lt; j &amp;&amp; param[j] &gt;= value) {<br>                j--;<br>            }<br><br>            while (i &lt; j &amp;&amp; param[i] &lt;= value) {<br>                i++;<br>            }<br><br>            if (i &lt; j) {<br>                int t = param[i];<br>                param[i] = param[j];<br>                param[j] = t;<br>            }<br>        }<br><br>        param[p] = param[i];<br>        param[i] = value;<br>        return i;<br>    }</div> <span class="time">2018-11-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/bf/10/b7974690.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">BD</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">有个地方没看懂，当p=0，q=1对应区间11 8的时候再往下分会直接return，一直return到执行下面排序的q=1+1,r=3此时再往下分也会直接return，返回到p=0,q=1，和q=1+1,r=3的情况这时候就执行merge方法。可这时候p=0，q=1不还没有排序了吗？</div> <span class="time">2018-11-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d3/fd/41eb3ecc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">奔跑的徐胖子</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我感觉应该每次读取每个文件99兆的数据，这样总共占用990兆内存，然后每个文件对应的第一条为一个序列，第二条为一个序列……，对每个序列进行快速排序，排序完成，两两进行归并，预留的10兆，就是归并所需的额外空间，然后所有归并完成写入文件，进行下一次，直到所有文件排序完毕，不知道我说的对不对😁</div> <span class="time">2018-11-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">👽</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">新建一个存放最小值的文件夹，然后开始从十个文件夹里面分别取最小值，然后比较。<br>将最小值放入新移动到文件夹，然后继续取他们的最小值。将全文件移动完毕的时候，就合并完成了。</div> <span class="time">2018-11-13</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/2e/3c/e70cbed8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">姚文锐</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">首先用快排思想，选一个时间点（pivot）将每个300M的文件分成两个，以此类推，直到每个区间的10个文件大小满足内存要求时，用归并排序思想，合并每个区间内的10文件，最后在合并各个区间。</div> <span class="time">2018-11-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">无名</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">三数取中法可以通过比较完成；如果是多数取中法怎么弄，只想到了先排序再取中了，这样死循环了，有没有别的方法呀</div> <span class="time">2018-11-08</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">哈哈 要比较的数据不会很多 插入或者选择排序就好了</p> <p class="reply-time">2018-11-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/d9/c6/a295275b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">o</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">也就是顺序写，跳读</div> <span class="time">2018-11-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">renderfan001</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">在O(n)时间内查找第K大元素，如果对于一个已序序列应用快排的划分算法，最坏的情况也有可能接近O(n2)，比如 序列n从小到大排列，n远大于10，并且每次划分的哨兵都是最后一个元素，要找第10大元素，情况不乐观。<br><br>不过思路很巧妙，很烧脑</div> <span class="time">2018-11-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/d9/c6/a295275b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">o</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1、提前将硬盘（就是硬盘）数据连续区域开辟出来做好记录；<br>2、按照最大时间和最小时间进行时间切片排序，可以对不同时间片区间的数据同时排序。然后根据该时间片区间的容量大小放到指定硬盘区间<br>3、对于某个时间区间的数据如何排序，目前只想到了插入排序</div> <span class="time">2018-11-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">dorinegorz</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">想问老师哪里能看到课程目录，这样可以自己规划一下进度</div> <span class="time">2018-11-06</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">专栏介绍了有的 你找找</p> <p class="reply-time">2018-11-06</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/29/41/a413ca91.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">冒泡雪碧 🏈</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">【课后思考】看了大家的想法，我页说说我脑子里第一个想法：既然每个文件一开始就是按时间戳凯旭好了的，那么我们已经就知道所有文件的最小时间戳和做大时间戳。知道了时间戳的范围，那我们就合理的分成n份时间段（每小时,每分钟,或者每小时。按实际的情况而定），然后按顺序分析每个时间段：从每个文件获取该时间段的数据，合并排序，存入结果文件，然后分析下个时间段。</div> <span class="time">2018-11-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/eb/dc/ae5485bb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">PoetAndPoem</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如何通过快排选择第K大（小）元素。<br>我的解决方案：通过快排的partition方法的思想，每次返回的pivot的位置即为该元素已排序成功的位置。那么，当partition返回的值为k-1（或arr.len-(k-1)）时，即求出实际解。</div> <span class="time">2018-11-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/2d/11/0ecbe9ea.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">烈冬冰夏</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，topN的算法，如果pivot选择不好，是不是也有可能退化到n2？</div> <span class="time">2018-11-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">是的呢</p> <p class="reply-time">2018-11-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/55/e1/8c223e95.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">qwerboo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">赞的最多的那个是怎么想的😏</div> <span class="time">2018-11-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f9/ab/374fe105.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Alan</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我觉得文中的快排分区函数确实巧妙，但是不太好理解，我曾经写快排代码用的是另一种方法：<br>1、取第一个或最后一个数为标志数<br>2、在除标志数以外的数据中，游标i从左边开始向中间遍历，游标j从右边开始向中间遍历<br>3、若游标i所在的位置值大于标志数，j所在的值小于标志数（假设从小到大排），那就交换两个数<br>4、直到i和j相遇（i&gt;=j）时，再与标志数交换</div> <span class="time">2018-11-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/5c/96/2fe46b27.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">井中月</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">课后作业，我的理解就是有序序列的合并，思想就是归并中的merge。但由于这里是10个文件，所以比较的次数就是关键，我们可以建一个双向链表，先读10个文件中的第一条数据放入链表，然后对链表进行时间戳排序，head为最小时间戳。取链表head中元素存放到新日志文件，读取head对应文件下一条日志，head移到下一个元素，新取出日志比较插入到链表中，依次知道读完所有文件，然后把链表全部写入即可。内存的限制主要增加了磁盘读写的io时间，所以这里可以建10条io流对应10个日志文件，每次取90m出来，直到比较完再取下一次；建一个100m的内存空间放排序好的日志，满就写磁盘，最后全部写入即可。</div> <span class="time">2018-11-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/ba/f5/a028f728.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">geek_banana</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我觉得在快速排序里面，分区条件改为value &lt;= pivot, 从前向后遍历元素，是可以保证相同元素值位置不变的，求老师解释一下</div> <span class="time">2018-10-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/35/15/0b7de6b0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Veigar</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">原来以前自己对快排的理解都是错的。。</div> <span class="time">2018-10-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/2d/0f/2b81b98b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">waine_m</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师：归并排序和快速排序能不能也整理一下对比图表，这样比较直观，多谢	</div> <span class="time">2018-10-30</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">下节课有的</p> <p class="reply-time">2018-10-31</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Smallfly</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，今天回过来复习第 K 大的数，发现对第 K 大的理解有点模糊，第 K 大不是应该是有 K - 1 个数比目标数大么？为什么文中的思路是，有 K - 1 个比目标值小呢？</div> <span class="time">2018-10-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1c/46/a141c7e6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">子嘉</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如果这个数组是 有重复数据的话 那这个算法应该不正确吧？ 比如 1 1 2 2 3 3 4 4 5 5 找第三大</div> <span class="time">2018-10-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/5e/24/040855d3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Wilson</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师这节的练习题没有正确答案吗？<br>请老师解答下</div> <span class="time">2018-10-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/62/2f/6fe8ee9e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李靖峰</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">打开全部文件，从头开始各取80m数据，组成一800m的数组，用快排的逻辑排到某个数据用尽时，将内存中此行之前的数据落盘，再从当前偏移量各个文件中取数据填满80m，重新组成800m数组，如果某个文件已读尽，则从其他文件平均补足，各取floor(80&#47;0.9)=88m。直到全部文件读尽。直到最后一次不足800m数组的快排落盘</div> <span class="time">2018-10-28</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">qinggeouye</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">归并排序：把一个待排序数组A，最终分解成不能再分的各个子数组 A1、A2、A3、...、Ak，然后再按原路将各个子数组合并(每次合并的过程中排序)；<br>快速排序：选择数组中A的一个元素作为基准点pivot，每次将数组划分为两个区间（一个区间的元素全都小于pivot，另一个区间的元素全都大于pivot），按此原则继续划分子区间，直到区间不能再划分为止，排序完毕。</div> <span class="time">2018-10-28</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0d/ac/09678490.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">谢特</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">归并最后拷贝数组为什么是p+i,直接A[i]=tmp[i]不就行了吗？</div> <span class="time">2018-10-28</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">要拷贝到下标p到r之间啊</p> <p class="reply-time">2018-10-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/91/e83a4b5e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">我能走多远</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">partition函数中，最好加个判断i和j不相等时才swap A[i] with A[j]</div> <span class="time">2018-10-28</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">嗯 更好点 👍</p> <p class="reply-time">2018-10-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d9/68/38703855.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">seamoontime</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">请问一下，为什么您的代码中喜欢用p,q,r做下标，这是什么单词缩写，还是约定俗成的标志。。。</div> <span class="time">2018-10-28</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">随便起的 没啥原因</p> <p class="reply-time">2018-10-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/e2/26/144af4e1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">RogerIs谭纶</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">请问下文档中的类似手写的图是什么工具生成的？</div> <span class="time">2018-10-28</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">paper</p> <p class="reply-time">2018-10-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/04/43/835418b5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">木羊人007</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">个人觉得可以采用merge() 函数里面的做法，将文件两两比较。例如有A、B、C、D、E、F、G、H、I、J十个文件，将文件两两组合形成A-B、C-D、E-F、G-H、I-J五组，每一组比较后生成一个临时文件tmpFile1、tmpFile2、tmpFile3...，重复上述步骤直到形成一个文件。两个文件中时间戳的比较方式是，每次读取文件中的一行时间戳，小的写入到临时文件中（或者缓存起来批量写出），然后读下一行和大的时间戳比较（如合并A-B文件时，首先A、B文件各读一行，如果TimeA&lt;TimeB则将TimeA写入tmpFile，继续从A文件读取一行与TimeB比较），依次类推，直到其中一个文件被完全读取，将另一个文件中的剩余数据全部写入到tmpFile。</div> <span class="time">2018-10-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">kakasi</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">归并排序分析：<br>1. 原理：对半递归拆分数组，将每个拆分后的数组一一合并，合并时进行排序。<br>2. 执行效率：最好、最坏和平均都是O（nlogn）。这里有个计算递归时间复杂度的一个技巧：T(n) = T(n&#47;2) + T(n&#47;2) + n, 继续分解后 T(n) = 2^k*(T(n&#47;2^k)) + k*n, k = logn其他可以忽略不计。<br>3. 内存消耗：因为在合并结果时需要临时开辟数组，所以是O(n)， 不能和时间复杂度混为一谈，临时数组内存空间是会在函数结束后被回收的，因此取最大的即可。<br>5. 稳定。<br><br>快排分析：<br>1. 原理：取一个基数，一般是最后一位，然后遍历前面的数，比其小的数在左边，否则在右边，最后将基数放到分区位，递归排序左右两部分。<br>2. 执行效率：最好O（nlogn），最坏O（n^2），平均是O（nlogn）。最坏的情况是取最后一位为基数而这个列表已经排序好了。<br>3. 内存消耗：原地排序O（1），这也是为什么快排比归并更受欢迎<br>5. 不稳定。<br><br>这两种排序是大规模的数据排序常用的。</div> <span class="time">2018-10-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/14/09/083584a6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">琴晓</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不容易呀，想了几天了，必须留个言！<br>快速排序：<br>def quick_sort(data, p, r):<br>    if p &gt;= r:<br>        return data[p: r]<br>    pivot = data[r]<br>    i = p<br>    j = r<br>    while i &lt; r and j &gt; p:<br>        a = -1<br>        b = 0<br>        if data[i] &gt;= pivot:<br>            a = i<br>        else:<br>            i += 1<br>        if data[j] &lt; pivot:<br>            b = j<br>        else:<br>            j -= 1<br>        if a &gt;= 0 and b:<br>            data[a], data[b] = data[b], data[a]<br>        if i &gt; j:<br>            break<br>    data[j+1], data[r] = data[r], data[j+1]<br>    quick_sort(data, p, j)<br>    quick_sort(data, j+1, r)<br><br><br>m = [9, 5, 8, 2, 1, 3, 10, 54, 82, 24]<br>quick_sort(m, 0, 9)<br>print(m)</div> <span class="time">2018-10-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/85/63/e22af145.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">饶飞</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于快排的空间复杂度，wiki上说需要计算递归调用过程中占用的固定数量的空间，所以快速排序的空间复杂度最优为O(logn)，最差为O(n)。</div> <span class="time">2018-10-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/11/11/52a78856.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">D→_→M</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师我想问一下在快速排序中的partition函数里面“a[j] &lt; pivot”换成“a[j] &lt;= pivot”，会有什么影响？会影响到稳定性吗？</div> <span class="time">2018-10-24</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">没有影响的 不影响稳定性</p> <p class="reply-time">2018-10-24</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/04/a3/947c3cfe.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">俞永斌</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">merge函数中申请数组大小不是应该是<br>int[] tmp =new array[r-p+1] 吗？<br>归并排序<br>&#47;&#47; 取 p 到 r 之间的中间位置 q <br>q =(p+r) &#47; 2 我觉得写成 q= r+(p-r)&#47;2会好点，避免溢出<br></div> <span class="time">2018-10-24</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/53/e9/f244988e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Nirvana</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">在做模拟股票收益排行的时候，用到了归并排序算法，根据前面讲到的将递归代码用普通的循环来实现，发现在有100万条数据的情况下排序的时间会快一点，但是想知道在用循环的这一段代码中，<br>    public static void sortNew(int [] sort){<br>        System.out.println(&quot;开始排序&quot;);<br>        long start = System.currentTimeMillis();<br>        int left, mid, right,len;<br>        len  = sort.length;<br>        for(int i = 1 ;i &lt; len; i *= 2) {<br>            left = 0;&#47;&#47; 从数组第一个元素开始<br>            while (left + i &lt; len) {<br>                mid = left + i - 1;<br>                right = mid + i &lt; len ? mid + i : len - 1;<br>                merger(sort, left, mid, right);<br>                left = right + 1;               &#47;&#47;下标后移<br>            }<br>        }<br>        long end = System.currentTimeMillis();<br>        System.out.println(&quot;排序耗时: &quot;+ (end - start));<br>    }<br>我想知道在for循环中以多大倍数的跨度来进行执行效率会比较高，老师。</div> <span class="time">2018-10-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/08/c7/6b0cb046.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小花小黑的铲屎官</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">哦，明白了</div> <span class="time">2018-10-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/04/41/082e2706.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">任旭东</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题思路:<br>每个文件先读90M数据，从10个文件的最小值中选出最小值放到缓存数组中(数组大小为90M)，反复重复选取最小值得过程。<br>在此过程中<br>1.任何一个文件读出来的数据被处理完，就再读取90M出来，直到读取完。<br>2.当缓存数组为放满时就将数据写入合并文件，并清空数组。<br>直到所有数据处理完，缓存数组都写入到合并文件。</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">macro</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于课后思考,可以先每个文件取40m,加载入内存,然后逐个比较每个数组的最小值(10个数组中当前比较的10个数的最小的),写入文件,位置加1,如果加载到内存的文件用完,继续加载对应的文件的数据,如此循环,知道数据比较完毕竟,全部写入文件</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">不似旧日</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">今天的课程有点难<br></div> <span class="time">2018-10-22</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">加油 💪多看几遍</p> <p class="reply-time">2018-10-23</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/30/1c/e160955d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">sky</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">之前一直想学quick select然后看了几篇博客没看懂,就在这里看到啦，开心</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/dd/1c/6ce66b48.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Ricky</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">python实现快排<br><br>def quickSort(array):<br><br>    if len(array) &lt; 2:<br>        return array  # -----------基线条件<br>    else:<br>        pivot = array[0]  # -----------递归条件<br>        less = [i for i in array[1:] if i &lt;= pivot]<br>        greater = [i for i in array[1:] if i &gt; pivot]<br><br>    return quickSort(less) + [pivot] + quickSort(greater)</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e5/0d/a8b0eb81.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">安龙</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">由于这10个已经是有序的，所以只需要merge的动作吧</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/58/9f/abb7bfe3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小龙的城堡</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">您好，关于课后习题我想是不是可以这样解决。因为只有1G内存。1、将10个文件分成4份，（300*3）一份，最后一个是300M单独一份。对前三份可以全部载入内存排序，所以使用快速排序，因为是原地排序，所以不需要额外的空间，排序完成可以全部刷入文件系统；第一步的结果是四个排序好的文件，900M三个，300M一个。2、因为四个文件不能完成两两全部载入内存，所以使用归并排序，因为归并排序需要使用额外的存储，所以将1G的内存分成三份 300M，300M，400M（假设1G=1000M），300M用于存储要排序的数据，400M用于放结果；输入是两个900M的文件要归并，每次分别从两个文件中从小到大读入300M的文件填入内存，形成400M的归并结果停止，然后刷入文件；然后再从外部文件读入400M的数据，直到完成计算；3、第二步做完后结果是1800M的文件1个，1200M的文件1个，再使用第二步的方法将这两个文件归并成3000M的结果文件。<br><br>不知道这样做是否可以，感谢回复～</div> <span class="time">2018-10-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ff/46/2ea2fe90.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿尔卑斯</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">王老师，我代表基础一般学员(我想大部分都是吧)，强烈要求文稿里附上完整的“算法代码实现”，而不要只是伪代码，不然，我们还得从网络上找完整代码实现，找到的也未必是你讲解的实现框架和版本…这样一来，我们学习效率和质量都会大打折扣，我想这也不是您开设这门课程的初衷吧！…在比，代表广大学员拜托王老师，接下来把讲解每种算法的完整代码实现在文稿中添加，谢谢！</div> <span class="time">2018-10-21</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">你得综合想想啊 贴代码对我来说没啥负担 但是文稿就很丑了 很长很长的代码。代码我基本上都放到github上了 你可以去那里看。再说你自己搜搜 写写 不是更有提高吗 伸手拿来直接看印象肯定不深的</p> <p class="reply-time">2018-10-22</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/ff/b3/a236be3c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">CrazyGoMan</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">课后思考题：逐一读取10个文件到数组中，数组进行快排，将排好序的数组写入到相应文件中。因为是逐一读取，这个文件读取完排好序后，才开始下一个文件的读取和排序，那么占用的内存大小始终是300M。这个操作的结果是10个文件内的数据都是各自有序的了。之后模仿归并排序合并数组的逻辑，创建一个几百M大小的临时数组，设置10个指针分别指向10个文件的第一条数据，边读取比较大小，小的就放入到临时数组中且相应指针加1，临时数组满时就将其内容刷新到一个大小为3G的文件中，重复这个过程，最后这个3G的文件就是10个文件合并的排好序的文件。</div> <span class="time">2018-10-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/84/3b/ba1b626e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Summer</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，归并排序实现merge的时候，是把两个有序数组合并成一个有序数组。我觉得可以不需要开辟额外数组的呀。比如，merge(Arr(p,r),Arr(r+1,q)，把Arr(r)和Arr(q)中大的一个放Arr(q)的位置，再依次向前比较就行了。</div> <span class="time">2018-10-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/07/0b/a33982a5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Cest la vie</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">partition(A, p, r) {<br>  pivot := A[r]<br>  i := p<br>  for j := p to r-1 do {<br>    if A[j] &lt; pivot {<br>      swap A[i] with A[j]<br>      i := i+1<br>    }<br>  }<br>  swap A[i] with A[r]<br>  return i<br><br>当数组中存在多个重复时，你的partition 是不是陷入死循环了？如A=[2,5,4,2]，partition 一直返回是0</div> <span class="time">2018-10-20</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">看着不会啊</p> <p class="reply-time">2018-10-23</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8d/83/8b6972c0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">老姚</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">文章中针对 一个已为升序的队列 时间为 O(n^2) ,加条如下判断进行识别<br>q = partition(A, p, r) &#47;&#47; 获取分区...<br>if (q==r) return ； &#47;&#47; 如果q=r  说明是一个有序的，不用再进行排序。</div> <span class="time">2018-10-20</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">好像不行</p> <p class="reply-time">2018-10-23</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/38/217ecccb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">大坏蛋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">re:<br>walor<br>课后思考<br>1.申请 10 个数组，每个数组 30M。再申请个临时数组，大小 300M。<br>2.每个文件每次读取 30M 数据分别存入 30M 的数组中。<br>3.比较 10 个数组的最大时间戳，获取它们中的最小值<br>4.合并排序 10 个数组。排序完成后，取出数组前 30M 存入磁盘（硬盘上的最终日志文件），后 270M 存入文件<br>5.循环至 300M 文件读取结束，生成 10 个新的 270M 文件<br>6.重复步骤 1。<br>7.终止条件：生成的新文件大小 0M。<br>=================================================<br>同意walor思想，但是第一次合并排序后，数组前30M存入磁盘，后270M存入文件；此时产生11个270M文件；新产生文件也要参与合并排序；以此类推，直至没有新文件生成。为了减少文件IO，每次读取数组大小可以进行优化。</div> <span class="time">2018-10-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Rain</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">--<br>老师，有个问题没懂，在一个数组中找第k大的数这个问题中，为什么如果p+1=k，a[p]就是要查找的结果呢？<br>--<br><br>我理解是：<br>P是支点的index，每一轮快排之后都能确定这个P的index，而且这个index就是他在最终排序后的数组中的位置。<br><br>对于老师的那个例子来说，要解的问题是找出数组中的第3大元素，那么他肯定是在最终排序后的数组中的index=2的那个元素。在例子中一轮快排之后，选定的支点元素 8 被交换到了index=2的位置，所以8就要找的第 K=3 大元素，而他的index=2，故证明：如果p+1=k，a[p]就是要查找的结果 。</div> <span class="time">2018-10-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/7d/f8/1ee5514d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">来风</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">leetcode上的215. Kth Largest Element in an Array，可以作为练习</div> <span class="time">2018-10-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">纯洁的憎恶</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">快速排序与归并排序都是分治策略，不同之处在于，快速排序是先确定分区之间的有序性再向下递归，归并排序则是递进到最低层后向上归并的时候才能确定分区之间的有序性。于是可以看出，快速排序是自顶向下的分治，归并排序是自底向上的分治。</div> <span class="time">2018-10-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">shawn</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">课后题，先说一个内存消耗为常数的个人想法，开十个文件流，读取十个文件的第一行，找到时间戳最小的一行，假设是第X个文件，先把这一行输出，然后读入X文件的第二行，再在十个值中找找最小，假设是Y文件，最小的一行输出，然后读入Y文件下一行，以此类推，直到所有文件都读完结束<br><br>所以1G的内存是完全够用的，考虑磁盘性能一次性读取大的块比较高效，所以每个文件先读入80M，压入十个输入队列，然后保留一个200M的结果队列，出队第一个，比较，写入结果队列，然后出队第二个，结果队列满了就写到文件，输入队列空了就再加载80M，直到做完。<br><br>不知道思路有没有问题，请老师指点</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">来碗绿豆汤</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题: 各个文件是有序的，就相当于归并排序切成的小块已经由于，下面就是merge了。每个文件读一行数据，时间最小的写入合并后文件(可缓存)，然后从对应文件中再读一行，一直到所有文件都读完为止。</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">勤劳的小胖子-libo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">使用桶排序的方式,先查看一下这十个日志的日期范围，至少先分成六大份，比如对应1对6月，从小到大，对应六个文件，把相关的时间日志放入到相应的文件中，如果正好平均分布，每一份再保存十个小文件，每个保存属于特定月份的来源于上面300M的日志文件，平均而言是每个50^_^M，二二归并，使每个文件有序，十个小文件一共500M，归并中需要额外500M中保持数组，所以设置每个50M，然后把这六个大文件依次读入写入到目标文件。<br><br>当然，日志不一定正好平均分布，如果某个大份里面数据过多，比如2月份数据量过多，可以再细分成上中下旬，然后从十个日志文件中对应的部分写入文件，在归并。反正只做最小结点来归并。<br><br>因为二二小文件本身都有序的，可以直接归并，时间复杂度N*k，k为分了几层。如果分层较少，接近O(n)。</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/5d/8f/16e1da5d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">程</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，打扰下，求归并排序的时间复杂度时：“得到 k=log2n 。我们将 k 值代入上面的公式，得到T(n)=Cn+nlog2n。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)”<br>这里的“上面的公式”是指哪个吖，数学渣渣没找到，谢谢解答了</div> <span class="time">2018-10-19</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">就是上面推导的最后一步</p> <p class="reply-time">2018-10-20</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ff/16/b0ab9a73.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">luffy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">以前学数据结构，就是到这部分放弃了，只是了解思想，写不出代码。</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">竹林清风</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">快排不是稳定的排序，这是它的一个缺陷，这个难道影响不大吗？我们应该更热衷稳定排序吧</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">竹林清风</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这个留言要是我们可以评论就好，真的好想评论下别人的留言</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d8/0d/bc1957cf.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Vinegar.</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">伪代码看的好累啊，还是 JAVA 代码和 c 代码看的比较直观</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">微秒</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n&#47;2 个元素。<br>不是很理解为什么每次分区我们平均要扫描大约 n&#47;2 个元素，而不是n-1个元素？？？<br></div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/db/3b/e56ff0a9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Pan^yu</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">课后问题有个坑要留意，如果10个日志的时间戳大小个不一样，用固定大小去拆分，可能出现排完序中最大时间戳不是为排序的最小时间戳。我认为，先遍历10个文件第一行时间戳，以固定大小去截取时间戳最小的文件，获取截取内容的最大时间戳，然后用这个最大时间戳去截取后面的9个文件，在进行排序，以此递推下去</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e8/a0/c2daafdb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">A_阿海</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回答一下p＋1 等于 K，那么A［p］就是那个要求解的问题。 题目说的是第K大，注意，这个第K大是从1开始数的，而在数组中，是有第0个元素的，所以，刚好差1。</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Linuxer</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题应该可以部分读入加多路归并</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Monday</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">      用Java实现查找无序数组的第K大元素（未判断边界，如k&gt;a.length，k&lt;1等等），有错的话，欢迎指错，有借鉴作用，欢迎带走！ <br>      public static int findRankKElement(int [] a, int k) {<br>		&#47;&#47;第k大的数据，转换为数组下标需要减1<br>		int value = findRankKElement(a, 0, a.length - 1, k - 1);<br>		return value;<br>	}<br>	private static int findRankKElement(int[] a, int p, int r, int k) {<br>		int result;<br>		int pivot = partitionK(a, p, r);<br>		if(k == pivot) { &#47;&#47;等于即返回<br>			result = a[pivot];<br>		}else if(k &lt; pivot){&#47;&#47;小于则在小区间查询<br>			result= findRankKElement(a, p, pivot - 1, k);<br>		}else {&#47;&#47;大于则在大区间查询<br>			result = findRankKElement(a, pivot + 1, r, k);<br>		}<br>		return result;<br>	}<br>   partition()方法代码见本节文章</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f0/ee/ff6ec4f6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">youngshi</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">快排加归并？<br>总共3G文件数量10个，内存1G<br>1g&#47;10=100m,临时空间100m&#47;2=50m<br><br>每次每个文件读50M即每个文件分成6个50m等份的区间，每个区间取开始和结束的日志时间放到长度为6的数组中<br><br>那就有60个区间，求交集，有交集的才需要排，那么有些无交集，有些多个区间交集分别计算排序，写到临时数组区间，然后将各个排序好的区间(区间又有顺序)写到文件<br><br><br>排序的过程就是交集的区间用归并的方式合并<br><br>瞎想的，这个题目拿来写代码很有意思，明天写写<br></div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">zixuan</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题描述是不是合适，比如这个接口是不是可以流式读取，还是只能一下全部导入内存中。否则直接10路归并不行吗，每次每个接口读一个元素到内存也行啊</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/e5/c9/fa9199d0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">张小小的席大da</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">github上传可不可以传真实的代码 自己实现过 想对比参照下</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1d/f5/ff8d82e4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mib Du</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对啊老师，那个伪代码反而看起来满费劲的，希望老师能直接用代码实现。</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/8b/e0/9a79ddac.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">🐱您的好友William🐱</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">最后一题肯定不是分批归并最后合到一起啊，有可能10个文件分别属于不同月份的呢。。。我的初步想法是按时间戳找，反正是有序的，10个并行按一个时间戳找，直到某个时间戳之前的十个文件总数据填满了1G，就快排之后就存起来。那么10个文件中所有剩余的数据就都是这个时间戳之后的了，就不会出现总文件时间乱序的现象了。。。。肯定不是最优解，还得再好好想想。</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我发现还是有很多细节问题，比如是奇数个，就不能均分，会出现小数。另外如果下边从零开始。0和1相加，均值是0.5。这样，递归下去是。0和0.5，1.5和1。但实际没有0.5和1.5的坐标。</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">为什么不是＝？大于的情况有可能出现吗？应该没有可能吧。</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/09/33/57757a23.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小苏饼</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这种TopN的问题是要用快排还是堆比较好？我看这种问题网上大多是用堆 </div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">T(n) = 2*T(n&#47;2) + n； n&gt;1，为什么这里是加n，不是O(n)吗？</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">传说中的成大大</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这篇文章我花了两天才读完，了解了 归并和快排的思想，但是时间复杂度仍然是让我头疼的一块<br>至于思考题 <br>我觉得情况分两种<br>1. 时间戳:01234 56789这类型的文件<br>    针对这类型的日志文件只需要进行选择排序每次最小的文件依次写入最终日志文件<br>2. 时间戳为:13579 2468十类型 有穿插大小的时间戳排序文件<br>     我们可以10通道从10个文件中读取固定的大小的日志内容只要不超过1G，进行排序写入最终日志文件，然后读到所有文件都读完为止，这样的原因就是因为本身文件已经有序，所以敢保证 先进去的内容一定小于或大于后面写进去的内容<br></div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">终止条件为什么是p&gt;=r.</div> <span class="time">2018-10-18</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">这样有错吗</p> <p class="reply-time">2018-10-18</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d6/bc/026ac6b1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">windliang</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师问一下，递归的空间复杂度需要考虑递归中堆栈所用的空间吗？</div> <span class="time">2018-10-18</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">需要的</p> <p class="reply-time">2018-10-18</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/54/ce/ed58c82d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">为你而来</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">又学到一个小技巧:快排分区操作类似选择排序，目的就是选择出比分区点小的元素放在一边。<br>之前一直比较迷糊，没有很好的理解。谢谢老师，专栏很棒😁</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/1e/96/3162d51f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">等风来</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">快排partition函数按搬移数据实现的话,可实现稳定排序且时间复杂度和空间复杂度保持不变;<br>归并排序Merge函数通过将数组的后半部分插入到前半部分可实现原地排序,时间复杂度会增加.<br>当然这两种实现方式显然都不是最佳实践.<br>思考题:<br>1.从10个文件中每次取50M进行排序,合并成6个500M的文件;均分成3组;<br>2.组中取每个文件前250M合并成一个文件A,后250M合并成B;<br>3.将A的前250M写入一个单独文件C;<br>4.A剩下250M和B的500M的前250M合并D,将D的前250M追加到C中;<br>5.将B剩下250M和D剩下的250合并写入C中,以此合并成3个1000M的有序文件E,F,G;<br>6.将E,F分别取250M合并,并将前250M写入H中,后250M写入I;<br>7.分别从E,F取250M合并写入J;<br>8.将J前250M和I合并后,取前250M追加到H,剩下回写I;<br>9.合并I,J写入I;<br>10.以此类推,得到2000M的H和1000M的G;<br>11.用类似的方式合并H,G即可.</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/07/41/2d477385.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">柠檬C</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这个伪代码像pascal风格啊</div> <span class="time">2018-10-17</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">能看懂就行了</p> <p class="reply-time">2018-10-17</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/25/0b/f9fc5255.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">DADDYHINS</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">把文件分小组，每组1g，在内存中进行归并排序，排序完了写进目标文件，以此类推</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/be/d2/3d88cb8e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">NeverMore</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">充分利用1G的内存空间。分三次，将300M的文件分成3份，每份100M，10个文件一共1G，内存内对这1G文件进行归并排序。然后将排序好的1G文件写入到磁盘。这样最终会有3份1G的文件落到磁盘上，然后通过读取每份文件的时间戳，对这3份文件进行排序并直接写入到磁盘内（外排）。 <br>比较依赖磁盘的I&#47;O性能。</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Smallfly</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd"># 并归排序 vs. 快速排序<br><br>并归排序跟数据有序度无关，时间复杂度稳定在 O(nlogn); 快速排序复杂度受有序度的影响，最坏情况复杂度是 O(n^2)，平均复杂度是 O(nlogn)。<br><br>并归排序的处理是由下到上的，所以需要额外的空间，将有序数组进行重组，空间复杂度为 O(n)。快速排序的处理过程是由上而下的，分区的过程中排序，所以它是原地排序。<br><br>归并排序合并时可以保证相同元素保持原来的顺序，所以是稳定的排序；而快速排序是不稳定排序。<br></div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">cricket1981</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">分三批处理，每批读入每个文件100MB，10个文件是1G，在内存中归并排序后写入目标文件，完了再下一批处理</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">徐凯</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题是不是通过将文件放在外存 多路归并排序</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li></ul></div></div></div></div><div id="translate-man-app" class="content-3WfBL_0" style="background-color: rgb(255, 255, 255); display: none;"><div data-v-ea0bd11e="" class="outputBox-qe9A4_0"><div data-v-ea0bd11e="" class="outputBox-3oESn_0"><span data-v-ea0bd11e="" class="outputBox-13Ovx_0"></span></div><div data-v-ea0bd11e="" class="outputBox-1GLb__0"><div data-v-ea0bd11e="" class="outputBox-onVZH_0"><img src="chrome-extension://fapgabkkfcaejckbfmfcdgnfefbmlion/static/sound.svg"            class="icon-tprjJ_0"></div></div><div data-v-ea0bd11e="" class="outputBox-2sJgr_0"></div><div data-v-ea0bd11e="" class="outputBox-17RAm_0" style="display: none;"><div data-v-ea0bd11e=""></div></div></div></div><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({        showProcessingMessages: false,        messageStyle: "none",        tex2jax: {          inlineMath: [['$','$'], ['\\(','\\)']],          displayMath: [ ["$$","$$"] ],          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a']        }      });      MathJax.Hub.Register.MessageHook("End Process", function (message) {        var eve = new Event('mathjaxfini')        window.dispatchEvent(eve)      })</script></body></html>