<html class="cye-disabled cye-lm"><head><meta charset="utf-8"><link rel="apple-touch-icon" sizes="180x180" href="http://static001.geekbang.org/static/icon/time/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="http://static001.geekbang.org/static/icon/time/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="http://static001.geekbang.org/static/icon/time/favicon-16x16.png"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover"><meta name="format-detection" content="telephone=no"><title>06 | 链表（上）：如何实现LRU缓存淘汰算法?</title><link href="https://static001.geekbang.org/static/time/css/app.b230db929e53af87acd535637f5011b8.css" rel="stylesheet"><style id="nightModeStyle">    html.cye-enabled.cye-nm:not(*:-webkit-full-screen) body,html.cye-enabled.cye-nm:not(*:-webkit-full-screen) #cye-workaround-body {-webkit-filter:contrast(91%) brightness(84%) invert(1);}</style><style id="cyebody">html.cye-enabled.cye-lm body{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyediv">html.cye-enabled.cye-lm div{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyetable">html.cye-enabled.cye-lm th{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}html.cye-enabled.cye-lm td{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyetextInput">html.cye-enabled.cye-lm input[type=text]{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}html.cye-enabled.cye-lm textarea{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyeselect">html.cye-enabled.cye-lm select{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyeul">html.cye-enabled.cye-lm ul{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style id="cyeChangeByClick">html.cye-enabled.cye-lm .cye-lm-tag,html.cye-enabled.cye-lm.cye-lm-tag{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}</style><style type="text/css">    .hljs-ln {      border-collapse: collapse    }    .hljs-ln td {      padding: 0    }    .hljs-ln-n:before {      content: attr(data-line-number)    }</style><style type="text/css">    #iv-container {      position: fixed;      background: #0d0d0d;      width: 100%;      height: 100%;      top: 0;      left: 0;      display: none;      z-index: 1000    }    .iv-container {      overflow: hidden    }    .iv-close {      width: 26px;      height: 26px;      position: absolute;      right: 20px;      top: 20px;      cursor: pointer;      text-align: center;      overflow: hidden;      text-shadow: 0 0 3px #6d6d6d;      -webkit-transition: all .2s ease;      -moz-transition: all ease .2s;      -o-transition: all ease .2s;      transition: all .2s ease    }    .iv-close:after,    .iv-close:before {      content: "";      height: 2px;      width: 26px;      background: #fff;      position: absolute;      left: 0;      top: 50%;      margin-top: -2px;      border-radius: 2px    }    .iv-close:before {      -webkit-transform: rotate(45deg);      -moz-transform: rotate(45deg);      -ms-transform: rotate(45deg);      -o-transform: rotate(45deg);      transform: rotate(45deg)    }    .iv-close:after {      -webkit-transform: rotate(-45deg);      -moz-transform: rotate(-45deg);      -ms-transform: rotate(-45deg);      -o-transform: rotate(-45deg);      transform: rotate(-45deg)    }    .iv-close:hover {      -webkit-transform: rotate(90deg);      -moz-transform: rotate(90deg);      -ms-transform: rotate(90deg);      -o-transform: rotate(90deg);      transform: rotate(90deg)    }    .iv-image-view {      position: absolute;      height: 100%;      width: 100%    }    .iv-image-wrap {      display: inline-block    }    .iv-image-wrap:active {      cursor: move    }    .iv-large-image {      cursor: move;      max-width: 100%;      max-height: 100%;      background-color: #ececec;      -moz-transform: translateZ(0);      -o-transform: translateZ(0)    }    .iv-large-image,    .iv-loader {      position: absolute;      -webkit-transform: translateZ(0);      -ms-transform: translateZ(0);      transform: translateZ(0)    }    .iv-loader {      top: 50%;      left: 50%;      border-radius: 50%;      width: 32px;      height: 32px;      z-index: 100;      margin-top: -16px;      margin-left: -16px;      font-size: 5px;      text-indent: -9999em;      border-top: 1em solid hsla(0, 0%, 100%, .2);      border-right: 1em solid hsla(0, 0%, 100%, .2);      border-bottom: 1em solid hsla(0, 0%, 100%, .2);      border-left: 1em solid #fff;      -webkit-animation: load8 1.1s infinite linear;      animation: load8 1.1s infinite linear    }    .iv-loader:after {      width: 10em;      height: 10em;      border-radius: 50%    }    @-webkit-keyframes load8 {      0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg)      }      to {        -webkit-transform: rotate(1turn);        transform: rotate(1turn)      }    }    @keyframes load8 {      0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg)      }      to {        -webkit-transform: rotate(1turn);        transform: rotate(1turn)      }    }</style><style type="text/css">    .vue-pull-to-wrapper[data-v-12abd9fb] {      display: -webkit-box;      display: -webkit-flex;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -webkit-flex-direction: column;      flex-direction: column;      height: 100%    }    .scroll-container[data-v-12abd9fb] {      -webkit-box-flex: 1;      -webkit-flex: 1;      flex: 1;      overflow-y: auto;      -webkit-overflow-scrolling: touch    }    .vue-pull-to-wrapper .action-block[data-v-12abd9fb] {      position: relative;      width: 100%    }    .default-text[data-v-12abd9fb] {      height: 100%;      line-height: 50px;      text-align: center    }</style><style type="text/css">    .button-cancel[data-v-87ffcada] {      color: #888;      border: 1px solid #888;      border-radius: 3px;      margin-right: 12px    }    .button-cancel[data-v-87ffcada],    .button-primary[data-v-87ffcada] {      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      height: 35px;      display: inline-block;      font-size: 15px;      text-align: center;      line-height: 36px    }    .button-primary[data-v-87ffcada] {      color: #fff;      background-color: #ff5a05;      border-radius: 3px    }    .article[data-v-87ffcada] {      max-width: 46.25rem;      margin: 0 auto    }    .article .article-unavailable[data-v-87ffcada] {      color: #fff;      text-align: center;      font-size: .875rem;      font-weight: 400;      width: 100%;      -webkit-box-sizing: border-box;      box-sizing: border-box;      padding: 0 15%;      height: 4.9rem;      background-image: url(data:image/jpeg;base64,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);      background-position: 0 0;      background-repeat: no-repeat;      background-size: cover;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: center;      -ms-flex-pack: center;      justify-content: center    }    .article .main[data-v-87ffcada] {      padding: 1.25rem 1.375rem;      margin-top: 52px;      margin-bottom: 52px    }    .article-title[data-v-87ffcada] {      color: #353535;      font-weight: 400;      line-height: 1.65rem;      font-size: 1.34375rem    }    .article-info[data-v-87ffcada] {      color: #888;      font-size: .9375rem;      margin-top: 1.0625rem    }    .article-content[data-v-87ffcada] {      margin-top: 1.0625rem    }    .article-content.android video[data-v-87ffcada]::-webkit-media-controls-fullscreen-button {      display: none    }    .audio-player[data-v-87ffcada] {      width: 100%;      margin: 20px 0    }    .to-comment[data-v-87ffcada] {      overflow: hidden;      margin-bottom: -30px    }    .to-comment a.button-primary[data-v-87ffcada] {      float: right;      height: 20px;      font-size: 12px;      line-height: 20px;      padding: 4px 8px;      cursor: pointer    }    .article-comments[data-v-87ffcada] {      margin-top: 2rem    }    .article-comments h2[data-v-87ffcada] {      text-align: center;      color: #888;      position: relative;      z-index: 1;      margin-bottom: 1rem    }    .article-comments h2[data-v-87ffcada]:before {      border-top: 1px dotted #888;      content: "";      position: absolute;      top: 56%;      left: 0;      width: 100%;      z-index: -1    }    .article-comments h2 span[data-v-87ffcada] {      font-size: 15.25px;      font-weight: 400;      padding: 0 1rem;      background: #fff;      display: inline-block    }    .article-sub-bottom[data-v-87ffcada] {      z-index: 10;      cursor: pointer    }    @media (max-width:769px) {      .article .breadcrumb[data-v-87ffcada] {        padding: 10px 0      }    }</style><style type="text/css">    .share-poster-wrapper {      position: fixed;      background-color: #fff;      left: 0;      bottom: 0;      z-index: 100;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      overflow: hidden;      width: 100%;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -moz-user-select: -moz-none;      -webkit-user-select: none;      -ms-user-select: none;      user-select: none    }    .share-poster-wrapper .poster-bottom,    .share-poster-wrapper .poster-middle,    .share-poster-wrapper .poster-top {      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .poster-middle {      padding: 16px 32px;      -webkit-box-sizing: border-box;      box-sizing: border-box    }    .share-poster-wrapper .poster-middle .poster-userinfo {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      padding-bottom: 18px    }    .share-poster-wrapper .poster-middle .poster-userinfo .poster-avatar {      min-width: 45px;      min-height: 45px;      width: 7vw;      height: 7vw;      border-radius: 50%;      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .poster-middle .nickname {      font-size: 5vw;      font-weight: 400;      margin-left: 18px    }    .share-poster-wrapper .poster-middle .time {      font-size: 3.2vw    }    .share-poster-wrapper .poster-middle .poster-middle-content {      font-size: 4vw;      font-weight: 400;      white-space: normal;      word-wrap: break-word;      word-break: break-word;      letter-spacing: 1px    }    .share-poster-wrapper .poster-middle .poster-middle-content p {      margin-bottom: 22px    }    .share-poster-wrapper .poster-middle .quote-content {      font-size: 3.7vw;      padding: 32px 0    }    .share-poster-wrapper .poster-middle .quote-content p {      margin-bottom: 22px    }    .share-poster-wrapper .poster-middle .quote-info {      border-left: 1px solid #000;      padding-left: 10px;      margin-top: 38px    }    .share-poster-wrapper .poster-middle .quote-info p {      font-size: 3.2vw;      line-height: 1.5    }    .share-poster-wrapper.theme0 .poster-top {      width: 100%;      height: 25px;      margin-top: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/top.png") no-repeat 15px 1px    }    .share-poster-wrapper.theme0 .poster-middle {      width: 100%;      padding-left: 56px;      padding-right: 56px;      background-image: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/middle.png");      background-repeat: repeat-y;      background-position: 15px 0    }    .share-poster-wrapper.theme0 .poster-middle .time {      margin-bottom: 45px    }    .share-poster-wrapper.theme0 .poster-middle .quote-content {      border-top: 1px solid #e3e1dc;      margin-top: 30px    }    .share-poster-wrapper.theme0 .poster-bottom {      width: 100%;      height: 25px;      margin-bottom: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme1/bottom.png") no-repeat 15px -10px    }    .share-poster-wrapper.theme1 .poster-top {      width: 100%;      height: 25px;      margin-top: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/top.png") no-repeat 38px 1px    }    .share-poster-wrapper.theme1 .poster-middle {      width: 100%;      padding: 0 42px 10px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/middle.png") repeat-y 38px 0    }    .share-poster-wrapper.theme1 .poster-middle .poster-userinfo {      border-bottom: 1px solid #b5a899    }    .share-poster-wrapper.theme1 .poster-middle .poster-userinfo .poster-avatar {      margin-left: 38px    }    .share-poster-wrapper.theme1 .poster-middle .poster-middle-wrapper {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      min-height: 260px;      border-bottom: 1px solid #b5a899    }    .share-poster-wrapper.theme1 .poster-middle .time {      max-width: 65px;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -webkit-box-pack: center;      -ms-flex-pack: center;      justify-content: center;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      text-align: center;      vertical-align: middle;      border-right: 1px solid #b5a899    }    .share-poster-wrapper.theme1 .poster-middle .time span {      white-space: nowrap;      -webkit-transform: rotate(90deg);      transform: rotate(90deg)    }    .share-poster-wrapper.theme1 .poster-middle .poster-middle-content {      padding: 30px    }    .share-poster-wrapper.theme1 .poster-middle .quote-content {      font-size: 3.7vw;      margin-left: 36px;      margin-right: 36px    }    .share-poster-wrapper.theme1 .poster-middle .quote-info {      margin-left: 36px;      margin-right: 36px    }    .share-poster-wrapper.theme1 .poster-middle .footer {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      margin-right: 30px    }    .share-poster-wrapper.theme1 .poster-bottom {      width: 100%;      height: 25px;      margin-bottom: 27px;      background: url("https://static001.geekbang.org/static/time/page/img/sharePoster/theme0/bottom.png") no-repeat 38px -10px    }    .share-poster-wrapper .share-poster {      background: #fefdf8;      -webkit-box-sizing: border-box;      box-sizing: border-box;      color: #9b8d73;      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      overflow: auto;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      -webkit-overflow-scrolling: touch;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center    }    .share-poster-wrapper .share-poster.color0 {      background-color: #fefdf8    }    .share-poster-wrapper .share-poster.color1 {      background-color: #4d4d4d    }    .share-poster-wrapper .share-poster .footer {      margin-top: 2rem;      position: relative;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-pack: end;      -ms-flex-pack: end;      justify-content: flex-end;      -webkit-box-align: end;      -ms-flex-align: end;      align-items: flex-end    }    .share-poster-wrapper .share-poster .footer p {      margin: 0;      line-height: 1.4;      margin-left: 20px;      text-align: right;      padding-right: 20px    }    .share-poster-wrapper .controls {      background: #fff;      border-top: 1px solid #f5f5f5;      width: 100%;      padding-top: 5px;      -webkit-box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, .1);      box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, .1);      z-index: 1;      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .controls>div {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-pack: center;      -ms-flex-pack: center;      justify-content: center;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      padding: 10px 0    }    .share-poster-wrapper .controls>div span {      font-size: .85rem    }    .share-poster-wrapper .controls>div button {      width: 100px;      height: 24px;      background: #eee;      margin: 0 10px;      border-radius: 5px;      border: 2px solid #b2b2b2;      outline: none    }    .share-poster-wrapper .controls>div button.on {      border: 2px solid #ff5a05    }    .share-poster-wrapper .controls .controls-themes button {      color: #b2b2b2;      font-size: 12px;      background: #fff;      text-align: center    }    .share-poster-wrapper .controls .controls-themes button.on {      color: #ff5a05    }    .share-poster-wrapper .buttons {      background: #fff;      border-top: 1px solid #f5f5f5;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -ms-flex-negative: 0;      flex-shrink: 0    }    .share-poster-wrapper .buttons a {      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      text-align: center;      color: #000;      font-weight: 400;      height: 3rem;      line-height: 3rem    }    .share-poster-wrapper .buttons a:last-child {      border-left: 1px solid #f5f5f5    }    .share-poster-wrapper img {      max-width: 100%    }    .share-poster-wrapper.android .poster-middle .nickname {      font-size: 10vw    }    .share-poster-wrapper.android .poster-middle .time {      font-size: 6.4vw    }    .share-poster-wrapper.android .poster-middle .poster-middle-content {      font-size: 8vw    }    .share-poster-wrapper.android .poster-middle .quote-content {      font-size: 7.4vw    }    .share-poster-wrapper.android .poster-middle .quote-info p {      font-size: 6.4vw    }</style><style type="text/css">    .mobile-tips {      width: 100%;      height: 51px;      background: rgba(0, 0, 0, .8);      position: fixed;      top: 0;      left: 0;      z-index: 20;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: justify;      -ms-flex-pack: justify;      justify-content: space-between;      -webkit-box-sizing: border-box;      box-sizing: border-box;      padding: 0 12px;      -webkit-transition: opacity .35s;      transition: opacity .35s;      opacity: 0;      pointer-events: none    }    .mobile-tips.istop {      opacity: 1;      pointer-events: auto    }    .mobile-tips .mobile-tips-info {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: start;      -ms-flex-pack: start;      justify-content: flex-start    }    .mobile-tips .mobile-tips-info i {      width: 36px;      height: 36px;      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEQAAABECAYAAAA4E5OyAAAL30lEQVR4Ae2bBXTbStOG/VGZmVJM6lCZmZnplJmZmZkZ/o+Z4TIzM2O5aW+bimWZY8H7jxTnNvax2xQcnnOerHhm351R1rJsO3/+fG2i7uXLlxsGAoE9ABQUETMM42NFUfqZ/Q/qUMtmrqSnpyfquv4Giqb5yRaTDvVMUWxXrlxpRGK8i6JtAa/XO94Uxaaq6mEUm2nczZs3k2wAXLCs2Cg5jttQbNlvsrfDBCk2W96MhA7d54Qm34R662uoNz6z0Jjz0J0sDL/LPKhwC6J7HMi48g7crx6B8qcJkA6kQNzTGNJuk4ZBGkHa0wTSwVQ4/zkH3nd/aQlmBHyFRxCVRt3z1GY49iVB3l0f8kE7lJPtoPyyF5Rf9QnSN5Nf9oXTanvDcaoD5EOJdE4DKEdaw/vWOcoepuAKogppcP1pOqTtcZD3xUM51x3K//WhtncmZ7PoFXk5iMM6pycc+5vSterC/dwu6F5HwRHE0FR4XjgCeUt9KHsT4DxDnTxt0jNID4vgcoRtwfXw4+g6Fvsoa7Y3RMbXz+Z/QTSXSCXRBdK6KlBOdIVyqhe13e9Cj/vfR9d0nuwGeWN1uP+1DIau5k9BAuwViGvqQt6RAMfJ3pCPdoPjoegedbt17RO9IO9KhONQNxgZ3vwlSEb6hUwxdtop4B6QD3cN0iWM0G2OO9vD6BKhDT2OzrV8SXtSIe9tTaJ48ocgqsxAWlELjm2UGUdoVA91zhkHTaJuJ3J4jcPkc1cKHPs7AYaet4LoaoAyIx7i5oaQKXXlA50gRaUjpP0drWPkg7S+pwXE9XEQV9WAsKoWhJXVIa2sCXFdHKTdzcxj6NjOEa9pbdufbdvBrpC22eH808K8FcTxx2UQVlTNDGhfR6JDWEtkrR/oTG178OvqUoc7wP3kHmR8/yY0Pg2ag4Em34aafh7+z56G8pfl4JfVhLCmNsS9bc1zw65tLYdCMYira8L/9Ut5I4jv4kfgZ5eAtJeC23N35P1dIK1vBOXIYAQuvgtDC9w7+9wOeN/+CwneANLaOLpG53v72dcJwtKqMHyu3BVENwxIWztQyjc0R5toH529HSEsqw7f6799wCm/AuXsVKujJP49/NG+zXZ4/rs1dwXxfPIcZUdpKwBxR9sotLNGTVhUDeq1z/Gw5n76JPhZpchnO/PaUf2aMfELK5GQjtwRxDAMiDt7QFhNqbytLdEmBDGr3UlizC0P9frXeFTmevwIhFmlrWuTj6iI6xLge/lc7gjiT78Mfk6FTOdbiK0mrX9sRbPdTiO4tBb8Hz2BR23yyekQF1YlH+2zfGYjGA8NlLw+BdC12Aviev4cxFllIJtibG4dmY2pUE5OQCxM8/vAzakFeZ09un+KTZxfBeqNr2MriK5p4Dd0hLiiEaQNrSKzqQ2ldSVo4i3Eypyv/gXC1NLU+TYRYmhpteLaRLifPBBbQQIiA35mNQjrm0NY1yIya5KgnJiEWJrq94NbYoewKiF6HOtbwHFoeGwF8V36BPyUshDWNo9AC6vl5lSF75NnEEszCPk3KyHMqBA1DrMVlzeFkeGLnSDuj54GN6kUZQE5XN0MPBFsg8vNwU4sCZW/gVib+70nwE8oBX5Nlu9wmlM2V4UmM7ETxPnS78BOLQNuVTNwq7NIvdMS/KLG1qjE2ryXvwQ7uRL5TDb9R4ShDNK467ETRHnqBAlSjgRJjczKJIjr2ltT81ibn7kBblpN8pkYNR5mWnmo6RdjKMiTx8FPLgd+JWXCiuykZLbLswRRkVPTiYDbef+CsDfBTq1JPu2RYyHYqeURSPsqhiXz7C/BTSgNblky+BBSgiSBn98I+n08wZJe+Qe4YVXu+1mGJ+08mIlVyKedSI4IO6kcZcil2AnievNfYMf9AsLS5BB4q02y4Eb9HKqQszmIVxbAjCoJaUZjGOr9lZnrk1fAjSlp+eRD4shaJqZUgSalx04Q75dvgh31U3BLqOOLg4Qts2N+Ad8Xr+NephoGuPX9wJHA0qZu91VmBiH+fT/YkT8L+o8MP7chDL8ndoJkpF8FO7okuEV2IjEyM2rAcXYx7mXyU78F08dG5ZcIaU2n+xIkYADshn5gp1SKHsfiRBK6R2wnZprfC3ZqbXIYTw5DnN9ZX5IIdvjPoDklRDM3z+D2WOrMnLp0nv2+BVG++5RKrTSd2zToP5Iodrj+tDH2H+6kc8vATawAbmFiZBZR2UyoAMeZJVFKBWCWdgZL9c8tSaFzmkK8D0ECBLO6D7ixpiDJUeNgp9ZA4Nt3Yi+I96u3wQy2gTWdLrBHxhwhOsZ34bPw2ofw37NgBtisGmfn28HMj4e4umOOBDEI6aV/gxtE5y+kc7P8zQ/zT7HxMxvAUDNiL4ie4Qc3oTq4eY3BUSARWUCCzIqjwH+KgCwgy1xpF8EM/Bntq2cdYx07Lx7SqpwJolz+HuzQMuCn16LzSdDI/ml7U7j/vCX3HiEqf9sLfvjPIVBQ/Dw7+PlBaFkgeJOFyeAnVabyqmPde1QA7JKO4EaVgLAwhY7JOj4B0sq7C2IQzqsk5mgaiPHlwS9K+dGnkN0/YcbEjSljTtlzTxDV5QAz9GeZWUId4uZHgWqcHV8O3JL24I4uADuhCnXGHnrMvCYkSIeoghiE8u3HYIbQdaz7TnJ0fyYL4qEcnZ77X0Mo/zkGhmqZNVN3bkIm84LMzQZlCju1FtjRpcxUpv32kP3M3CYQV0QXRNMNpE9PBWv6WpRM54T6CPE9PxHMqFLQJSb3BdFVFey4GuCm1qaAqJNzEh4IZnYTCMvv/vlH/Ou+TPHnJYKdHX6+BS1TDNPi4HnseN59c5dx6wqYHjYKMp6g0Z+VQC1BbdTl8G0zG99TkIDPC2Z0FbBT69J54deMJ0xBmkLaMDTvv+x2v/I3MP1JlLmJFFjTsA5HIUQQypBl7e75X0Z+7LQ1s2XnJZnnhkLb+GkNzGl6/ngdwvmPg2D72qwaZufEmx0NtlnL2QUJbs88jmgMMQeCqH4/zW6rm/ej4PXiM9v5SeAmx0Hjf8hfL8y4/ncCXG8bmLnxYOYkEE0yoXsEa7V3YIkf981uRCXTLmfzkFf/DaYn+Zhvz/Rh/oeb0hi6mJ4/X6nymOVDorBT48yaDtY3MdNsw5iZ1VKGLM2ZIFogQFlSmzKiJtjpDei8ztAVIX+/dJdx/TzEGSnghpUAT6LwVOMcddxiZpBZ2ZjRGFIOBTHN+enrYFNKwP3LtQCMgvFapqHrcD/9S3CDK4IbUwHc7AQiKEw4M0mQZff32FGT2IL54q7mkuH+7zGIUxuBHfoLcFPrkTDZxcgURJxtv/8PYgVJkAyfF3r2jFED8H/9NpznlkGcmwJ+WGlwQ0uAG18N3JSakGZRyehazq8f/Fq14AgiceCOrYSbvR2xyjWZQ8b5D+F9/Z/w0H8njb2eYyHEWzehPPUHU+SCVTJe+kCW3t4G/tgCKN9+Ap/bjfsdUyP4uNAtyxA+fRPpR+ZBWj7QFKNg3kMC7A2wCTZw5txhcjzYXZMgvPh3OM5/DiebDo/XB59mwK9q8Psz4KV1t0OGkv4DpG8+Bvf8X3F76zgwU+xgaZbq3LaoEPwawiFAGFsHwogS4EaWBdfPBnZoWTAT4sDObgZmcWcwK/uANVnSFczsFmAmNQAzrLw1++WGlwI7siQ8v9lUeH4vo/k8cGwdDn7YL8CZD3RmNQY3tS74idXBjasEbkx5C95cnlAd/NQ64Gc2Aj8vERw9jPa/+IfC+Ysq13+OgutlAz8tDtwce+R5iclsO9gZDSHOaw017dvC/ROzjFuXoWweDI4+IXOTa5kTthDYyZQdk+rC+6+DgK4Xjd/cWcJc+wauP22BNC8VwuiKEKc1gGPbMPhe+gN0l1xoJmb3b7oOzcFD97nz4Uy12LRiQUKSVX/bRn8+QbFZ5nQ6J9ocDscwAP4iXyua9vj58+fjbeYfr9e7ytxWhEvls7S0tOakRWOb+YeId7vdcw3DEItgZjxx7dq1ZqRBE6KRKUiD4Er89evXWwUCgTMkDFvYdTBvoHTPmEz9TsgSg6j///oXgzKZqkEyAAAAAElFTkSuQmCC);      background-position: 0 0;      background-repeat: no-repeat;      background-size: contain;      border-radius: 7px    }    .mobile-tips .mobile-tips-info h2 {      font-size: 15px;      color: #fff;      font-weight: 400;      margin-left: 6px    }    .mobile-tips .mobile-tips-info h2 span {      font-size: 11px    }    .mobile-tips a {      width: 72px;      height: 31px;      text-align: center;      border: 1px solid #ff5a05;      border-radius: 3px;      font-size: 13px;      color: #ff5a05;      line-height: 31px    }</style><style type="text/css">    .mini-audio-player {      width: 100%;      height: 5.25rem;      border: 1px solid #d9d9d9;      background: #fafafa;      -webkit-box-sizing: border-box;      box-sizing: border-box;      padding: 1rem;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -webkit-box-pack: justify;      -ms-flex-pack: justify;      justify-content: space-between;      margin: 1rem 0    }    .mini-audio-player>a {      border: none;      -ms-flex-negative: 0;      flex-shrink: 0    }    .mini-audio-player .btn-play {      background-image: url(data:image/png;base64,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)    }    .mini-audio-player .btn-pause,    .mini-audio-player .btn-play {      width: 2.6875rem;      height: 2.6875rem;      background-repeat: no-repeat;      background-position: 0 0;      background-size: contain;      text-decoration: none    }    .mini-audio-player .btn-pause {      background-image: url(data:image/png;base64,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)    }    .mini-audio-player .audio-info {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1;      -webkit-box-orient: vertical;      -webkit-box-direction: normal;      -ms-flex-direction: column;      flex-direction: column;      margin-left: .6875rem;      min-width: 0    }    .mini-audio-player .audio-info h3 {      color: #353535;      font-size: 15.25px;      margin: 0;      white-space: nowrap;      overflow: hidden;      text-overflow: ellipsis    }    .mini-audio-player .audio-info p {      margin: 0;      margin-top: .125rem;      font-size: 11px;      line-height: 1rem    }    .mini-audio-player .audio-info p span {      color: #888    }    .mini-audio-player .btn-download {      width: 1.25rem;      height: 1.25rem;      position: relative;      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA+CAYAAACbQR1vAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+IEmuOgAAA4hJREFUaIHtm8lOFFEUhr9qCWGHGxcaY1joK2h0YRzAtYmsWbAGGidEXOACbAYRxfgAPoEPoInGxJgg86gsJTHMw86EhS7O7TDk3uqq6qo6HahvQ7pOce7//1U0feve9vr6+lAiD3QC/4AC8FZDRJXGoMB14PWB1yPANPA1bSG5tAc0XLEcu5y6CvQCOGU5pnI3agVQMWQBaAvQJgtAW4A2WQDaArTJAtAWoE0WgLYAbbIAtAVokwWgLUCbLABtAdpkAfjU6oC7wKV0pCTCRcRDnesEVwDNwC/gg/nZHbeyFOgGltj30Gw7yRZALfAOqDavPeA50BO7xOToQTR75nU14qn26Im2AM4DNZbjz4DeePQlSi+i9Sg1iLdD2AJYApYdzbuo7BBeIBptLCPeDmELYA9oBHYdjbqQpaxKowA8ddR2gXuIt0O43gRHgTu4Q+ikskIoIJps7AINwA9b0e/fYJAQ1FZWD9CP2/wOUI/DPJT+IDRqGrhCeGIEaNEPdDhqO8iVH/NrEOST4BgSwo6j3gEMBOgTNwP4m6+nhHkI/lG4VAiPgcGAveJg0IxpYxvROh6kUZi5wLhpvO2oPyKdEF6asWyEMg/hJ0PjyN+VXwhDIXuGYQh46KhtIeYnwjSMMhss3glbjvoDkglhyPS2Eck8RJ8OTyB3gl8IryL2tjGM2/wmYn4ySuNyngdMmIE3HfX7iHDPUQ+CZ3q0O+qbyIWIZB7KfyAyaQS4QmhH7oQoIZQyv0EZV75IHE+EJvG/E9oJfyd4yC6yvKO+gQQ/FaKnlbgeiU0hIWw46nnEUJAQiubbHPV1M1bZ5iHeZ4KlQmgD3uAfgofsGfQz34DsKYyFuLemTSMhfATOWOqtiMk/llrRfIuj9zpwG5gtX+Y+SezNK4bwCXsILdgDaAXOOnomYh6Seyw+gwhed9TPWY75mb9FAuYh2XWBWUS4K4QgrAE3gblYFFlIemFkDjEQJYQ1JMD5WBUdIY2VoXkkhLUQv7NqfidR85De0liYEFaRK7+QqCJDmmuDC0gIqz7nrJhzUjEP6S+O+oWwglz5xTQFaawOLwI3gO8Hjo2ZY6maB72vzPwErgEXkO8MuVaiEkcrgCK/lcfPNkhkAWgL0KYKmZiMIG9Ktn0Bx5G/wDcgXwW8R6avJ41G4HQOufInlas5ZO5+UpnJAU3AFyy7J44xe8BnoOk/JruwYo92bigAAAAASUVORK5CYII=);      background-repeat: no-repeat;      background-position: 0 0;      background-size: contain;      text-decoration: none;      padding-right: .25rem    }    .mini-audio-player .btn-download .icon-download-done {      width: .45rem;      height: .45rem;      position: absolute;      bottom: 0;      right: 0;      display: inline-block;      background-image: url(data:image/png;base64,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);      background-repeat: no-repeat;      background-position: 0 0;      background-size: contain    }</style><style type="text/css">    .MathJax_Display {      overflow: auto    }    .poster {      position: fixed;      left: -10000px;      top: -10000px;      overflow: hidden;      padding: 1rem;      background: #ececec    }    .richcontent-pre-copy {      font-size: 13px;      color: #888;      position: absolute;      right: 1em;      top: .2em;      cursor: pointer;      -webkit-user-select: none;      -moz-user-select: none;      -ms-user-select: none;      user-select: none    }    .richcontent-pre-copy .iconfont {      font-size: 12px;      margin-right: .2em    }</style><style type="text/css">    .comment-item {      list-style-position: inside;      width: 100%;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      margin-bottom: 1rem    }    .comment-item a {      border-bottom: none    }    .comment-item .avatar {      width: 2.625rem;      height: 2.625rem;      -ms-flex-negative: 0;      flex-shrink: 0;      border-radius: 50%    }    .comment-item .info {      margin-left: .5rem;      -webkit-box-flex: 1;      -ms-flex-positive: 1;      flex-grow: 1    }    .comment-item .info .hd {      width: 100%;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-pack: justify;      -ms-flex-pack: justify;      justify-content: space-between;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center    }    .comment-item .info .hd .username {      color: #888;      font-size: 15.25px;      font-weight: 400;      line-height: 1.2    }    .comment-item .info .hd .control {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center    }    .comment-item .info .hd .control .btn-share {      color: #888;      font-size: .75rem;      margin-right: 1rem    }    .comment-item .info .hd .control .btn-praise {      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      font-size: 15.25px;      text-decoration: none    }    .comment-item .info .hd .control .btn-praise i {      color: #888;      display: inline-block;      font-size: .75rem;      margin-right: .3rem;      margin-top: -.01rem    }    .comment-item .info .hd .control .btn-praise i.on,    .comment-item .info .hd .control .btn-praise span {      color: #ff5a05    }    .comment-item .info .bd {      color: #353535;      font-size: 15.25px;      font-weight: 400;      white-space: normal;      word-break: break-all;      line-height: 1.6    }    .comment-item .info .time {      color: #888;      font-size: 9px;      line-height: 1    }    .comment-item .info .reply .reply-hd {      font-size: 15.25px    }    .comment-item .info .reply .reply-hd span {      margin-left: -12px;      color: #888;      font-weight: 400    }    .comment-item .info .reply .reply-hd i {      color: #ff5a05;      font-size: 15.25px    }    .comment-item .info .reply .reply-content {      color: #353535;      font-size: 15.25px;      font-weight: 400;      white-space: normal;      word-break: break-all    }    .comment-item .info .reply .reply-time {      color: #888;      font-size: 9px    }</style><style type="text/css">    .breadcrumb {      padding: 30px 0;      display: -webkit-box;      display: -ms-flexbox;      display: flex;      -webkit-box-orient: horizontal;      -webkit-box-direction: normal;      -ms-flex-direction: row;      flex-direction: row;      -webkit-box-align: center;      -ms-flex-align: center;      align-items: center;      -ms-flex-wrap: wrap;      flex-wrap: wrap;      background: #fff    }    .breadcrumb a.title {      color: #e57c39;      font-size: 15px;      font-weight: 400    }    .breadcrumb span.title {      color: #888;      font-size: 15px;      font-weight: 400    }    .breadcrumb .split {      color: #ccc;      font-size: 10px;      margin-right: 5px    }</style></head><body style=""><div id="app"><div data-v-87ffcada="" class="article"><div data-v-87ffcada="" class="main main-app" style="margin-top: 0px;"><h1 data-v-87ffcada="" class="article-title">          06 | 链表（上）：如何实现LRU缓存淘汰算法?</h1><div data-v-87ffcada="" class="article-info"><span data-v-87ffcada="">2018-10-03</span><span data-v-87ffcada="">王争</span></div><div data-v-87ffcada="" class="article-content typo common-content"><img data-v-87ffcada="" src="https://static001.geekbang.org/resource/image/d0/ec/d05de7616d91d99c3afe11ebd66497ec.jpg"><div data-v-87ffcada="" class="mini-audio-player"><a href="javascript:;" class="btn-play"></a><div class="audio-info"><h3>06 | 链表（上）：如何实现LRU缓存淘汰算法?</h3><p><span>朗读人：秭明&nbsp;&nbsp;&nbsp;</span><span>00:17:06 | 8033</span></p></div><audio title="06 | 链表（上）：如何实现LRU缓存淘汰算法?" src="https://res001.geekbang.org/resource/audio/bc/3a/bc1cd295e7b4b17caf28f0bcc552b93a.mp3" controls="controls"></audio></div><div data-v-87ffcada="" id="article-content" class=""><div class="text">              <p>今天我们来聊聊“链表（Linked list）”这个数据结构。学习链表有什么用呢？为了回答这个问题，我们先来讨论一个经典的链表应用场景，那就是LRU缓存淘汰算法。</p><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。</p><p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）。</p><p>这些策略你不用死记，我打个比方你很容易就明白了。假如说，你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？对应一下，你的选择标准是不是和上面的三种策略神似呢？</p><p>好了，回到正题，我们今天的开篇问题就是：<strong><span class="orange">如何用链表来实现LRU缓存淘汰策略呢？</span></strong> 带着这个问题，我们开始今天的内容吧！</p><h2>五花八门的链表结构</h2><p>相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，我们常常将会放到一块儿来比较。所以我们先来看，这两者有什么区别。</p><!-- [[[read_end]]] --><p>我们先从<strong>底层的存储结构</strong>上来看一看。</p><p>为了直观地对比，我画了一张图。从图中我们看到，数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果我们申请一个100MB大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败。</p><p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果我们申请的是100MB大小的链表，根本不会有问题。</p><p><img src="https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg" alt=""></p><p>链表结构五花八门，今天我重点给你介绍三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。我们首先来看最简单、最常用的<strong>单链表</strong>。</p><p>我们刚刚讲到，链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“<strong>结点</strong>”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针next</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt=""></p><p>从我画的单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址NULL</strong>，表示这是链表上最后一个结点。</p><p>与数组一样，链表也支持数据的查找、插入和删除操作。</p><p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p><p>为了方便你理解，我画了一张图，从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)。</p><p><img src="https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg" alt=""></p><p>但是，有利就有弊。链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第k位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要O(n)的时间复杂度。</p><p>好了，单链表我们就简单介绍完了，接着来看另外两个复杂的升级版，<strong>循环链表</strong>和<strong>双向链表</strong>。</p><p><strong>循环链表是一种特殊的单链表</strong>。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。</p><p><img src="https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg" alt=""></p><p>和单链表相比，<strong>循环链表</strong>的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">约瑟夫问题</a>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><p>单链表和循环链表是不是都不难？接下来我们再来看一个稍微复杂的，在实际的软件开发中，也更加常用的链表结构：<strong>双向链表</strong>。</p><p>单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。</p><p><img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt=""></p><p>从我画的图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？</p><p>从结构上来看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><p>你可能会说，我刚讲到单链表的插入、删除操作的时间复杂度已经是O(1)了，双向链表还能再怎么高效呢？别着急，刚刚的分析比较偏理论，很多数据结构和算法书籍中都会这么讲，但是这种说法实际上是不准确的，或者说是有先决条件的。我再来带你分析一下链表的两个操作。</p><p>我们先来看<strong>删除操作</strong>。</p><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul>
<li>
<p>删除结点中“值等于某个给定值”的结点；</p>
</li>
<li>
<p>删除给定指针指向的结点。</p>
</li>
</ul><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。</p><p>尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为O(n)。</p><p>对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点q需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到p-&gt;next=q，说明p是q的前驱结点。</p><p>但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O(n)的时间复杂度，而双向链表只需要在O(1)的时间复杂度内就搞定了！</p><p>同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在O(1)时间复杂度搞定，而单向链表需要O(n)的时间复杂度。你可以参照我刚刚讲过的删除操作自己分析一下。</p><p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><p>现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉Java语言，你肯定用过LinkedHashMap这个容器。如果你深入研究LinkedHashMap的实现原理，就会发现其中就用到了双向链表这种数据结构。</p><p>实际上，这里有一个更加重要的知识点需要你掌握，那就是<strong>用空间换时间</strong>的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p><p>还是开篇缓存的例子。缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p><p>所以我总结一下，对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。你还能想到其他时间换空间或者空间换时间的例子吗？</p><p>了解了循环链表和双向链表，如果把这两种链表整合在一起就是一个新的版本：<strong>双向循环链表</strong>。我想不用我多讲，你应该知道双向循环链表长什么样子了吧？你可以自己试着在纸上画一画。</p><p><img src="https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg" alt=""></p><h2>链表VS数组性能大比拼</h2><p>通过前面内容的学习，你应该已经知道，数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p><p><img src="https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg" alt=""></p><p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><p>你可能会说，我们Java中的ArrayList容器，也可以支持动态扩容啊？我们上一节课讲过，当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。</p><p>我举一个稍微极端的例子。如果我们用ArrayList存储了了1GB大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，ArrayList会申请一个1.5GB大小的存储空间，并且把原来那1GB的数据拷贝到新申请的空间上。听起来是不是就很耗时？</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，就有可能会导致频繁的GC（Garbage Collection，垃圾回收）。</p><p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p><h2>解答开篇</h2><p>好了，关于链表的知识我们就讲完了。我们现在回过头来看下开篇留给你的思考题。如何基于链表实现LRU缓存淘汰算法？</p><p>我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><p>1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p><p>2.如果此数据没有在缓存链表中，又可以分为两种情况：</p><ul>
<li>
<p>如果此时缓存未满，则将此结点直接插入到链表的头部；</p>
</li>
<li>
<p>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</p>
</li>
</ul><p>这样我们就用链表实现了一个LRU缓存，是不是很简单？</p><p>现在我们来看下m缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为O(n)。</p><p>实际上，我们可以继续优化这个实现思路，比如引入<strong>散列表</strong>（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到O(1)。因为要涉及我们还没有讲到的数据结构，所以这个优化方案，我现在就不详细说了，等讲到散列表的时候，我会再拿出来讲。</p><p>除了基于链表的实现思路，实际上还可以用数组来实现LRU缓存淘汰策略。如何利用数组实现LRU缓存淘汰策略呢？我把这个问题留给你思考。</p><h2>内容小结</h2><p>今天我们讲了一种跟数组“相反”的数据结构，链表。它跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。</p><p>和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。</p><h2>课后思考</h2><p>如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的思题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p><hr></hr><p><span class="orange">我已将本节内容相关的详细代码更新到GitHub，<a href="https://github.com/wangzheng0822/algo">戳此</a>即可查看。</span></p><p><img src="https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg" alt=""></p></div></div></div><div data-v-87ffcada="" class="article-comments"><h2 data-v-87ffcada=""><span data-v-87ffcada="">精选留言</span></h2><ul data-v-87ffcada="">            <li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Rain</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>275</span></a></div>
	</div>
	<div class="bd">Re Ydyhm:<br><br>“数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。” 这里的CPU缓存机制指的是什么？为什么就数组更好了？<br><br>----<br><br>我没有百度也没有Google。之前开发时遇到过，我斗胆说下。<br>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。<br><br>对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。<br><br>大牛请指正哈！</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">同学，太爱你了。写的太好了！就喜欢你这样的，减轻了我很多回复留言的工作量。👍</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/8b/73/5d4dca26.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">JK David</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>87</span></a></div>
	</div>
	<div class="bd">思考题：<br><br>使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。<br><br>时间复杂度：O(n)<br>空间复杂度：O(1)<br><br>https:&#47;&#47;github.com&#47;andavid&#47;leetcode-java&#47;blob&#47;master&#47;note&#47;234&#47;README.md</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">思路正确，不过空间复杂度计算的不对，应该是O(1)，不是O(n)。我们要看额外的内存消耗，不是看链表本身存储需要多少空间。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Liam</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>40</span></a></div>
	</div>
	<div class="bd">1 快慢指针定位中间节点<br>2 从中间节点对后半部分逆序<br>3 前后半部分比较，判断是否为回文<br>4 后半部分逆序复原<br><br>时间复杂度On, 空间复杂度O1<br>把LRU和回文都实现了一遍~~<br><br>如果是双向链表，时间效率更高，看了下LinkedList，底层也是用双向链表实现</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">回答的很好！👍</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/b2/80/e9223398.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">glbfor.gtw</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>14</span></a></div>
	</div>
	<div class="bd">1 快慢指针定位中间节点（这里要区分奇偶情况）<br>1.1 奇数情况，中点位置不需要矫正<br>1.2 偶数情况，使用偶数定位中点策略，要确定是返回上中位数或下中位数<br>1.2.1 如果是返回上中位数，后半部分串头取next<br>1.2.2 如果是返回下中位数，后半部分串头既是当前节点位置，但前半部分串尾要删除掉当前节点<br>2 从中间节点对后半部分逆序，或者将前半部分逆序<br>3 一次循环比较，判断是否为回文<br>4 恢复现场<br><br>题外话，这种操作有点BT啊？实际运用场景中，也真的直接改变引用值吗？至少在多线程情况，要加N多锁（Read Write都要加锁），这个时间成本就不能简单用时间复杂度来衡量了。如果是用copy 机制，不论是倒置前半段还是后半段，至少有一段是需要n&#47;2个节点副本的空间消耗的，那么空间复杂度就是O（n）？？啦~跑题了，跑题了~~<br><br>老师，你给我评价被~ 我比较容易钻牛角尖。。<br></div> <span class="time">2018-10-11</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍 回答的非常好</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/30/1c/e160955d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">sky</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>4</span></a></div>
	</div>
	<div class="bd">用快慢指针先找到中点，然后把后半段链表reversed，然后一个指针在头部，一个指针再中点，开始逐个比较，时间复杂度是O（n)</div> <span class="time">2018-10-09</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对的！👍</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">姜威</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>131</span></a></div>
	</div>
	<div class="bd">五、应用<br>1.如何分别用链表和数组实现LRU缓冲淘汰策略？<br>1）什么是缓存？<br>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。<br>2）为什么使用缓存？即缓存的特点<br>缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。<br>3）什么是缓存淘汰策略？<br>指的是当缓存被用满时清理数据的优先顺序。<br>4）有哪些缓存淘汰策略？<br>常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。<br>5）链表实现LRU缓存淘汰策略<br>当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。<br>6）数组实现LRU缓存淘汰策略<br>方式一：首位置保存最新访问数据，末尾位置优先清理<br>当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。<br>方式二：首位置优先清理，末尾位置保存最新访问数据<br>当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）<br>2.如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如 上海自来水来自海上）<br>1）前提：字符串以单个字符的形式存储在单链表中。<br>2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。<br>3）将链表中的字符倒序存储一份在另一个链表中。<br>4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是水仙花字串，否则，不是。<br>六、设计思想<br>时空替换思想：“用空间换时间” 与 “用时间换空间”<br>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/17/88/be4fe19e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">molybdenum</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>60</span></a></div>
	</div>
	<div class="bd">看了大家的评论学习到了快慢指针法，看语言描述没太懂，自己用代码写了下才明白。<br>大致思路如下<br>由于回文串最重要的就是对称，那么最重要的问题就是找到那个中心，用快指针每步两格走，当他到达链表末端的时候，慢指针刚好到达中心，慢指针在过来的这趟路上还做了一件事，他把走过的节点反向了，在中心点再开辟一个新的指针用于往回走，而慢指针继续向前，当慢指针扫完整个链表，就可以判断这是回文串，否则就提前退出，总的来说时间复杂度按慢指针遍历一遍来算是O(n),空间复杂度因为只开辟了3个额外的辅助，所以是o(1)</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">姜威</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>36</span></a></div>
	</div>
	<div class="bd">总结<br>一、什么是链表？<br>1.和数组一样，链表也是一种线性表。<br>2.从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。<br>3.链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。<br>二、为什么使用链表？即链表的特点<br>1.插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。<br>2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。<br>三、常用链表：单链表、循环链表和双向链表<br>1.单链表<br>1）每个节点只包含一个指针，即后继指针。<br>2）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。<br>3）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。<br>2.循环链表<br>1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。<br>2）适用于存储有循环特点的数据，比如约瑟夫问题。<br>3.双向链表<br>1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。<br>2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。<br>3）性能特点：<br>和单链表相比，存储相同的数据，需要消耗更多的存储空间。<br>插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br>对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>4.双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。<br>四、选择数组还是链表？<br>1.插入、删除和随机访问的时间复杂度<br>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。<br>2.数组缺点<br>1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。<br>2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。<br>3.链表缺点<br>1）内存空间消耗更大，因为需要额外的空间存储指针信息。<br>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。<br>4.如何选择？<br>数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。<br>如果代码对内存的使用非常苛刻，那数组就更适合。<br></div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fd/91/65ff3154.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">_stuView</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>34</span></a></div>
	</div>
	<div class="bd">双向链表存储，两个指针分别从头节点和尾节点开始遍历，依次比较节点value，判断是否为回文序列</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fc/13/11f8062e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Joshua 兆甲</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>31</span></a></div>
	</div>
	<div class="bd">习题解答<br>1.快进慢进法[两组指针，从头开始，a组一次进一，b组一次进二，b组到终点时，a组位置即为链表中间结点，循环次数为链表除去中间结点后前后两组的长度] 求得单向链表“中间”节点。并计算遍历次数，经过验证，遍历次数为‘’半链表‘’长度<br>2.从中间结点开始，以动态步长[每第i次步长是半链表长度-i+1]遍历链表，同时，从头节点开始，以1步长遍历。比较两组对应元素是否相同，相同继续，不同退出，返回不是回文字符串的结论。<br>3.返回是回文字符串的结论，退出.<br>空间复杂度O(n). 不用连续内存，可以磁盘操作<br>时间复杂度度O(n). 主要费时操作遍历<br><br>  算了，不够直观，不易别人看懂。还是先把单项链表转存为线性表。<br>1.单向遍历，获得对应的线性表Arr，求线性表长度为L<br>2.运用线性表可以任意访问的性质，遍历Arr，令下标i从0。比较Arr[i]和Arr[L－i]是否相等 相等继续，不等报告不是回文字符串结论，退出<br>3.报告是回文字符串结论，结束。<br>空间复杂度O(n)<br>时间复杂度O(n)<br>看起来一样，这个就需要字符串不太大，有足够的连续内存可以分配，而且，预先不知道链表多长，可能还会遇到扩容问题。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/df/47/9a425604.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">雨山</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>26</span></a></div>
	</div>
	<div class="bd">果然有程序员风格，放假还更新，昨天临睡前就看完了，但是没有评价，总之这个课绝对物有所值。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/12/e1/8356200c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">无崖子🍀</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>19</span></a></div>
	</div>
	<div class="bd">用数组解决Lru缓存问题：<br>维护一个有序的数组，越靠近数组首位置的数据越是最早访问的。<br>1.如果这个数据已经存在于数组中，把对应位置的数据删掉，直接把这个数据加到数组的最后一位。时间复杂度为o(n)<br>2.如果数据不存在这个数组中，数据还有空间的话，就把数据直接插到最后一位。没有的话，就把第一个数据删掉，然后把数据插入到数组最后一个。这样的时间复杂度为o(n）。<br><br>第一个小伙伴的留言有点问题。判断是否为回文串和奇偶数没关系吧，偶数个字符串也可以是哈，比如abccba。<br></div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">落叶飞逝的恋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>18</span></a></div>
	</div>
	<div class="bd">老师，关于解答开篇那边，能不能附加一些代码示例，这样配合代码跟思路讲解，可能更好的理解呢。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">徐凯</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>12</span></a></div>
	</div>
	<div class="bd">通过一个栈  遍历整个链表   然后再从栈中弹出  如果元素都匹配则为回文</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">null</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>9</span></a></div>
	</div>
	<div class="bd">老师，您回复 JK David 说到：<br>空间复杂度计算的不对，应该是O(1)，不是O(n)。我们要看额外的内存消耗，不是看链表本身存储需要多少空间。<br><br><br>在《复杂度分析（上）》提到：<br>第 3 行申请了一个大小为 n 的 int 类型数组，所以整段代码的空间复杂度就是 O(n)。<br><br><br>----<br><br><br>疑问一：<br>为什么两处计算空间复杂度的方法不一致，回复评论是以额外消耗为准，而文章中是以分配存储的空间为准？<br><br><br>疑问二：<br>《复杂度分析（上）》中介绍空间复杂度没有时间复杂度详细且带例子，看到老师您回复 JK David 以额外消耗为分析对象，就更懵圈了。<br>如果说：<br>1. 额外消耗常量值内存的空间复杂度是 O(1)；<br>2. 额外消耗 n 内存的空间复杂度是 O(n)；<br>那么空间复杂度是 O(n 的平方)，如何才能额外消耗 n 的平方空间呀？<br>老师能否针对空间复杂度，有一个更详细的说明和举例呢？<br><br><br>谢谢老师</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f0/21/dc37257c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">JStFs</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>8</span></a></div>
	</div>
	<div class="bd">LRU：活在当下。比如在公司中，一个新员工做出新业绩，马上会得到重用。<br><br>LFU：以史为镜。还是比如在公司中，新员工必须做出比那些功勋卓著的老员工更多更好的业绩才可以受到老板重视，这样的方式比较尊重“前辈”。</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">哈哈 形象！</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1b/86/22a9362f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">六六六</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>8</span></a></div>
	</div>
	<div class="bd">判断单链表是否是回文，只想到了这种low一些的做法，时间复杂度为O(n^2)：<br>public static boolean isHuiwen(LinkedList linkedList) {<br>        Node first = linkedList.getFirst();<br>        int size = linkedList.getSize();<br>        Node head = null;<br>        Node foot = null;<br>        for (int a = 0; a &lt; size &#47; 2; a++) {<br>            head = head == null ? first : head.next;<br>            foot = head;<br>            for (int i = a; i &lt; size - 1 - a; i++) {<br>                foot = foot.next;<br>            }<br>            if (!head.getData().equals(foot.getData())) {<br>                return false;<br>            }<br>        }<br>        return true;<br>    }<br></div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阳仔</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>6</span></a></div>
	</div>
	<div class="bd">学习反馈：<br>链表也是一种基础的线性表结构。由于它的很多特点跟数组是相反的，因此可以与数组一起对比着学习。<br>数组的存储空间是连续，而链表不是；数组可以通过寻址公式计算通过下标来访问，而链表访问元素需要遍历。<br>常见的链表有：<br>单链表、双向链表、循环链表、双向循环链表。<br>链表擅长插入、删除操作，时间复杂度为O(1)；查询的效率不高，时间复杂度为O(n)。<br>数组擅长通过下标随机访问元素，时间复杂度为O(1)；插入、删除的效率不高，时间复杂度为O(n)。<br>在实际项目开发中，选择数组或者链表不能只关注时间复杂度，还需要考虑具体业务，综合考虑选择数组还是链表。<br>了解了链表的数据结构，那么实现一个机遇链表数据结构的LRU算法就比较简单了：<br>从链表中查询此缓存数据是否存在：<br>1、如果存在，则删除该缓存数据节点，并把数据插入到链表头部的位置；<br>1、如果不存在，则也考虑两种情况：<br>    1、如果缓存充足，则把数据插入到链表头部的位置；<br>    2、如果缓存不足，则把链表中的末尾节点删除，再把缓存数据插入到头部。<br>思考题：<br>如果是只使用单链表的话，假设存储回文的链表是L1，再用一个链表L2来存储逆文；<br>我的思路是这样：<br>1、循环这个回文链表L1，在遍历到一半之前把逆文存在一个L2中；<br>例如L1 为A-&gt;B-&gt;C-&gt;B-&gt;A，那么遍历到一半时，L2为：B-&gt;A；<br>偶数和奇数的区别在与中间的节点要不要放在L2中。<br>2、继续遍历比较L1,L2两个链表各个元素是否相等，如果不相等则立即返回；如果比较到最后遍历结束，则说明是回文；<br>因此通过一次遍历就知道这个链表是否为回文。时间复杂度为O(n)。<br></div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Smallfly</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>6</span></a></div>
	</div>
	<div class="bd">思考题：根据原有单链表回文创建一个逆向的单链表回文，while 循环遍历比较，复杂度为 O(N)。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/d8/bc/a20dc219.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">A漩</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>5</span></a></div>
	</div>
	<div class="bd">最近最少使用策略 LRU（Least Recently Used）<br>老师此处的例子是着重体现了”最近“的场景吧！<br>如果想体现”最少“是不是还得为LinkedList加个”访问次数“的属性？</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">字面上是你的理解 不过请百度百科一下LRU 我讲的没错呢</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d6/59/d19253dd.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">wistbean</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>4</span></a></div>
	</div>
	<div class="bd">--------总结一下--------<br><br><br>常见的链表结构<br>1.单链表：<br>每个节点除了存储数据之外，还有记录下一个节点的地址，这样才能串联起来，记录下一个节点地址的指针就是「后续指针next」。<br>其中有两个特殊的节点为「头结点」和「尾节点」，头结点记录链表的基地址，尾节点记录下一个节点地址是NULL，代表链表的最后一个节点。<br><br>链表增删效率高<br>对于链表（存储数据无需连续性）的增删，只需要考虑指针的改变，复杂度为O（1）。<br><br>链表访问慢<br>由于不像数组那样可以根据首选地址和下标计算出内存地址，只能通过遍历节点获取地址。时间复杂度为0（n）。<br><br>2.循环链表<br>是特殊的单链表，尾节点指针指向链表的头结点。<br><br>3.双向链表<br>支持双向，除了「后续指针next」还有「前驱指针prev」<br><br>相比单链表和双链表，增删查效率高，内存消耗高。<br><br>空间换时间，时间换空间<br>对于执行慢的程序--&gt;空间换时间<br>对于消耗内存多的程序--&gt;时间换空间<br><br>链表和数组的区别<br><br>底层存储结构：<br>数组需要一块连续的内存空间存储<br>链表通过“指针”将一组零散的内存块串联起来使用<br><br>性能：<br>1.链表和数组的（增删查）时间复杂度正好相反。<br><br>2.数组使用连续的内存空间，可以借助缓存机制提高效率。<br>链表不连续，所以无法借助缓存机制。<br><br>3.数组大小固定，当要申请更大的空间，需要拷贝数据，很耗时。<br>链表则支持动态扩容。<br><br>4.相对来说链表比较耗内存，因为需要记录节点指针，内存消耗翻倍。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/26/88/e8098480.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">James Scott</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>4</span></a></div>
	</div>
	<div class="bd">回复一下CaiBird的提问：应该是写错了，应该是越靠近链表头部的节点是越早被访问的。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">谢谢你🙏 不过我没有写错。已经回复给他。不过，你为什么觉得我写错了呢？</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">yaya</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>4</span></a></div>
	</div>
	<div class="bd">思考题:先用快慢指针得中点，然后将后段链表逆序，比较是否是回文串。再将链表逆序回来，时间复杂度o（n）,空间复杂度o（1）.<br>利用数组实现lru,想法是利用堆的思想，根据时间最远最少用的规则建立堆，利用结构体维护最近的访问时间，根据其建堆，如果一个新的元素来，遍历数组，如果能找到，更新他的参数，调整堆。如果不能就将堆的头元素删除，插入该元素</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/dd/03/77a80775.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">CaiBird</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>4</span></a></div>
	</div>
	<div class="bd">越靠近链表尾部的结点是越早之前访问的<br><br>这里不懂 😳老师可以解答一下吗，谢谢</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">链表是有序链表，按照访问时间排序，访问时间值最小的放到链表尾部，最大的放到链表头。当要淘汰一个数据时，直接删除链表尾部的结点，当要加入一个数据时，直接插入链表头部。<br>当然，你要想按照相反的方式组织，也是可以的啊，只要是满足LRU就可以了。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8e/08/b64c9ac6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">hello,武招招</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">golang使用快慢指针实现的回文字符串判断<br>type node struct {<br>	data interface{}<br>	next *node<br>}<br><br>type linkList struct {<br>	head *node<br>	tail *node<br>	size int32<br>}<br><br>func (l *linkList) reverseList() {<br>	l.tail = l.head<br>	var after *node<br>	var pre *node<br>	root := l.head<br>	if l.head != nil &amp;&amp; l.head.next != nil {<br>		for root.next != nil {<br>			after = root.next<br>			root.next = pre<br>			pre = root<br>			root = after<br>		}<br>		root.next = pre<br>		l.head = root<br>	}<br>}<br><br>func (l *linkList) getMidNode() *node {<br>	slow := l.head<br>	fast := l.head<br>	for fast != nil {<br>		&#47;&#47; 已指向最后一个节点 奇数<br>		if fast.next == nil || fast.next.next == nil {<br>			return slow<br>		}<br>		slow = slow.next<br>		fast = fast.next.next<br>	}<br>	return nil<br>}<br><br>&#47;&#47; 快慢指针判断回文字符串 奇数的话快指针刚好指向最后一个节点 偶数的话快指针指向空<br>&#47;&#47; 根据慢指针来定位中间节点<br>func isPalindrome(l *linkList) bool {<br>	mid := l.getMidNode()<br>	length := l.getLength()<br>	backLinkList := creatLinkList()<br><br>	if length%2 != 0 {<br>		mid = mid.next<br>	}<br>	backLinkList.setHeadNode(mid)<br>	backLinkList.reverseList()<br><br>	preHead := l.head<br>	p := backLinkList.head<br>	for p != nil {<br>		if preHead.data != p.data {<br>			return false<br>		}<br>		preHead = preHead.next<br>		p = p.next<br>	}<br>	return true<br>}</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/14/f9/5e08a350.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">5ispy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">老师好，关于这节的内容有个疑问不太确定。<br>因为我看有人用java实现了链表有人也可以用c来实现。是不是数组属于编程语言“自带”的，而链表是 人 用编程语言 “实现”的。<br>比如对于java来说，如果项目中用到了链表，我们可以说是用到了某个类，而这个类就是 链表（实现了链表的功能）。<br>恳请老师指正！</div> <span class="time">2018-10-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">你理解的没错</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/f6/88/ee32fde9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">章光辉</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">判断访问的数据是否存在于缓存里的时候，无论是链表还是数组，时间复杂度都是O(n)对吧？那么在此基础上做的增删改，最高的复杂度也只是O(n)。根据加法法则，总的复杂度都是O(n)。不知道我理解得对不对？</div> <span class="time">2018-10-05</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">对的</p> <p class="reply-time">2018-10-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Kudo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">&gt;&gt; 思考题：用数组来实现 LRU 缓存淘汰策略。<br>为了使访问更有效率，我们用数组尾部的结点存储最近访问的数据。<br>1. 如果此数据之前已经被缓存在数组中了，反向遍历得到这个数据对应的结点，将其放在数组尾部，并将原先该结果后面的结点分别向前移动一个单位。<br>2. 如果此数据没有在缓存数组中，又可分两种情况。<br>（1）如果此时缓存未满，则将此结点插入到数组的尾部；<br>（2）如果此时缓存已满，则将数组头部结点删除，将新的数据结点插入数组尾部，并将其它所有节点分别前移一个单位。<br>该操作的时间复杂度为O(n)，相对链表实现方式涉及更多的数据移动动操作，因此访问效率要低一些。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/39/4d/9ce28826.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">luxinfeng</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>3</span></a></div>
	</div>
	<div class="bd">单链表存储，设置两组指针A和B，从链表头部开始遍历，指针A每次前进一位，指针B每次前进两位；指针A每到一个位置，就将该位置的字符压入栈中，直到指针B到达链表尾部，此时指针A到达字符串的中间位置。然后，每当指针A前进一步，就将栈中的字符弹出一位，比较指针A所指字符与弹出字符是否相等，如果相等，则继续运行；不等，则退出程序，说明该字符串不是回文序列。<br>时间渐进复杂度O（n），空间渐进复杂度O（n）。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/01/ae/f298ef27.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">岁月如歌</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">设计lru算法的思路，不管用什么数据结构，都要考虑的几个问题。<br>1、如何表示最近访问的数据和最早访问的数据<br>2、如何查找是否缓存了<br>3、数据有缓存，如何处理<br>4、数据没有缓存，如何处理<br>      1.缓存未满<br>      2.缓存已满</div> <span class="time">2018-10-12</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍 总结的很好</p> <p class="reply-time">2018-10-13</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/47/52/5205764a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">🤔</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">理论大概明白，但是还有个问题，用js实现了个链表类，并且模拟Array.prototype.splice实现了链表的在指定下标插入操作，因为要循环遍历找到指定下标前的节点所以时间复杂度应该是O(n)，splice应该也是O(n)，但用console.time测了下循环10000次插入操作，链表插入比数组splice快了6ms，仅仅是因为splice执行了其他额外操作吗？怎么理解这种相同复杂度下两种不同结构造成的差异呢？</div> <span class="time">2018-10-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">港</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">创建一个与原来链表相同的反向链表，然后一个一个结点比对，时间复杂度是O(n)，空间复杂度是O(n)。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小喵喵</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>2</span></a></div>
	</div>
	<div class="bd">如果此数据之前已经被缓存在链表中了,我们遍历得到这个数据对应的结点,并将其从原来的位置删除，然后再插入到链表的头部。<br>1。LRU算法这点不太理解，为什么都在cache中，还有删除掉重新插入呢？<br>2.  这个LRU算法，cache过期了，如何更新呢？请老师指点一下。<br><br><br><br><br><br></div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">1. 因为链表是有序的，按照访问时间排序；<br>2. cache怎么过期的呢？麻烦说详细点。</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/07/3f/53ae01f6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Kevin.zhang🌏</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">习题解，大部分同学都说到了方法一：半栈法<br>　　　　　１．用快慢两个指针遍历，同时用栈copy慢指针指向的data。<br>　　　　　２．完成后，慢指针指向中间节点，耗时为N&#47;2.<br>　　　　　３．最后用pop栈中的data和慢指针指向的data比较，耗时也是N&#47;2.<br>          所以时间复杂度为：Ｏ(N)，空间复杂度因栈额外存储了一半的data，故为O(N&#47;2)<br><br>方法二：全栈法<br>　　　　　１．全部遍历，data压栈，额外空间消耗N<br>                    ２．再次全部遍历取data，同时pop栈取data, 二者比较，时间消耗2N<br>          所以时间复杂度为O(3N)，空间复杂度为O(N)<br>          该法算法最简单，但复杂度高。可以用栈存储节点指针，而非data来改进。<br><br>方法三：硬干法<br>　　　　　1. 一个指针从头取data，另一个指针遍历到底取data，比较二者<br>　　　　　２．删除尾部节点，重复１．<br>　　　时间复杂度高达　O(N^2)，空间复杂度却最低Ｏ(1)</div> <span class="time">2018-11-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">👽</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">判断是否是回文<br>回文：level noon这样，对称的字符串<br>手机回复，所以不写代码了，就写一下思路。<br>1.创建一个双向链表存储该字符串<br>2.循环找到中间节点 长度\2 再+1（长度为10，就访问第6个，长度为7就访问4）<br>4.定义两节点，两种情况 <br>      1.如果长度是奇数，两个节点都指向已找到的中间节点。<br>     2.如果长度是偶数，那么分别指向之前找到的节点的前一个节点。<br>5.两变量分别取上一个节点和下一个节点对比并复制给自己。直到上一个节点为空时。代表链表遍历结束。<br>6.中间任意一次数值不相等则返回false，到最后都相等则返回ture。<br>时间复杂度应该是O（n），这样处理对吗？</div> <span class="time">2018-10-29</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">题设是单链表呢</p> <p class="reply-time">2018-10-29</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0b/d0/a5eacd8c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Zherlock</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">我的方案是，对于单纯的单链表<br>1。从头部遍历到尾部。<br>2。判断第一个和最后一个是否相等<br>3。删除第一个和最后一个，然后循环<br>这个方案时间复杂度，O(n×n)，空间复杂度n<br><br>或者把单链表复制到一个数组里面去，直接进行比较，时间复杂度O(n),空间复杂度2n<br><br>或者用一个循环链表，时间复杂度也能下降到O(n)</div> <span class="time">2018-10-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/43/98/d1f6c524.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">(≧ω≦)罗敏</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">单链表判断是否是回文串:<br>把原先的单链表倒序复制一遍，然后比较两个链表是否值相同</div> <span class="time">2018-10-11</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">好像空间复杂度有点高了</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/d6/11/808eb5f8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小志</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">印象中，还记得CPU还有一级、二级、三级缓存呢吧</div> <span class="time">2018-10-11</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">args</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">讲得很容易理解，不多的篇幅讲知识点和应用，润物无声</div> <span class="time">2018-10-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">多谢认可🙏</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/25/9e/69b65b6f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">一棵开花的树</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">用python写的，仅供参考！考虑奇偶，否则会报错：AttributeError: &#39;NoneType&#39; object has no attribute &#39;next&#39;<br>&#39;&#39;&#39;<br>参考：https:&#47;&#47;blog.csdn.net&#47;whm114336793&#47;article&#47;details&#47;79996943<br>&#39;&#39;&#39;<br>class Node(object):<br>    def __init__(self, data, next=None):<br>        &quot;Instantiates a Node with a default next of None.&quot;<br>        self.data = data<br>        self.next = next<br>def getLinkedList(str):<br>    head = None<br>    # Add nodes to the linked structure<br>    for item in str:<br>        # print(item)<br>        head = Node(item, head)<br>        # print(&quot;head.data:&quot;, head.data)<br>        # print(&quot;before:&quot;, head.next)<br>    return head<br><br>def isPalindrome(node, isEven):<br>    if (node == None):<br>        return True<br>    elif (node.next == None):<br>        return True<br>    else:<br>        fast = node<br>        slow = node<br>        while ((fast != None) &amp; (fast.next != None) &amp; (fast.next.next != None) &amp; (isEven == True)):<br>            fast = fast.next.next<br>            slow = slow.next<br>        while ((fast != None) &amp; (fast.next != None) &amp; (isEven == False)):<br>            fast = fast.next.next<br>            slow = slow.next<br>        if (fast != None):<br>            slow = slow.next<br>        print(&quot;slow.data:&quot;,slow.data)<br>        high = slow.next<br>        slow.next = None<br>        temp = None<br>        while (high != None):<br>            temp = high.next<br>            high.next = slow<br>            slow = high<br>            high = temp<br>        temp = node<br>        high = slow<br>        flag = True<br>        while ((temp != None) &amp; (high != None)):<br>            if (temp.data != high.data):<br>                flag = False<br>                break<br>            temp = temp.next<br>            high = high.next<br>        return flag<br><br><br>def main():<br>    if __name__ == &#39;__main__&#39;:<br>        isEven = False<br>        str = &quot;abcddcbafg&quot;<br>        length = len(str)<br>        if (length % 2) == 0:<br>            isEven = True<br>        else:<br>            isEven = False<br>        node = getLinkedList(str)<br>        print(&quot;isEven:&quot;, isEven)<br>        flag = isPalindrome(node, isEven)<br>        print(&quot;result:&quot;, flag)<br><br>main()<br></div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/e3/41/b06f7ec0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">CozyThinker</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">耗时28分钟学习完毕</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">spark</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>﹉﹉﹉<br>老师，上面这段话什么意思，有点理解不了！双向链表查询效率为什么比单链表要高？记录上次查找的P又是啥意思？在哪里记录，在链表还是自己单独用一个内存(变量）记录？</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/50/99/44378317.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">李皮皮皮皮皮</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">个人认为链表还是增加一个表头节点，存储一些信息，比如首节点，尾节点，长度等。这样使用起来比较方便</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">我瑟瑟的方法</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">什么是回文串</div> <span class="time">2018-10-05</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">麻烦自己百度一下吧 亲 百度一下好几十页都是讲回文串的</p> <p class="reply-time">2018-10-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1b/85/c743120c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">🍀  Rice</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">为什么单链表插入删除的时间复杂度是O(1)呢？如果插入一个数在下标是K的位置，不是要先遍历获取到a(k-1)吗?</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">同学，能认真看看我的文章吗？我不是讲了的嘛！后面还特意强调的！</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/37/d0/d60767cf.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">geektime learn</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">1，基于内存计算的Spark相比基于磁盘计算的Hadoop应该就是空间换时间吧<br>2，数组实现LRU<br>      分析了一下，数组实现LRU会造成大量数据迁移带来的耗时，而且缓存不满时，数组满了，这时数组要扩容，扩容还得考虑扩容是否能请求到足够的缓存问题，会变得很复杂......<br>3，思考题<br>     (1)遍历单链表并取出数据放入数组中<br>     (2)正向遍历数组取出每个字符并生产一个字符串s1<br>     (3)逆向遍历数组取出每个字符并生产一个字符串s2<br>     (4)判断s1的值跟s2的值是否相同，相同就是回文串，否则不是<br>      时间复杂度：n+n+n=3n推断时间复杂度为O(n)<br>      空间复杂度：多申请了一个数组的大小</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0e/69/5ee5af96.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Niulx</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">public static boolean isPalindrome(Node root) {<br>		if (root == null) {<br>			return false;<br>		}<br><br>		Node head = root;<br>		Node reserve = null;<br><br>		while (head != null) {<br>			Node next = head.next;<br>			head.next = reserve;<br>			reserve = head;<br>			head = next;<br>		}<br><br>		while (root != null &amp;&amp; reserve != null) {<br>			if (root.c == reserve.c) {<br>				root = root.next;<br>				reserve = reserve.next;<br>			} else {<br>				return false;<br>			}<br>		}<br>		return true;<br>	}<br>我是这样想的，先反转单链表，在while循环判断两个链表的字符是否相等</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/a7/8e/abb7bfe3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Astrian 🦊</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">简单写了一下 JS 下的链表实现，https:&#47;&#47;gist.github.com&#47;Astrian&#47;0fab823f41e288cc2fc324ba3991d1b8，希望可以有帮助+求大佬指点 (=ﾟωﾟ)ﾉ</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/27/fc/b8d83d56.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">liangjf</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">习题解答方法<br>1.快慢指针。通过得到中间结点，同时从开始，尾部向中间遍历并对比，不满足则退出直到全部匹配<br><br>2.借助 栈。对比入栈前，出栈后的字符串，相同则满足条件。<br><br>3.字符串插入到数组。利用求出数组长度，利用数组下标访问特性，循环判断arr[i] == arr[L-i] ，直到不满足退出。<br><br>数组和链表各有各的优点缺点，不能一概而论，同时抛开需求业务谈性能都是耍流氓，比如在嵌入式开发时，一些芯片的栈内存资源是很紧张的，如果申请较大的局部数组会造成栈溢出，这时可以用链表替换。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mr.Panda</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>1</span></a></div>
	</div>
	<div class="bd">打卡学习！</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">biepa</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于开篇问题写得有些少吧，而且我觉得用数组实习lru缓存明显比较复杂，是不是讲一下比较好</div> <span class="time">2019-02-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/15/48/7f/0f1f861f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">解忧杂货店。</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">好尴尬，不懂快慢指针赶紧去百度</div> <span class="time">2019-02-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/lZCviaxzMSO3ibm1boIjHKrPIK9RVOGRNLZa1UKvZe2DgPU9Cnwlt9zbnvicRJ3dRMicChz7kWs8ibLeDKEO9mpWpBw/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">梁华建</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">LRU也叫页面置换机制，缓存页表中爆满时需要把一个最久未使用的页面调出以从内存加载一个新的页面。<br>显然答案里面的单链表实现LRU是有规定的，他规定头节点插入（因为是单链表，从哪里插入都是随便找一个内存空间给你放的），尾节点是最久未使用的（因为他很久没有被访问，当他被访问时候，他会被删除，然后插入到头节点，相当于移位到头部，访问是指删除和插入，并不是简单的查看）<br>数组的实现的话，制定类似上面的规则就好，如数组一般尾插入，按照顺序。那就变成数组头是最久未访问的，被访问了的元素会被刷新位置放到尾部。<br>回文字符串：上面链表可以实现，很多同学已经回答了， 当然使用数组也可以，直接定位到元素中间，然后两个下标，一前一后i- -和j+ +判断前后元素是否相同。leetcode上面有个判断字符串里面最长的回文字符串，那个就是用数组下标做的，主要是理解回文就是找到中间向两边散开</div> <span class="time">2019-02-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Pre-Y</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对于思考题看了大佬们的解答涨姿势了。<br><br>个人所学甚少，只能想到这些：<br>一：硬干<br>先记录头结点data，再用另两个指针遍历单链表到最后一个结点，比较两者data值。相同就删除这两端的结点，并重复操作；不同就返回No<br>时间复杂度应该是O（n²）<br>空间复杂度应该是O（1）<br>二：将单链表转存到双链表<br>用两指针记录首尾两结点，比较它们的data值。相同就往中间移动；不同返回No<br>时间复杂度，虽然判断简单，但涉及数据搬家所以应该是O（n）<br>空间复杂度因为额外用了内存，应该也是O（n）<br></div> <span class="time">2019-02-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIWgpgEACljAII095cibNoPxlR6X3sIY1fmf4KjNjIoZ8icUOYL206lAcsqMsMl80pc4IbnsrpE28rQ/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">京</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">用数组实现LRU 缓存淘汰策略<br>思路：<br> 1、维护一个固定大小的有序数组<br>*2、如果访问的元素在数组中，获取元素的原位置，将原位置之前的所有元素整体向后移动一位，访问的元素放在数组第一个位置<br> 3、如果访问的元素不在数组中，获取需要重新排序的元素位置，将该位置之前的所有元素整体向后移动一位，访问的元素放在数组第一个位置<br><br>代码实现：<br>public class LRUBaseArrayList {<br>	&#47;&#47; 数组长度<br>	String array[] = new String[10];	<br>	public void add (String str) {<br>		&#47;&#47; 判断新访问的元素是否在数组中<br>		Integer in = isInArray(str);<br>		if (in == null) {&#47;&#47; 不在数组中<br>			&#47;&#47; 获取需要重新排序的元素位置<br>			int i = getPox();<br>			putStrToFirst(str,i);<br>		} else {&#47;&#47; 在数组中<br>			&#47;&#47; in位置之前的元素重新排序，新元素放在数组第一个位置<br>			putStrToFirst(str,in);<br>		}<br>	}<br>	private int getPox() {<br>		int i = 0;<br>		while (array[i] != null) {<br>			if (i == array.length-1) {<br>				break;<br>			}<br>			i++;<br>		}<br>		return i;	<br>	}<br>	<br>	private void putStrToFirst(String str,int count) {<br>		for (; count &gt; 0; count--) {<br>			array[count] = array[count-1];			<br>		}<br>		array[0] = str;<br>	}<br><br>	private Integer isInArray(String str) {<br>		for (int i = 0; i &lt; array.length; i++) {<br>			if (str.equals(array[i])) {<br>				return i;<br>			}<br>		}<br>		return null;<br>	}<br>	<br>	public void printAll() {<br>		for (int i = 0; i &lt; array.length; i++) {<br>			System.out.print(array[i]+&quot;,&quot;);<br>		}<br>		System.out.println();<br>	}<br>	<br>	public static void main(String[] args) {<br>		LRUBaseArrayListBy list = new LRUBaseArrayListBy();<br>		Scanner sc = new Scanner(System.in);<br>        while (true) {<br>        	list.add(sc.next());<br>        	list.printAll();<br>        }<br>	}<br>}<br></div> <span class="time">2019-01-31</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/be/d4/ff1c1319.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">金龟</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">大概思路：如果允许空间复杂度是O(n)的话，可以另外起一个stack，前半部分都入站，后面部分都出站。只不过要分奇偶数。</div> <span class="time">2019-01-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">极客鱼</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">“双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。”老师，这个是不是说错了，双向链表只是需要额外的一个空间来记录前驱结点的，因为本身单向链表也储存后继结点。求指教</div> <span class="time">2019-01-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/e4/1e/2d9181bb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">lll</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">“我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的...”<br>为什么越靠近尾部的节点是越早之前访问，正常逻辑，越靠近尾部那就是越靠后遍历，那应该是比较晚访问的？<br></div> <span class="time">2019-01-24</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">都可以啊，看你怎么定义了</p> <p class="reply-time">2019-01-25</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/7e/90/4f588dd9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">isea_you</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">第一次遍历链表，在使用一个栈将数据全部读进来，<br><br>第二次遍历链表，在出栈，对比即可<br><br>都是ON，但是贼简单，适合做对数器</div> <span class="time">2019-01-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">双子座的马克思</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表的特性是遍历方向为从前往后，而不能从后往前，如果要判断一个单链表的字符串是不是一个回文串，就判断第1位和第n位是否相等，第2位和第n-1是否相等...一直到中间位置。时间复杂度是O(n^2)</div> <span class="time">2019-01-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">双子座的马克思</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">通过数组实现LRU缓存：分数据在或不在数组中的两种情况。如果在，则将数组中的数据从原位置上删除，并添加至头部。如果不在，那么直接添加至头部，这里需要注意，如果数组空间满了，那么把最后的数据从数组中移除。</div> <span class="time">2019-01-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/44/f4/6b456c12.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">杜鹏</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">JK David的解法虽然是对的，但我不认同的是，它改变了链表原来的内容。<br><br>可以先遍历链表拿到链表的长度n<br>递归的判断长度为n-2的head-&gt;next链表是否回文，并且返回这个长度为n-2的链表的后继节点tail，判断head和tail的内容是否相等。只有两个条件都满足才返回true。</div> <span class="time">2019-01-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">双子座的马克思</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">举一个实际中的例子，增大服务器带宽，就是空间换时间的例子。</div> <span class="time">2019-01-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">双子座的马克思</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">用空间换时间真的很重要，前面讲的很多都有这个的体现，比如数组到链表，牺牲了连续内存增加了指针，虽然增加了空间，但增删查都节约了时间，计算机中，空间可以增加，但时间就这么多，是没办法改变的。不止算法，其实很多事也是这样。</div> <span class="time">2019-01-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0b/27/e67b238d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">无星</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看完散列表从头看链表，课程真的是连起来的</div> <span class="time">2019-01-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0b/27/e67b238d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">无星</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看完散列表从头看链表，课程真的是连起来的</div> <span class="time">2019-01-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8e/c7/6d08d502.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">双子座的马克思</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">提个小建议，插入x节点的图，最好不要用x，因为x和“叉号”很像……</div> <span class="time">2019-01-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">海军上校</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看评论，学习快慢指针法～</div> <span class="time">2019-01-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/10/4d/f548bc68.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Apollo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于缓存行不了解的同学请参考：http:&#47;&#47;blog.jobbole.com&#47;89759</div> <span class="time">2019-01-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d3/0e/c057ff45.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">远方</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对于双向链表，删除的第二种情况，为什么知道了指针位置，时间复杂度为1了，为什么不需要遍历查找了，前驱节点不也是只知道一个节点的前面一个人是谁吗。求教</div> <span class="time">2019-01-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e7/d1/9d1c283b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">randomx</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组来实现 LRU 缓存淘汰策略思路：<br>数组大小应该是固定的，<br>索引越小说明使用越早，每次向数组中插入一个数据之前同样两种情况，<br>如果已经存在将对应索引的值改为空，如果不存在，如果数组满了删除为空的和最近使用的，请老师指点</div> <span class="time">2019-01-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJic27dia65Z8OdictLLDOWic2fjFtiaQNQ1ou4icQ7AOjic4gK2iaOlYAUkNX7OoFnLs1hr1u5ib4Khcjib4DA/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">鱼子酱</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1. 链表与数组不同，特点是内存不连续，插入删除高效，复杂度是O(1)；而随机访问的复杂度是O(n)。<br>2. 几种常见的链表：单列表、双向链表、循环列表；<br><br>3. 单列表：包含一个数据元素和指向下一个阶段的指针，也就是pNext，并为尾节点的next指针为空。<br>循环列表：与单列表相似，不同的是尾节点的next指针指向头节点。<br>双向列表：每个节点包含两个指针，分别是指向前驱节点的prev指针和指向后继节点的next指针。在某些情况下，双向列表比单链表要高效。<br><br>4.空间换时间的思想：当内存空间足够时，如果追求代码的执行效率，可以采用空间复杂度较高，时间复杂度较低的算法，其中缓存就是利用了空间换时间的设计思想：<br><br>5.用链表判断一个字符串是否是回文字符串；<br>6.用链表实现LRU缓存淘汰算法。<br></div> <span class="time">2019-01-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">pplegend</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">abba 跟bacab 这两种都属于回文吧？ 设置两个指针的方法怎么感觉只适用后面那情况。或者说这两种情况需要分开来说吧？</div> <span class="time">2019-01-06</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">都是回文。不啊，两个都适合的。</p> <p class="reply-time">2019-01-17</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/30/f2/249a7ed5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">garryfu</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我认为这句话会有点误导：在链表中插入或者删除一个数据，，，，对应的时间复杂度是 O(1)。<br>比如我想删除链表中的第K个元素，那首先通过遍历找到这个元素，时间复杂度是O(n)，然后改变相邻元素的指针地址，时间复杂度是O(1)，那这样说来，插入或者删除链表的一个数据，对应的时间复杂度不就是O(n)嘛。</div> <span class="time">2019-01-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/8d/71/ec84719c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">钦</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链删除插入跟数组比复杂度是O(1),跟双向链比又是O(n),麻烦说明一下</div> <span class="time">2019-01-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">仔细看下文章吧，文章都有解释的</p> <p class="reply-time">2019-01-12</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/bb/a7/03f90dc4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">逍遥一叹</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">课后作业好多人都是使用：快慢指针定位中间节点的方法。为啥没人使用最基本的方法：<br>1、先找到链表尾(时间复杂度o(n))<br>2、一个指针从链表头往后遍历，一个指针从链表尾往前遍历，同时比较字符内容<br>3、如果发现有不一样的就表示不是回文数，如果两个指针最后指到一起或者相邻就表示回文数<br><br>上面的操作第一步复杂度最高，如果使用有指针保存链表尾，第二、三步平均复杂度才o(1)</div> <span class="time">2019-01-01</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/df/6c/287981d8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Dylan</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">&#47;&#47;在leetcode上AC的，O(n)时间复杂度，O(1)空间复杂度，关键点已经注释了<br>func isPalindrome(head *ListNode) bool {<br>	if head == nil || head.Next == nil {<br>		return true<br>	}<br><br>	var cur, fast = head, head<br>	var prev *ListNode<br>	for fast != nil &amp;&amp; fast.Next != nil {&#47;&#47;快慢指针，到链表中间，顺便把前半部分逆序<br>		cur.Next, prev, cur, fast = prev, cur, cur.Next, fast.Next.Next<br>	}<br>	if fast != nil {&#47;&#47;奇数的情况<br>		cur = cur.Next<br>	}<br><br>	for prev != nil &amp;&amp; cur != nil {&#47;&#47;将逆序的前半部分和后半部分一一比对<br>		if prev.Val != cur.Val {<br>			return false<br>		}<br><br>		cur = cur.Next<br>		prev = prev.Next<br>	}<br>	return true<br>}<br></div> <span class="time">2018-12-31</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/5f/30/4ae82e16.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">wordMan</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">既然链表再插入的时候涉及到先查找，复杂度为O(n),这样的话相对于数组的插入操作时间复杂度并没有优势啊。单纯讲链表插入为O（1）并没有什么意义啊？？</div> <span class="time">2018-12-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/aa/1b/b43c8519.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">happiness_xcy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表类中增加一个链表长度的字段length。实现思路如下，从链表头遍历链表，截止条件为遍历次数达到length&#47;2或者前后。<br>从链表头依次遍历到链表中部，每次遍历取逻辑为从当前节点（假设位置为i，从0）往后搜索链表，到length-i-1的位置为止。比较两个节点value的值是否相等，相等的话进入一下次循环；不相等的话判断为非回文直接退出。<br>时间复杂度分析：正向遍历的时间复杂度为O(n平方&#47;4)【1+2+...n&#47;2】，反向的时间复杂度为O(n平方)【n-1+n-2+...+1】。总体时间复杂度为O(n平方)。</div> <span class="time">2018-12-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">CathyLin</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不好意思到现在才开始学习这一章，经历了一个很忙很忙的 quarter。但是不给自己找借口了，该补上的还是得补上！<br><br>自己的课程总结：（因为链表之前有接触过，所以一些基础的知识就没有放上去）<br>如何实现 LRU 缓存淘汰算法?<br>缓存是一种提高数据读取性能的技术，例如常见的 cpu 缓存、数据库缓存和浏览器缓存等。<br><br>但是缓存大小有限，如果满了我们要将它们清理出去。有以下几种缓存淘汰策略：<br>先进先出策略 FIFO (first in first out)，最少使用策略 LFU (least frequently used)，最近最少使用策略 (least recently used)。<br><br>链表和数组的区别<br>链表申请的内存空间可以不是连续的；而数组的内存空间是一定要连续的。<br><br>单链表<br>通过指针把零散的内存块联系在一起。然后内存块被称为是链表的&quot;结点&quot;。<br>头结点用来记录链表的基地址。<br>尾结点则指向 NULL，是最后一个结点。<br><br>循环链表<br>循环链表是一种特殊的单链表。只不过尾指针指向的是头结点。<br><br>当要处理的数据具有环形结构时，那么就适合采用循环链表。例如约瑟夫问题。<br><br>双向链表<br>双向链表，每个结点都有一个向后的指针连接后面，以及一个 prev 指针指向前一个结点。<br><br>需要占用更多的内存空间。<br>但是当我们知道当前指针指向链表的哪个位置（某个指定位置的结点）时，那么删除和插入对于双向链表来说就只是 O(1) 的复杂度了，而单链表来得找它的前一个位置的链表，所以是 O(n) 的复杂度了。<br><br>空间换时间的 Idea!<br>缓存就是空间换时间。将数据存在硬盘里面会比较省内存，但是花时间。所以将其存在了内存中，虽然耗空间，但是运行速度就大大提升了。<br><br>双向循环链表<br><br>链表 vs 数组性能<br><br>它们插入删除、随机访问的时间复杂度刚好相反。<br><br>思考题 - 怎样利用链表实现 LRU 缓存淘汰算法<br>LRU(最近最少使用)，所以我们可以维护一个链表，然后最常访问的放在链表的头部，然后不经常访问的放在链表的尾部，然后如果有新的数据被访问时，分为两种情况：<br>	1. 这个数据已经在链表的结点中了，那么我们将其从原位置删除，然后重新将它插入到链表的头部。<br>	2. 这个数据没有在链表的结点中，又得分成两种情况：<br>		a. 当前缓存已经满了，那么我们得先删除链表的尾部，然后再将当前这个数据插入到链表的头部。<br>		b. 当前缓存没有满，那么我们直接将数据插入到链表的头部就好了！<br>复杂度：因为我们都得遍历一遍链表，所以最后的复杂度为 O(n)。<br><br>思考题我还没有想出来，先放着，不打算直接看答案。容我想一想然后再来评论区给答案！加油加油！！！</div> <span class="time">2018-12-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/43/fd/69beb2af.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">陈悬高</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">通过定位中间节点，可以检查链表的前半部分和进行反转后的后半部分是否相等，从而确定链表数据是否是回文格式。具体步骤如下：<br><br>1. 使用快慢指针定位中间节点。当链表的大小是偶数时，将返回中间的两个节点，要求它们必须相等。<br>2. 反转链表的后半部分（不包含中间节点）。<br>3. 遍历比较两部分数据，要求必须相等。<br>4. 再次反转链表的后半部分（不包含中间节点），恢复原始链表。<br>	<br>为了简化实现，在查找链表的中间节点时，有可能会返回两个节点。如果链表的大小是奇数，返回的恰好是中间节点；如果链表的大小是偶数，返回的则是中间的两个节点。在实现上使用了一个表示两个节点的*二维元组* `TwoTuple&lt;Node, Node&gt;`。如果链表的大小是奇数，那么二维元组的第一项将是中间节点，第二项为 `null`；如果链表的大小是偶数，那么第一项将是上中位节点，第二项将是下中位节点。<br>	<br>定位中间节点需要遍历 N&#47;2 次，反转链表的一半需要遍历 N&#47;2 次，遍历比较链表的一半需要遍历 N&#47;2 次，所以总共的遍历次数是 2N 次。时间复杂度为 O(N)。但是，该实现不需要额外的内存空间，空间复杂度为 O(1)。<br><br>```java<br>&#47;**<br> * 检查链表数据是否是回文格式。<br> * <br> * @param head<br> * @return<br> *&#47;<br>public static &lt;Item extends Comparable&lt;? super Item&gt;&gt; boolean isPalindrome(Node&lt;Item&gt; head) {<br>	if (head == null) &#47;&#47; 链表为空<br>		throw new NullPointerException(&quot;head is null&quot;);<br><br>	if (head.next == null) &#47;&#47; 只有一个节点<br>		return true;<br><br>	&#47;&#47; 1. 使用快慢指针定位中间节点。<br>	TwoTuple&lt;Node&lt;Item&gt;, Node&lt;Item&gt;&gt; tuple = getMiddleNode(head);<br>	Node&lt;Item&gt; first = tuple.first; &#47;&#47; 中间节点或上中位节点<br>	Node&lt;Item&gt; second = tuple.second; &#47;&#47; 下中位节点<br>	&#47;&#47; 若链表的大小是偶数，则有两个中间节点；要求它们必须相等。<br>	if (second != null) {<br>		if (first.item.compareTo(second.item) != 0)<br>			return false;<br>	}<br><br>	&#47;&#47; 2. 反转链表的后半部分（不包含中间节点）。<br>	Node&lt;Item&gt; probe = first;<br>	if (second != null) {<br>		probe = second;<br>	}<br>	probe.next = reverse(probe.next);<br><br>	&#47;&#47; 3. 对链表的前半部分，以及反转后的链表的后半部分执行遍历比较，要求必须相等。<br>	boolean result = true;<br>	Node&lt;Item&gt; p1 = head;<br>	Node&lt;Item&gt; p2 = probe.next;<br>	while (p2 != null) {<br>		if (p1.item.compareTo(p2.item) != 0) {<br>			result = false;<br>			break;<br>		}<br>		p1 = p1.next;<br>		p2 = p2.next;<br>	}<br><br>	&#47;&#47; 4. 再次反转链表的后半部分（不包含中间节点），恢复原始链表。<br>	probe.next = reverse(probe.next);<br><br>	return result;<br>}<br>```</div> <span class="time">2018-12-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/99/f1/68f5c089.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">咔咔NG</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，为什么双向链表删除的复杂度是O（1）？</div> <span class="time">2018-12-19</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">如果要删除p 那只需要p-&gt;previous-&gt;next =p-&gt;next就可以了</p> <p class="reply-time">2018-12-20</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIYIAkP3iaQzq8z3V2FibVX13g897ibnBt0g6Ps6QsN007JIpObLVia855GY0q842ljPbw3u54YEzmWxw/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Ewing</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，我在看你gitlab上的代码的时候，发现这段代码有问题。<br>&#47;**<br>     * 模拟访问某个值<br>     * @param object<br>     *&#47;<br>    public void offer(T object) {<br>        if (object == null) {<br>            throw new IllegalArgumentException(&quot;该缓存容器不支持null!&quot;);<br>        }<br>        Integer index = holder.get(object);<br>        if (index == null) {<br>            if (isFull()) {<br>                removeAndCache(object);<br>            } else {<br>                cache(object, count);<br>            }<br>        } else {<br>            update(index);<br>        }<br>    }<br>在调用cache()方法的时候，传入的第二个参数应该是 index 索引吧？<br>希望得到老师的指点，谢谢！</div> <span class="time">2018-12-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/4c/d3/365fe5a1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">yann [扬] :曹同学</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">cpu带几块小缓存，以KB为单位，比内存还快，其实是硬盘，内存，cpu缓存接力的<br><br>另，什么是回文字串？</div> <span class="time">2018-12-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e1/69/0db70c84.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">那样的月色</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">学习了，快慢指针  ，，弱弱的问一句：ABCDEDCBA 和ABCDDCBA 这两个都是回文，还是说只有后面一个是回文？  </div> <span class="time">2018-12-18</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">都是的</p> <p class="reply-time">2018-12-19</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/07/ea/b82fd545.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">abs</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">根据程序的局部性原理，最近的、将来要使用的数据和指令大多局限于正在使用的指令和数据，或存放于与这些指令数据临近的单元中。计算机就是基于这个原理把将要用到的数据替换缓存到cache中，所以访问数组中的一个元素，计算机可能把整个数组都给缓存，这样不需要多次访问主存，可以极大加速遍历等操作，由于使用链表存储的数据可以不是连续的，根据局部性原理设计的缓存就无用武之地了，造成链表中数据cache命中率低</div> <span class="time">2018-12-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Geek_04e22a</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">时间换空间:请求分页，请求分段<br>空间换时间:缓存技术<br><br>数组:简单易用，随机访问，借助CPU缓存，访问效率高<br><br>链表:支持动态扩容<br><br>LRU数组实现：<br>如果有，后移，放到首位<br>没有，够用，后移，放到首位<br>没有，不够用，删除末尾，后移，加到开始<br><br>回文算法:<br>单链表<br>一个快指针，寻找中间位置<br>慢指针，前半部分反序<br>时间复杂度：O(n)<br>空间复杂度：&#39;O(1)<br></div> <span class="time">2018-12-16</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-12-17</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Ben</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">&#47;&#47;约瑟夫问题 循环链表实现<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>struct Human {<br>	int		live;<br>	int		ID;<br>	struct Human	*next;<br>};<br>void printJosephus( struct Human *n, int count )<br>{<br>	int interval = 3;<br>	while ( count &gt; 0 )<br>	{<br>		if ( n-&gt;live == 1 )<br>		{<br>			interval = interval - 1;<br><br>			if ( interval == 0 )<br>			{<br>				n-&gt;live		= 0;<br>				interval	= 3;<br>				printf( &quot; %d &quot;, n-&gt;ID );<br><br>				count = count - 1;<br>			}<br>		}<br>		n = n-&gt;next;<br>	}<br>}<br><br>int main()<br>{<br>	struct Human	* head	= NULL;<br>	struct Human	* sec	= NULL;<br>	struct Human	* third = NULL;<br>	struct Human	* four	= NULL;<br>	struct Human	* fiv	= NULL;<br>	head	= (struct Human *) malloc( sizeof(struct Human) );<br>	sec	= (struct Human *) malloc( sizeof(struct Human) );<br>	third	= (struct Human *) malloc( sizeof(struct Human) );<br>	four	= (struct Human *) malloc( sizeof(struct Human) );<br>	fiv	= (struct Human *) malloc( sizeof(struct Human) );<br><br>	head-&gt;ID	= 1; head-&gt;live = 1; head-&gt;next = sec;<br>	sec-&gt;ID		= 2; sec-&gt;live = 1; sec-&gt;next = third;<br>	third-&gt;ID	= 3; third-&gt;live = 1; third-&gt;next = four;<br>	four-&gt;ID	= 4; four-&gt;live = 1; four-&gt;next = fiv;<br>	fiv-&gt;ID		= 5; fiv-&gt;live = 1; fiv-&gt;next = head;<br><br>	printJosephus( head, 5 );<br>}</div> <span class="time">2018-12-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/91/4c/32c9403c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">面朝大海</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">自己查了下快慢指针，觉着无论快慢指针都是要遍历整个链表的，那么块指针的遍历时间复杂度是logn吧？<br>我的思路是：<br>直接遍历全部链表，链表数据用stringbuffer存储，这样遍历完时间复杂度是O(n),然后字符串recover之后比较，但是，recover本身的复杂度应该就是O(n),这样总体时间是2n的遍历时间。</div> <span class="time">2018-12-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/c4/bd/72180435.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">融梨</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">链表不同于数组，链表的底层数据结构是一段不连续性的内存块，不像数组需要连续性的内存空间。链表，是一个个内存块通过后继指针连接下一个内存块。</div> <span class="time">2018-12-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/43/fd/69beb2af.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">陈悬高</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如何用单链表来实现 LRU 缓存？<br><br>*答案*：在 LRU 的链表实现中，链表节点按访问时间排序。当从链表缓存中访问节点时，该节点将成为最近访问的（MRU，Most Recently Used）节点。如果缓存已满，在插入新节点前，还需要删除最久以前访问的（LRU，Least Recently Used）节点。<br><br>单链表可以有两种排序方式：<br><br>1.  链表节点按访问时间从近到远排序：链表的头节点是最近访问的，链表的尾节点是最久以前访问的。在实现上，我们首先遍历链表来查找指定的节点，<br><br>	1. 如果该节点已存在，我们会将该节点移动到链表的头部：先删除该节点，然后将其插入到链表的头部。<br><br>	2. 如果该节点不存在，我们会直接将该节点插入到链表的头部。要注意的是，在插入新节点前需要检查缓存是否已满，如果缓存已满，那么需要先删除链表的尾节点。<br><br>2.  链表节点按访问时间从远到近排序：链表的头节点是最久以前访问的，链表的尾节点是最近访问的。在实现上，我们首先遍历链表来查找指定的节点，<br><br>	1. 如果该节点已存在，我们会将该节点移动到链表的尾部：先删除该节点，然后将其插入到链表的尾部。<br><br>	2. 如果该节点不存在，我们会直接将该节点插入到链表的尾部。要注意的是，在插入新节点前需要检查缓存是否已满，如果缓存已满，那么需要先删除链表的头节点。<br>	<br>如果链表节点按访问时间从近到远排序，在删除链表的尾节点时，还需要遍历链表找到倒数第二个节点并将其指 `null`。如果链表节点按访问时间从远到近排序，为了便于在链表的尾部插入，需要维护一个额外的指向链表尾节点的引用变量。<br><br>不管对链表采用哪种排序方式，我们都需要遍历链表来查找指定的节点。所以，缓存访问的时间复杂度都是 O(N)。</div> <span class="time">2018-12-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/8d/76/48529fb5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">-{Wo^0}</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，现在留言您还看的到吗？我看了您在GitHub上的代码，感觉在重复删除value链表的地方，不太严谨：<br>if (head != null &amp;&amp; head.data == value) {<br>           head = head.next;<br>           }<br>           Node pNode = head;<br>如果头节点的下一个节点值也时value怎么办？我是这样改的：<br>if (head != null)<br>      while (head.data == value)<br>             head = head.next;<br>if (head == null)return;<br>老师您看下，我这样写合适吗？<br></div> <span class="time">2018-12-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">泉</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">双向链表练习。<br>链表和数组对比。</div> <span class="time">2018-12-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/5b/ab/ce1f9a7f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Xiaoqi</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">Python Implementation: leetcode 234 palindrome-linked-list<br># Definition for singly-linked list.<br>class ListNode(object):<br>    def __init__(self, x):<br>        self.val = x<br>        self.next = None<br><br>class Solution(object):<br>    def isPalindrome(self, head):<br>        &quot;&quot;&quot;<br>        :type head: ListNode<br>        :rtype: bool<br>        &quot;&quot;&quot;<br>        def reverseList(root):<br>            pre = None<br>            cur = root<br>            while cur:<br>                tmp = cur.next<br>                cur.next = pre<br>                pre = cur<br>                cur = tmp<br>            return pre<br>            <br>        slow = fast = head<br>        while fast and fast.next:<br>            slow = slow.next<br>            fast = fast.next.next<br>            <br>        newHead = reverseList(slow)<br>        p1 = head<br>        p2 = newHead<br>        while p1 and p2:<br>            if p1.val != p2.val:<br>                return False<br>            p1 = p1.next<br>            p2 = p2.next<br>        return True</div> <span class="time">2018-12-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/6f/63/8808cc00.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">扬～</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">LRU有对应的实例代码吗？？？</div> <span class="time">2018-12-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/f0/57/205cef6e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">吴涛</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">想起一个之前遇到的问题，请教一下。我自己写过一个C语言的双向链表，存储的数据是一个short数组，当链表元素存满之后，存储新的元素时我选择的是把链表尾部的node解除前后指针挪到头部复用，达到节省内存的效果，但是实际应用中却数据出错了，当时没找到具体原因。最后解决办法是当链表存满后释放尾部的node，重新创建新的node放到头部，解决了问题。当时项目紧急就没深究原因了，现在学到这里，又想起来了，还请赐教！</div> <span class="time">2018-12-06</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">弄个循环链表可以解决吗</p> <p class="reply-time">2018-12-07</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/27/06/b38cdd37.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Brandon</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">五花八门的链表 ------<br>单链表：尾节点指向空<br>双向链表：更常用<br>循环链表：特点是到头结点方便，如约瑟夫问题<br><br><br>来历：克服连续空间有限的问题<br>特点：删除和插入块，但是定位删除和插入点应该也是查询操作；除了不需要连续空间，没有任何优势啊，对比数组来说<br>适合解决的问题：几乎没什么优势<br>实际应用：LRU就是一个队列，链表和数组都可以搞定<br><br>思考题：单链表翻转，^_^</div> <span class="time">2018-12-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/4d/de/2e1b989d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Kevin</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">从单向链表删除节点遍历的时候判断当前节点的next节点是不是要删除的元素就行了吧，不用再重新遍历一遍找</div> <span class="time">2018-12-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/c4/bd/72180435.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">融梨</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">既然是链表，那么要基于链表的知识来思考。链表有单链表，双链表，循环链表。答案在这三个中。你问我，什么是链表，我只能说它是一段不连续性的内存空间。</div> <span class="time">2018-12-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/14/3a/20/eefeb0e3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">chilion</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">感觉看评论能学习更多....</div> <span class="time">2018-12-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Geek_abf512</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">LRU通常使用双向链表LinkedHashMap实现，为什么老师解答单链表的插入模式？</div> <span class="time">2018-12-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">都可以的 建议继续看后面的章节 会有解答</p> <p class="reply-time">2018-12-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">X</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，对于有序链表按值查找，双向链表相对于单链表的优势是只需平均查找一半，这个表述不准确吧？平均查找一半是因为记录了上次查找的P这一做法带来的优化，而非双向链表！因为单向链表也可以记录上次的P！<br>1）假设被查找的数据一定在链表中，如果本次查找的值大于P即往后查，单双两者所需时间一样，如果小于P，单链表从头往后查，双向链表从P的前一个开始往前查，如果分布均匀的话，两个方向查找复杂度一样！<br>2）如果被查的不在链表中，那么大于P往后查两者时间依然一样，只有小于P时，单链表需要遍历所有，而双向链表只需遍历P以前的部分。</div> <span class="time">2018-12-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/0c/df/c94bf568.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">卡佩罗🍀</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">讲得很好 结合实际例子更好</div> <span class="time">2018-12-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/9e/b5/17ff83e6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Leo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表回文判断按照我的理解：<br>首先需要知道单链表如何反转。<br>其次需要知道如何查找单链表的中间结点。<br><br>先弄清楚这两个算法是如何实现的，之后再去看评论里面大佬们说的算法就会清楚多了。<br></div> <span class="time">2018-11-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">匆匆</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">链表总结<br><br>链表特点 ：1、线性表；2、内存可不连续<br><br>链表种类：单链表、循环链表、双链表、循环双链表；<br><br>链表和数组是两种优劣刚好相反的数据结构。数组的随机访问时间复杂度为O(1)，插入和删除的时间的时间复杂度为O(n)（因为需要遍历移动数组）,而链表则刚好相反。当然相反的是双链表。对于单链表则插入和删除也需要O(n),因为需要知道前一个节点的指针next，那就需要遍历查找。<br><br>以上说的链表删除节点其实有两种情况，一种是删除指定指针处的节点，那么时间复杂度O(1)；另一种是删除指定内容的节点，那么则需要遍历查找该内容，时间复杂度为O(n)；<br><br><br>PS：空间换时间的思想：双链表效率提高了，同时空间占用也增多了，其实是一种空间换时间的思想，很多设计中会用到类似的思想。<br><br>最后：实现LRU缓存淘汰法：将刚访问的内容进行遍历查找，如果缓存中存在，则将其删除，然后在添加新节点到头部；如果缓存中不存在，则直接添加新节点到头部，同时将尾部的节点删除；</div> <span class="time">2018-11-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/ec/8f/c7884530.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">🍏</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">写的太好了，留言质量高</div> <span class="time">2018-11-29</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/e9/0b/53bf91d3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">WL</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">11月28日:<br>把该讲内容总结为几个问题, 大家复习的时候可以先尝试回答这些问题检查自己的掌握程度:<br><br>	1. <br>单向链表, 循环链表, 双向链表, 双向循环链表的数据结构各是什么样的?<br>	2. <br>双向链表相比单向链表有什么特点?<br>	3. <br>链表如何实现插入, 删除, 和随机遍历等操作?<br>	4. <br>结合CPU, 内存与缓存分析链表和数组在性能上各自有什么特点? <br><br></div> <span class="time">2018-11-28</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/e9/0b/53bf91d3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">WL</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题:<br>把字符串拆成char[]放到双向循环链表里, 然后从头结点找到尾节点, 从头尾两个方法向中间遍历, 这样是不是也可以实现, 请老师指正.</div> <span class="time">2018-11-28</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/17/9d/a3706e4f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">饺子</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表<br>循环链表<br>双链表<br>数组 链表插入、删除、访问时间复杂度。<br></div> <span class="time">2018-11-27</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/6e/af/1c21e7d6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">不知不觉</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表的时间复杂度是O(1)?这个不对吧，遍历查找的时候如果考虑最坏情况，时间复杂度为O（n）吧</div> <span class="time">2018-11-27</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">兄弟 没看懂你说的啥啊</p> <p class="reply-time">2018-11-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">云学</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对于单向链表，在不知道前驱节点时也可以极快增删，只要交换后面2节点，参考《编程之美》《剑指offer》</div> <span class="time">2018-11-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ee/b6/f99db3e7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mr.Lee</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，有个问题想问一下，就是在链表删除操作中，删除给定指针的节点为啥要知道前一个节点？已经知道了，直接删除不就行了吗？</div> <span class="time">2018-11-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/8c/40/96fd39ce.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">特普特</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">LRU那段没看懂，请问清理缓存的意思是什么？是去掉链表之间的碎片吗？</div> <span class="time">2018-11-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/ba/78/bbf723ff.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">S</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题 ：设置两个指针 一个一次走一个单位 第二个一次走另个单位 每循环一次比较一次</div> <span class="time">2018-11-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/30/2b/bc5873c6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">对方正在输入</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">课后思考<br><br>1. 快慢指针找到链表中间位置节点<br>2. 将链表前半部入栈，然后在遍历后半部分时，将元素逐一弹出，进行比较<br>3. 处理链表的奇偶，如果为奇，跳过中间节点<br><br>请问老师这种快慢指针是不是最优解呢<br></div> <span class="time">2018-11-20</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">你的方法借助了栈 实际上可以在链表原地实现</p> <p class="reply-time">2018-11-21</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Edison.Chen</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">  老师，假如要插入或删除双向链表指定位置的结点，按理来说应该要先找到指定位置的结点，寻找指定结点的过程不需要遍历链表吗？</div> <span class="time">2018-11-20</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/8e/bf/996c3aa6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">格勒</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题应该说明，一，是否知道链表长度，二，是否可以对链表进行修改。</div> <span class="time">2018-11-19</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">这不是应试考试 你可以自己去假设的</p> <p class="reply-time">2018-11-20</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/37/d3/9febe49d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">smartzs</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对于再使用一个栈来存值的方法能看懂，而对上面的同学用指针移动直接反转链表的方法都没看懂 <br>class ListNode:<br>    def __init__(self, x):<br>        self.val = x<br>        self.next = None<br> <br>class Palindrome:<br>    def isPalindrome(self, pHead):<br>        if pHead == None or pHead.next == None:<br>            return True<br>        pslow = pHead<br>        pfast = pHead<br>        stack = [pslow.val]<br>        # 查找链表中心<br>        while True:<br>            # 奇数链，比较从后半部分第一个开始<br>            if not pfast.next:<br>                mid = pslow<br>                break<br>            # 偶数链，比较从后半部分第一个开始<br>            elif pfast and not pfast.next.next:<br>                mid = pslow.next<br>                break<br>            pslow = pslow.next<br>            pfast = pfast.next.next<br>            stack.append(pslow.val)<br>        # 回文对比<br>        print stack<br>        while stack and mid.next:<br>            tmp = stack.pop()<br>            if mid.val != tmp:<br>                return False<br>            print mid.val, tmp<br>            mid = mid.next<br>        return True<br>node1 = ListNode(1)<br>node2 = ListNode(2)<br>node3 = ListNode(3)<br># node4 = ListNode(3)<br>node5 = ListNode(2)<br>node6 = ListNode(1)<br>node1.next = node2<br>node2.next = node3<br>node3.next = node5<br># node4.next = node5<br>node5.next = node6<br>S = Palindrome()<br>p = S.isPalindrome(node1)<br>print(p)<br></div> <span class="time">2018-11-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">张三丰</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">一般单链表的头结点存储数据吗</div> <span class="time">2018-11-17</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">可以存 也可以不存。带头链表就不存储数据</p> <p class="reply-time">2018-11-20</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Edison.Chen</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，为什么双向链表在执行节点的插入与删除时，时间复杂度为O(1)，按理来说，在双向链表插入元素与删除元素，应该也要遍历链表的。</div> <span class="time">2018-11-17</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">能说下为什么要遍历吗。你是怎么理解的呢</p> <p class="reply-time">2018-11-20</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Geek_987169</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，使用git代码java-&gt;06_linkedlist-&gt;SinglyLinkedList.java测试序列int data[] = {1,2,3,3,2,1};结果为不是回文序列，请老师看下。</div> <span class="time">2018-11-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/7a/6e/2118909c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">杨旭</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于用单链表进行回文字符串判断时，有两种方法：<br>1) 快慢指针，时间复杂度O（n），空间复杂度O（1）<br>2) 复制一个逆序单链表，然后从表头比较，时间复杂度O（n），空间复杂度O（n）<br><br>如有问题，希望各位大牛指正。</div> <span class="time">2018-11-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/6c/23/833eb7f4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小糊涂仙丶</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">LFU最少使用策略是根据节点访问的次数来判断的：如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小，每次删除的都是访问次数最少的那个；<br>LRU最近最少使用策略是根据时间的纬度来的：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小，每次删除的都是最后那个没有被访问的</div> <span class="time">2018-11-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿U</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老哥 没太懂 链表实现lru缓存淘汰策略，文中说的当有一个新的数据被访问什么意思 ，从头遍历链表 那链表里存的是什么数据？ 不是要删除缓存中满了的数据么 这些数据是存在链表中? 为啥要把数据插到链表头部 从头部删?还有为啥越靠近链表尾部的节点越早被访问? 我这全篇看的都还能懂 最后一个算法思路直接给我说懵逼 </div> <span class="time">2018-11-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/e9/96/38f54972.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">ning~</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">大神，之前讲复杂度时，只详讲了时间复杂度，对于空间复杂度没怎么讲，空间复杂度怎么计算呢？</div> <span class="time">2018-11-15</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">空间复杂度比较简单 没那么多花样</p> <p class="reply-time">2018-11-15</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/86/59/e8f58a2a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">LAMBO</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">有个问题不是很明白。<br>数组和链表要增删元素，不都要先找到该元素然后再增删元素吗？<br>数组根据寻址公式O(1)就能找到该元素，增删需要移动元素所以为O(n)。<br>链表想要增删某元素，也要先找到它O(n)，然后增删元素O(1)，根据加法原则不是O(n)吗？为什么说链表增删元素只要O(1)？</div> <span class="time">2018-11-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/bf/0e/eae05ad9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">我们都是大好青年🙌</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师您好，我想问下python中链表是如何存在的呢？</div> <span class="time">2018-11-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿官(^･ｪ･^)</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题思路：<br>1、顺序读取列表内容，得到串str1; 时间复杂度O(n)<br>2、获取反向列表 reverseList （思路：保存前驱pre和后继next两个结点，循环遍历列表，改变当前结点cur.next指针的方向为pre) 此处时间复杂度O(n)，并输出反向列表的内容，得到串str2<br>3、比较str1.equals(str2) 此处时间复杂度为 O(1)<br>最终得出用单向列表存储文符串，判断是否为回文串的时间复杂度为O(n).</div> <span class="time">2018-11-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/59/12/2034b163.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">五花肉小生</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如何利用数组实现 LRU 缓存淘汰策略呢？<br><br>使用数组实现一个循环队列，这样可以省去数据搬移的操作，缓存的存入与删除就对应着队列的出队与入队。</div> <span class="time">2018-11-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">cw</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回文串问题：用双向链表数据结构放字符串，每个节点只放一个字符。从头节点往后遍历与尾节点往前便利结果相同</div> <span class="time">2018-11-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">剑影梦残</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">笔记：<br>1.快慢指针定位中间<br>2.逆序前或者后半段，再循环比较，判断回文<br>3.时间跟空间的互换</div> <span class="time">2018-11-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">spark</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回头复习下，之前没做课后思考题，现在补上代码，注释写的比较详细了。希望可以帮助不好理解的同学<br>public class Node&lt;T&gt; {<br>    Node next = null;<br>    T data;<br>    Node(T data){<br>        this.data = data;<br>    }<br>}<br>public static boolean isHuiwen(Node&lt;String&gt; A){<br>    Node&lt;String&gt; fast = A;<br>    Node&lt;String&gt; slow = A;<br>    while(fast.next!=null &amp;&amp; fast.next.next!=null){<br>        fast = fast.next.next;<br>        slow = slow.next;<br>    }<br>    Node&lt;String&gt; head = slow.next;<br>    &#47;&#47;翻转Node过程<br>    Node&lt;String&gt; headNext = null;&#47;&#47;保存当前节点的下一个节点<br>    Node&lt;String&gt; pre = null;&#47;&#47;保存当前节点的前一个节点<br>    while(head!=null){<br>        headNext = head.next;<br>        head.next = pre;&#47;&#47;当前节点的下个节点指向前一个节点<br>        pre = head;&#47;&#47;将当前节点保存起来<br>        head = headNext;&#47;&#47;当前节点向后移动<br>    }<br>    &#47;&#47;对比过程<br>    Node&lt;String&gt; n1 = pre;<br>    Node&lt;String&gt; n2 = A;<br>    while(n1!= null){<br>        if(!n1.data.equals(n2.data)){<br>            return false;<br>        }<br>        n1 = n1.next;<br>        n2 = n2.next;<br>    }<br>    return true;<br>}</div> <span class="time">2018-11-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/23/ed/a4a774a8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">What for</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">判断一个字符串是不是回文串，为什么要用快慢指针找中点呢，既然给定了字符串，那长度应该是已知的吧？求老师解惑～</div> <span class="time">2018-11-06</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">也不一定知道长度啊</p> <p class="reply-time">2018-11-08</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/90/c0/0b66a81b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">胡升权</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，您好，我是一名刚学习数据结构的初学者，老师，有些代码您看能不能给点注释，这样也好让我们这些初学者能够更好的理解</div> <span class="time">2018-11-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">嗯嗯 👌</p> <p class="reply-time">2018-11-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/8e/c7/f05f9fd0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">leleba</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">别的同学用快慢指针，用数组空间复杂度是不是O(n)？<br><br>1遍历单链表取数组长度<br>2再遍历单链表拷贝到数组中<br>3用数组对比首尾是不是相等来判断是不是回文<br><br>谢谢老师</div> <span class="time">2018-11-02</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d6/2f/b3090d20.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">吴昊</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">引入hash表将缓存访问的时间复杂度降为O(1)<br>===================================<br>如果是单链表实现的缓存，即使有hash，时间复杂度也不是O(1)吧？<br>不命中缓存的情况下，插入链表头节点的时间复杂度是O(1)，命中缓存的情况下，调整链表节点顺序的时间复杂度是O(n)，因为需要遍历链表找到被命中节点的前节点，才能完成被命中节点前后的拼接工作。</div> <span class="time">2018-11-01</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">20节中会讲</p> <p class="reply-time">2018-11-02</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">傲</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">https:&#47;&#47;leetcode.com&#47;problems&#47;palindrome-linked-list&#47;<br>使用递归，依次判断两头的节点是否相等：<br>class Solution {<br>    private ListNode tmp;<br>    <br>    public boolean isPalindrome(ListNode head) {<br>        tmp = head;        <br>        return check(head);<br>    }<br>    <br>    public boolean check(ListNode node){<br>        if(node == null){<br>            return true;<br>        }<br>        boolean result = check(node.next);<br>        boolean equals = (tmp.val == node.val); <br>        tmp = tmp.next;<br>        return result &amp;&amp; equals;<br>    }<br>}<br>时间复杂度:O(n)<br>空间复杂度:O(1)</div> <span class="time">2018-10-30</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">allean</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">有一点疑问：链表的插入删除时间复杂度为O(1)这个应该针对性的讲吧?<br>1.单向链表的插入删除时间复杂度是O(n),<br>2.双向链表的时间复杂度为O(1)</div> <span class="time">2018-10-28</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我不是也是这么讲的吗？</p> <p class="reply-time">2018-10-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/9d/9a/42f98193.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">芒果</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">打扰一下，请求您帮我解决一下困扰我好几天的困惑(இдஇ; )，在单链表头插中，为什么是newNode.next = head;head = newNode;而不是，newNode.next=head.next;head.next=newNode.真的请你帮忙解答一下，感谢！</div> <span class="time">2018-10-28</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">head本身是一个节点 你的方法是将数据插到head所指节点的后面</p> <p class="reply-time">2018-10-29</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">太空土豆</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">最近很忙好久没来。赞一个。数组与链表优缺点分析很到位。</div> <span class="time">2018-10-26</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/0c/c2/310f15a4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Geek_zy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师有一个疑问 循环链表一定比不循环链表好吗  他有什么缺点呢 先对于 不循环的链表</div> <span class="time">2018-10-26</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">没有好坏 实际上循环链表不怎么常用 你知道概念就好了</p> <p class="reply-time">2018-10-28</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJibr1EW9cGq5zRX7V0Arn21wXldy9cPWpL7lUzyrqLeuLQgCC0icvZziaIOJ8nxWibOmuawhxevcfUNg/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">王</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组如果不通过下标查询 而是通过遍历来查询的话是否代表着除了因为CPU缓存而比链表快在未排序的情况下 时间复杂度都是O(n) ，目前一般真实开发中更多的是通过遍历未排序的数组来查询数组里数据进行判断，那给我的感觉真实开发中数组和链表查询性能没有想象中差距那么大</div> <span class="time">2018-10-25</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">小规模数据确实没啥差别</p> <p class="reply-time">2018-10-26</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/a0/4f/33a7e39c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">msupercoder</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">最少使用策略和最近最少使用策略的区别是什么？为什么觉得老师讲这个应该是最近使用策略？老师讲这个LRU感觉没有“最少”这个属性呀？</div> <span class="time">2018-10-25</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/73/63/fdeeb315.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">alex</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">        String input = &quot;qwertyuioppoiuytrewq&quot;;<br>        LinkedList&lt;String&gt; l = new LinkedList&lt;String&gt;();<br><br>        for (String b : input.split(&quot;&quot;)) {<br>            l.add(b);<br>        }<br>        if (l.size() % 2 != 0) {<br>            System.out.println(&quot;no&quot;);<br>        }<br>        int mid = l.size() &gt;&gt; 1;<br>        boolean flag = true;<br>        while (mid != 0) {<br>            if (!l.get(mid - 1).equals(l.get(l.size() - (mid - 1) - 1))) {<br>                flag = false;<br>                break;<br>            }<br>            mid--;<br>        }<br><br>        if (flag) System.out.println(&quot;yes&quot;);<br>        else System.out.println(&quot;no&quot;);</div> <span class="time">2018-10-24</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d7/5f/428a79e3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">谢帅</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">Java实现回文判断<br><br>public class Node&lt;T&gt; {<br>    Node next = null;<br>    T data;<br><br>    Node(T data) {<br>        this.data = data;<br>    }<br>}<br><br>&#47;**<br>     * 用链表校验是否为回文<br>     * @param node<br>     * @return<br>     *&#47;<br>    public static boolean isHuiWen(Node&lt;String&gt; node) {<br>        Node&lt;String&gt; fast = node;<br>        Node&lt;String&gt; slow = node;<br>        while (fast.next != null &amp;&amp; fast.next.next != null) {<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        }<br>        slow = fanZhuanNode(slow);<br>        while (slow.next != null) {<br>            if (slow.data.equalsIgnoreCase(node.data)) {<br>                slow = slow.next;<br>                node = node.next;<br>            } else {<br>                return false;<br>            }<br>        }<br>        return true;<br>    }<br><br>    &#47;**<br>     * 反转链表指针<br>     * @param slow<br>     * @return<br>     *&#47;<br>    public static Node fanZhuanNode(Node&lt;String&gt; slow) {<br>        Node&lt;String&gt; pri = slow;<br>        Node&lt;String&gt; now = slow.next;<br>        while (now != null) {<br>            Node&lt;String&gt; next = now.next;<br>            now.next = pri;<br>            pri = now;<br>            now = next;<br>        }<br>        slow.next = null;<br>        return pri;<br>    }</div> <span class="time">2018-10-24</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">懒猫</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">为什么需要前一半或后一半反转呢，直接从头结点遍历到中间节点，再从中间节点遍历到尾节点，遍历的时候两两比较，应该就能得出结果吧</div> <span class="time">2018-10-23</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d4/b5/b72b83f8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小小鹿</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">弱弱问一下，java 版本 SinglyLinkedList 里 静态类Node里声明私有对象成员mData 和 mNext 是不是一个语法错误唉？</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">懒猫</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我想问，为什么非要反转链表呢，找到中间节点后，头结点往中间遍历，中间往表尾遍历，两个比较，难道不行吗</div> <span class="time">2018-10-22</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">godtrue</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">阅后留痕<br><br>1：链表——这种数据结构的特点如下<br>1-1）线性表结构，元素之间有前后关系，逻辑结构上相邻<br>1-2）通过指针关联，元素之间在物理内存上是割裂的或者不连续的<br>1-3）和数组非常的相像区别在于，数组在逻辑和物理上元素之间都是连续，链表的元素则在逻辑上有连续的物理上则是不连续的，链表采用了以空间换时间的改进策略，至少在元素的删除和插入操作上可以这么认为，不需要移动数据只需要改变指针的指向，另外就是能够充分利用零碎的内存空间<br><br>2：链表的分类，主要通过指针的前后指向和尾指针的指向这两个维度的特点来分类的<br>2-1）单向链表<br>         体育课上，同学们排成一列，全部面向南向，都用左手搭在前面一位同学的肩上的样子，最后一位同学除外<br>2-2）双向链表<br>         体育课上，同学们排成一列，全部面向南向，都用左手搭在前面一位同学的肩上，<br>都用右手搭在后面一位同学的肩上的样子，第一位同学的右手和最后一位同学的左手除外<br>2-3）单向循环链表<br>         体育课上，同学们排成一列，全部面向南向，都用左手搭在前面一位同学的肩上的样子，最后一位的左手搭在了第一位同学的肩上<br>2-4）双向循环链表<br>         体育课上，同学们排成一列，全部面向南向，都用左手搭在前面一位同学的肩上，<br>都用右手搭在后面面一位同学的肩上的样子，第一位同学的右手搭在最后一位同学的肩上，最后一位同学的左手搭在第一位同学的肩上<br><br>同学的左手，类似指向下一个元素的指针<br>同学的右手，类似指向上一个元素的指针<br>构成循环与否的关键在于尾元素指针的指向<br><br>3：结构决定功能，所以，和数组相比，链表查询较耗时，插入和删除则性能较好，不过也要看插入和删除的位置的，如果必须以查询为前提，则总体性能也一般，则其最大的优势在于天然支持动态扩容<br>数组和链表的时间复杂度比较，如下所示<br>               数组   链表<br>插入删除  O(n)   O(1)<br>随机访问  O(1)   O(n)<br><br>4：空间换时间，是性能优化的一种重要思路，缓存机制应用的非常广泛，他是典型的使用空间换时间的实现方案，当然，缓存的空间也是有限的，如果缓存满了，该怎么办？那只能淘汰一些缓存的内容呗！淘汰那些内容呢？目前思路有三种，一是先进先出，二是最少使用先出，三是最近最少使用先出<br>当然，如果空间紧张，也可以采用时间换空间的思路来解决问题<br><br>5：算法是基于数据结构来讲的，毕竟对于数据而言，无非是增删改查四种操作，排序也主要是为了更快的查找，毕竟对于数据而言，查询的需求一般总是比其他的操作要更多的，使用不同的数据结构存储数据是视具体的业务场景来说，看看哪种更能满足或者符合我们的也许需要，所谓的符合业务操作，我认为就是我们想要的操作，选择对了对应的数据结构后会操作的更加得心应手和高效，高效性是常常我们的需求核心。<br><br>6：最后的思考题，如果限定只能使用单向链表，则其他同学的回答我认为非常好，我目前没有相出更好的法子，思路这里记上一笔<br>6-1）定位中心，快慢指针的方式<br>6-2）逆转部分链表，前后都应该可以<br>6-3）对比，看看是否为回文<br>6-4）回复原状<br>回文，奇偶的例子都比较容易造，比如：AA,ABA</div> <span class="time">2018-10-21</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/49/20/33bca37a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">turbopan</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师您好，在进行数组的插入删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，您这句话，我用java写了个demo，您说的数组插入是指数组空间不够了，重新开辟了一块内存空间么？为什么会大量的数据搬移呢？删除的话 我也不理解，a{1,2,3,4}，我将a[2]置成null,然后打印a[3]还可以打印出来呢，数据搬移指的是？求解</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/43/29/30a132f8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">　　　　　　　　</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">其实如果讲解的时候配上代码就完美了</div> <span class="time">2018-10-19</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ef/e8/076a6f59.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">张翀</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">学习了数组与链表的时间复杂度区别，<br>LRU最近最少使用策略实现的缓存，数据结构采用双向链表，数组也能实现同样的功能。<br>回文字符串问题如果采用单向链表解决，可以首先分为前后两半部分两个链表A，B，然后将后半部分B首尾颠倒成B1，再顺序比较A，B1，时间复杂度O(n)</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">朝夕心</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">今日所学：<br>单链表、循环链表、双向链表、双向循环链表<br>单链表通过一个指针指向下一个节点的地址。这样存储数据的内存空间可以不连续，不需要分配一整块「大」内存<br>链表适合增删、数组适合随机访问<br>如何选择用哪种链表：时间换空间的思维<br>双向链表访问指定「指针」的效率优于单向链表<br>LRU 最近用的数据存到链表头，删掉链表尾的数据。如果数据在链表中存在，这直接将该数据放到链表头<br>选用链表作为缓存的优势：数据频繁被使用，链表中已经缓存了最近用的，可能头几个节点就是要查找的数据（查找的最好复杂度O(1)，替换节点的复杂度O(1))<br>使用数组做LRU，即使是数组中存在缓存数据，也会造成O(n)移动数据造成的问题<br></div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/4f/6e/c8862883.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">水雕歌</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">func isPalindrome(head *Node)  bool {<br>	var slowOld *Node = nil<br>	slow, fast := head, head.next<br>	if fast == nil {<br>		return true<br>	}<br><br>	var isEven bool<br>	&#47;&#47; find middle<br>	for true {<br>		if fast.next == nil {<br>			isEven = true<br>			break<br>		}<br>		if fast.next.next == nil {<br>			isEven = false<br>			break<br>		}<br><br>		fast = fast.next.next<br><br>		&#47;&#47; next and reverse<br>		tmp := slow<br>		slow = slow.next<br>		tmp.next = slowOld<br>		slowOld = tmp<br>	}<br><br>	var slowNext *Node<br>	if isEven {<br>		slowNext = slow.next<br>	} else {<br>		slowNext = slow.next.next<br>	}<br><br>	ret := true<br>	for true {<br>		if slow.val != slowNext.val {<br>			ret = false<br>		}<br><br>		if slowNext.next == nil {<br>			break<br>		}<br><br>		slowNext = slowNext.next<br><br>		&#47;&#47; next and reverse<br>		tmp := slowOld<br>		slowOld = slowOld.next<br>		tmp.next = slow<br>		slow = tmp<br>	}<br><br>	return ret<br>}</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/2c/9d/e5af3fd4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Novapath ☀</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">一、链表<br>1.链表是一种线性表；<br>2.从内存结构来看，链表的内存结构是不连续的内存空间，通过“指针”把一组零散的内存块串联起来，从而进行数据存储的数据结构；<br>3.链表中的每一个内存块被称为节点N。节点除了存储数据外，还需记录链上的下一个节点的地址，叫作后继指针next。<br><br><br>二、链表的特点<br>1.插入、删除数据效率高，时间复杂度为O(1)，只需更改指针指向即可；随机访问效率低，因为为非连续存储，需要从链头至链尾进行遍历，时间复杂度为O(n)。<br>2.链表数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。<br><br>三、常用链表：单链表、循环链表和双向链表<br>3.1 单链表<br>1）每个节点只包含一个指针，即后继指针。<br>2）单链表有两个特殊节点，即首节点和尾节点。头结点记录链表基地址，为节点指向一个空地址NULL。<br>3）性能特点：插入和删除节点的时间复杂度为O(1)，查找的时间复杂度为O(n)。<br><br>3.2 循环链表<br>1）除了尾节点的后继指针指向首节点的地址，其他与均与单链表一致。<br><br>3.3 双向链表<br>1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。<br>2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。<br>3）性能特点：和单链表相比，存储相同的数据，需要消耗更多的存储空间；插入、删除操作比单链表效率更高。<br><br>i. 以删除操作为例，删除操作分为2种情况：删除特定值的节点，删除指针指向的节点。<br>前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。<br>第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br><br>ii.对于一个有序链表，双向链表的按值查询效率要比单链表更高。可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br><br>3.4 双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。<br><br>四、链表和数组性能比较<br>4.1 插入、删除和随机访问的时间复杂度<br>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂度是O(n)。<br><br><br>4.2 数组缺点<br>1）大小固定，声明了一个数组，就回去申请占用连续的内存空间，可能系统没有足够的连续的内存空间分配；<br>2）声明的数组过小，则需要申请更大的内存，把原数组拷贝进去，操作非常的耗时。<br><br>4.3 链表缺点<br>1）内存空间消耗更大，链表需要额外的空间存储指针信息；<br>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片。<br><br>4.4 链表，数组选择<br>1.链表和数组的（增删查）时间复杂度正好相反。<br>2.数组使用连续的内存空间，可以借助缓存机制提高效率；链表不连续，所以无法借助CPU缓存机制。<br>3.数组大小固定，当要申请更大的空间，需要拷贝数据，很耗时；链表则支持动态扩容。<br>4.相对来说链表比较耗内存，因为需要记录节点指针，内存消耗翻倍。<br><br>五、缓存及链表的应用<br>5.1 缓存<br>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。<br>5.2 缓存的特点<br>缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留，这就有一个优先顺序，则需要用到缓存淘汰策略。<br>5.3 缓存淘汰策略<br>常见的三种策略：先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。<br>5.4 链表实现LRU缓存淘汰算法<br>1.缓存数据在链表中：遍历得到数据对应节点并删除，插入到链表头部，时间复杂度为O(n)。<br>2.缓存数据不在缓存链表中：<br>i.缓存充足，将节点插入链表头部，时间复杂度为O(1)<br>ii.缓存不足，删除链表的尾节点，将新的数据插入链表头部，时间复杂度为O(1)。<br><br>五、设计思想<br>对于执行慢的程序--&gt;空间换时间<br>对于消耗内存多的程序--&gt;时间换空间<br><br>六、课后思考<br>Q.：如何通过单链表实现判断字符串是否为回文字符串？<br>A：倒序输出链表，与原链表进行比较，时间复杂度为O(n)。<br>同学的答案：1 快慢指针定位中间节点 2 从中间节点对后半部分逆序 3 前后半部分比较，判断是否为回文 4 后半部分逆序复原。<br></div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/80/67/abb7bfe3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">涂海生</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">针对删除给定指针指向的结点， 单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要0(1),这个是指删除耗时吧，找到指定的结点，耗时都要O(n)</div> <span class="time">2018-10-18</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/f5/98/fd56adc4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">耿旭涵gg</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">提个意见git代码里最好带一些详细的注释，有的方法都不知道干什么用的，还需要看完了之后才明白 </div> <span class="time">2018-10-18</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👌</p> <p class="reply-time">2018-10-18</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f8/3a/45a21606.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">万利</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">有个疑问…实际项目中虽然说，链表插入和删除效率高…其实都是之前要查找的…所以整体复杂度和属于，应该是一样的对么？</div> <span class="time">2018-10-18</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">没怎么看懂你说的呢</p> <p class="reply-time">2018-10-18</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/58/25/5937fa4d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">何言何语</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">确实讲的通俗易懂，之前看别人视频 感觉都是懵的，现在清晰了很多</div> <span class="time">2018-10-17</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/ff/b3/a236be3c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">CrazyGoMan</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">你们好厉害，都知道使用快慢指针的思路来做</div> <span class="time">2018-10-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/03/f8/f98df0a7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">vaccywen</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">redis的linkedlist数据类型就是采用双向链表数据结构实现的，用空间换时间。</div> <span class="time">2018-10-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/2d/15/8ed0ba3f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小奇</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">留言的很都好厉害👍，文中学习到很多东西，看评论中也长了好多知识</div> <span class="time">2018-10-16</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/c0/80/0c92e0b8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">saikida</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师您好，突然想到，我们平常通过变量名来访问内存中的变量值，那么这个访问过程的时间复杂度是O(n)吗？访问变量过程是否跟访问单向链条一样需要遍历查找？谢谢</div> <span class="time">2018-10-16</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">变量如何访问要看 编译器的设计了</p> <p class="reply-time">2018-10-16</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">djane</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">【笔记】<br>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 （LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。<br><br>一、五花八门的链表结构<br>1、链表通过指针将一组零散的内存块串联在一起。把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。<br>把这个记录下个结点地址的指针叫作后继指针 next。<br>把第一个结点叫作头结点，把最后一个结点叫作尾结点。头结点用来记录链表的基地址。<br>2、最常见的链表结构：单链表、双向链表、循环链表、双向循环链表。<br>1）尾结点特殊的地方：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。<br>链表的存储空间不是连续的。它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。<br>2）双向链表，支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br>如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。<br>3）循环链表是一种特殊的单链表。跟单链表唯一的区别就在尾结点。循环链表的尾结点指针是指向链表的头结点。<br>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。<br>3、用空间换时间的设计思想。<br>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。<br>对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。<br><br>二、链表 VS 数组性能大比拼<br>1、数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。<br>2、数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。<br>3、如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。<br><br>三、如何基于链表实现 LRU 缓存淘汰算法？<br>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。<br>1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。<br>2. 如果此数据没有在缓存链表中，又可以分为两种情况：<br>如果此时缓存未满，则将此结点直接插入到链表的头部；<br>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。<br><br><br>【习题】<br>回文字符串：一个正读和反读都一样的字符串，比如“level”或“noon”等。<br>1、遍历字符串，从后往前取值，组成一个新的字符串，比较原字符串和新字符串是否一致。<br>2、遍历字符串，判断字符串从前往后读和从后往前读的值是否一一对应。<br><br>（感觉偏题了，没用到单链表的存储方式。看到评论区回答挺好的，搬运下他思路。不过还是不太清楚具体该怎么实现。）<br>1 快慢指针定位中间节点（这里要区分奇偶情况）<br>1.1 奇数情况，中点位置不需要矫正<br>1.2 偶数情况，使用偶数定位中点策略，要确定是返回上中位数或下中位数<br>1.2.1 如果是返回上中位数，后半部分串头取next<br>1.2.2 如果是返回下中位数，后半部分串头既是当前节点位置，但前半部分串尾要删除掉当前节点<br>2 从中间节点对后半部分逆序，或者将前半部分逆序<br>3 一次循环比较，判断是否为回文<br>4 恢复现场</div> <span class="time">2018-10-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">梅坊帝卿</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这个快慢指针的想法真是赞 我的直接想法是来一个栈 这样空间复杂度是o(n) 不如快慢方案的o(1) 另外虽然两者都是同样量级的时间复杂度 但栈的常数系数会小一点 不知理解的对否。</div> <span class="time">2018-10-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/13/ae/cdd8a129.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">canoejun</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不知道这样子思考对不对。采用牺牲空间换取时间。<br>首先采用一个循环双向链表，在循环里，一个从头开始，一个从尾开始，循环条件为遍历的两个指针地址不相等。循环体判断结构体的值是否相等。中间若有不同，退出循环结束，否则就是回文。<br>时间复杂度为o(n) </div> <span class="time">2018-10-15</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/dd/d7/8faa8bde.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">子 非 </span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">每次认真读完文章和留言，都受益匪浅</div> <span class="time">2018-10-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d7/fb/384ef0a1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">黑桃K</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">总结：<br>几种链表，单向，双向，循环，双向循环，以及双向体现的，空间换时间思想<br>链表和数组，数组缺点，大小固定，申请过大过小带来的问题，但在cpu缓存读取更快<br>lru缓存淘汰算法，实现思路，头结点表示最新使用的。在链表，放入头，不在，放入头或删除尾放入头<br>思考题：<br>lru数组实现，评论中有队列，有普通实现<br>单链表判断回文，快慢指针，逆序，判断，复位。后续要重新实现下代码到我的github，再消化下这篇</div> <span class="time">2018-10-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">张三丰</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。  除了时间复杂度还有什么因素？</div> <span class="time">2018-10-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">kakasi</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">链表: 线性表数据结构，不连续的存储空间，插入、删除时间复杂度为O（1），而查找为O（n），特点与数组相反。单链表，双向链表，循环链表，双向循环链表，其中单链表和双向链表较常用。<br><br>其实链表的插入、删除真正意义上并不是O（1）。一般有两种情况: 1. 删除「与给定值相等的值」。这个时候无论是单链表还是双向链表都要用O（n）来查找，然后再删除。2. 删除「给定结点」，这个时候单链表要重新查找到这个节点的前结点然后执行删除，而双向链表直接可以拿到前结点，是真正意义的O（1）。因此实际运用中还是双向链表最多，不过这个是采用了空间换时间的方式，一般来说空换时或时换空都是视情况而定的。<br><br>LRU缓存算法（最近最少使用）: <br>1. 用链表实现方式。当数据已经在链表中时，将那个数据移到头部；当数据不存在，如果缓存链表没满直接添加到头部，如果满了就删除最后一个结点然后添加到头部。<br>2. 数组实现方式: 当数据已经在数组中时，将那个数据移到数组尾部；当数据不存在，如果缓存数组没满直接添加到尾部，如果满了就删除第一个元素，然后添加到尾部。<br>3. 散列表方式等待老师的讲解。<br><br>单链表实现回文姑且记录下: 用快慢指针找到中点，前半部分逆序，直接对比两部分。</div> <span class="time">2018-10-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">kakasi</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，虽说知道阅读，输出，实战是整个学习的方法，但是实战方面能给出一道对应的编程题吗？看完之后花个20来分钟的题能巩固知识，感觉这些题目不好找。</div> <span class="time">2018-10-14</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">leetcode上有的</p> <p class="reply-time">2018-10-14</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">qinggeouye</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">一、利用数组实现 LRU 缓存淘汰策略<br><br>利用数组实现 LRU 缓存淘汰策略：<br><br>维护一个有序数组，越靠近数组尾部元素是越早之前访问的。当有一个新数据被访问，从数组起始位置开始遍历数组：<br><br>1、如果该数据之前已经被缓存在数组中，则遍历数组得到该数据对应的位置，并将其从原来的位置删除，将这个位置前面的数组元素依次向后搬移一位，再把这个数据插入到数组的第一个位置。<br><br>2、如果该数据没有在缓存数组中：<br><br>- 若缓存未满，则将数组元素依次向后搬移一位，把这个数据插入到数组的第一个位置<br>- 若缓存已满，则删除数组中最后一个元素，搬移数组元素，插入新数据到数组的第一个位置。<br><br><br>二、如何判断一个字符串是否是回文字符串<br><br>问：字符串通过单链表存储，如何判断字符串是一个回文串？<br><br>1、定义两个指针：快指针 fast、慢指针 slow。<br><br>2、每次，快指针前进两步即 fast.next.next ，慢指针前进一步即 slow.next ；<br><br>3、慢指针每前进一步，取得到达链表结点的 next 指针，同时改变到达链表结点的 next 指针的指向，使链表前半部分反序；<br><br>4、快指针到达链表尾结点时，慢指针即到达链表中间结点，此时再定义一个新指针从链表中间结点往回走，而慢指针继续向后走，但不改变链表后半部分结点中next指针的指向；<br><br>5、新指针与慢指针每前进一步，比较它们所指向的值，判断是否相等；同时，新指针每前进一步，改变到达链表结点的 next 指针的指向，使链表前半部分再次反序；<br><br>如有不正确，还请老师指正，谢谢~</div> <span class="time">2018-10-14</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELtOO0HKrj5SI5JSlmwiaCvaF6GLiaTmf5NX88OZaO3HymTAGTeIoicBUjqzmMF6sF5raPFjuqLFibrrw/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">gesanri</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于双向循环链表那个手画的图有点没明白，中间的节点都是前面节点的next指向后面节点的prev，后面节点的prev指向前面节点的next，但首尾节点的prev和next却指向的是对方的data，不太明白这里首尾节点的特殊性</div> <span class="time">2018-10-13</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">关注的点有点跑偏了，不管是哪个节点，prev和next都是指向结点，既不是data也不是prev&#47;next</p> <p class="reply-time">2018-10-14</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d6/7b/7035a4f7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">空白</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">最上面的大佬说的东西,怎么看着很像计算机组成原理 里面的存储的部分。 不是很明白的可以看一看计算机原理哦</div> <span class="time">2018-10-13</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/02/33/57678ea3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">鹏程万里</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">文中的头结点是不是有歧义？真正的头结点是没有意义，也不存放数据的，文章图中应该指的是第一个元素结点吧？</div> <span class="time">2018-10-12</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">头结点为啥没意义呢？好像你理解的跟我理解的有点不一致。</p> <p class="reply-time">2018-10-13</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">feifei</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">使用单链表来判断是否为回文串，我的思路是这样子的<br>遍历，从链表的尾部移除字符串，然后还有一个索引从链表头开始读取，再进行比较，<br>如果发现首尾不相等，则直接判断返回false<br>一直到遍历结束，都能相等，则说明为回文串<br><br>我的这个实现代码，由于是单链表，未经优化，时间复杂度为O(N*N),但空间复杂度占用为O(N),即字符串点用链表的空间，<br>以下是我实现的回文串判断代码，<br>https:&#47;&#47;github.com&#47;kkzfl22&#47;datastruct&#47;blob&#47;master&#47;src&#47;test&#47;java&#47;com&#47;liujun&#47;datastruct&#47;linkedlist&#47;StrCheck.java<br>其他为自己实现的单链表的代码<br><br>希望得到老师您的指正，谢谢</div> <span class="time">2018-10-12</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">你的思路的时间、空间复杂度都有点高，你再想想有改进方法吗</p> <p class="reply-time">2018-10-13</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">曾经瘦过</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组实现LRU 思路 <br>1.创建一个数组 <br>2.再插入数据时候查找数组中是否存在该数据，如果存在将该数据和数组0下标的数据进行兑换<br>3.如果不存在则在数组头部插入数据（头部数据替换到空余数组位置）<br>4.如果数组满了，并且数组中不存在删除数组尾部数据，在数组头部插入<br><br>感觉可能实现起来有点麻烦，暂时的一个思路，也可以通过数组+指针的方式实现</div> <span class="time">2018-10-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/ec/98/834a8a9f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">黑boy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">之前面试被问到链表的随机访问问题，我回答的也是散列，嘻嘻。</div> <span class="time">2018-10-12</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/c0/80/0c92e0b8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">saikida</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">评论比正文还精彩👍</div> <span class="time">2018-10-11</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Monday</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1、如何用数组实现LRU缓存淘汰策略：<br>维护一个有序的数组a，越靠近数组尾部的元素是越早访问的。<br>1）当前访问数据在缓存中，遍历数组将当前数据对应元素item前的元素后移一位，并将item放入0位置。<br>2）当前访问数据不在缓存，又分为两种情况<br>2.1）缓存未满，则将当前数组所有元素后移一位，再将当前数据对应元素放入a[0]。<br>2.2）缓存满了，先删除数组最后一个元素删除，然后把数组所有元素后移一位，最后将当前数据对应元素放入a[0]。<br><br>2、思考题：<br>方案一<br>1）遍历链表将元素放入数组A中<br>2）利用数组随机访问特性，分别从头和尾往中间遍历，并将元素进行比较，直到有元素不相等或者数组A的中点结束。<br>此方案的空间复杂度为O(n）。<br>方案二<br>1）快慢两个指针定位链表中点，同时逆序前半部分链表<br>2）已逆序的前半部分与后半部分进行比较<br>3）再次逆序前半部分链表<br>此方案的空间复杂度为O(1)。</div> <span class="time">2018-10-11</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/d0/d7/a09ef784.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Tattoo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">LRU 的淘汰规则是基于访问时间，而 LFU 是基于访问次数的 。所以作者說的是正確的．</div> <span class="time">2018-10-11</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/9d/9a/42f98193.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">芒果</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组和链表各有利弊，它们插入、删除与随机访问操作的时间复杂度正好相反，链表支持动态扩容，这也是它与数组最大的区别。</div> <span class="time">2018-10-11</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">拔剑四顾心惘然</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单向链表回文判断代码： https:&#47;&#47;github.com&#47;guyuqi&#47;yuqi-repo&#47;blob&#47;master&#47;palindrome&#47;palindrome.c</div> <span class="time">2018-10-11</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/83/b7/dded0fe8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">范特西</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表判断回文：思路(比较low,😂)<br>遍历组装两个<br>While<br>   String1=string1+value<br>   String2=value+string2<br>最终判断两字符串是否相同。<br>时间复杂度O(n)<br>空间复杂度O(n)<br>Ps:如错误，望老师指正🤣<br><br></div> <span class="time">2018-10-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">算是个思路 不过空间复杂度高了</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e1/98/c99c6d36.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">宗子豪</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表的头结点一定是没有数据的吗?</div> <span class="time">2018-10-10</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">不一定 也可以存数据的。</p> <p class="reply-time">2018-10-11</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/d3/fb/da4aeff8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">王爷</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题根据大神留言整理的思路：找到链表“中间位置”，中间之前的反转放在一个新链表中，然后和中间位置后的链表数据比较是否相等。go 实现如下，时间复杂度O(n)<br>&#47;**<br>单向链表结构<br>*&#47;<br>type Link struct {<br>	value string<br>	next  *Link &#47;&#47;下一个节点<br>}<br>&#47;**<br>链表集合<br>*&#47;<br>type LinkList struct {<br>	node  *Link<br>	count int<br>}<br>&#47;**<br>链表中添加一个元素，新插入的再链表尾部<br>*&#47;<br>func (l *LinkList) Add(value string) {<br>	n := Link{}<br>	n.value = value<br>	if l.node == nil {<br>		l.node = &amp;n<br>	} else {<br>		node := l.node<br>		for {<br>			if node.next == nil {<br>				break<br>			} else {<br>				node = node.next<br>			}<br>		}<br>		node.next = &amp;n<br>	}<br>	l.count = l.count + 1<br>}<br>&#47;**<br>链表中添加一个元素，新插入的在链表头<br>*&#47;<br>func (l *LinkList) Enqueue(value string) {<br>	n := Link{}<br>	n.value = value<br>	if l.node == nil {<br>		l.node = &amp;n<br>	} else {<br>		node := l.node<br>		n.next = node<br>		l.node = &amp;n<br>	}<br>	l.count = l.count + 1<br>}<br>&#47;**<br>判断存储的是否是回文字符串<br>*&#47;<br>func (l *LinkList) IsPadlindrome() bool {<br>	boolean := false<br>	current := l.node<br>	if l.count == 0 {<br>		return false<br>	} else if l.count == 1 {<br>		return true<br>	} else if l.count == 2 {<br>		return current.value == current.next.value<br>	} else {<br>		&#47;&#47;找到链表“中间位置”<br>		p := 1<br>		&#47;&#47;“中间位置”之后的节点<br>		var rightLink *Link<br>		&#47;&#47;“中间位置”之前的元素要逆序放入新链表中<br>		var leftlink = LinkList{}<br>		&#47;&#47;参考留言中的快进慢进法<br>		for {<br>			leftlink.Enqueue(current.value)<br>			current = current.next<br>			rightLink = current<br>			p = p + 2<br>			if p == l.count {<br>				&#47;&#47;长度是奇数，中间节点的元素不参与比较，直接从中间节点的下一个节点开始<br>				rightLink = rightLink.next<br>				break<br>			} else if p &gt; l.count {<br>				break<br>			}<br>		}<br>		&#47;&#47;比较两个链表中的值是否相等<br>		var l1 = leftlink.node<br>		var l2 = rightLink<br>		for {<br>			if l1 == nil {<br>				break<br>			} else {<br>				if l1.value == l2.value {<br>					l1 = l1.next<br>					l2 = l2.next<br>					boolean = true<br>				} else {<br>					boolean = false<br>					break<br>				}<br>			}<br>		}<br>	}<br>	return boolean<br>}<br>func main() {<br>	list := LinkList{}<br>	list.Add(&quot;5&quot;)<br>	list.Add(&quot;0&quot;)<br>	list.Add(&quot;1&quot;)<br>	list.Add(&quot;1&quot;)<br>	list.Add(&quot;0&quot;)<br>	list.Add(&quot;5&quot;)<br>	fmt.Println(list)<br>	fmt.Println(list.IsPadlindrome())<br>}</div> <span class="time">2018-10-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/d8/74/399c5d99.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">꧁꫞꯭高꯭峰꯭꫞꧂</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">public static boolean isBackWord(String str) {<br>		boolean flag = true;<br>		String[] arrs = str.split(&quot;&quot;);<br>		int len = arrs.length;<br>		if (str.length() % 2 != 0) {<br>			for (int i = 0; i &lt; len; i++) {<br>				if (!arrs[i].equals(arrs[len - 1 - i])) {<br>					flag = false;<br>					break;<br>				}<br>			}<br>		} else {<br>			flag = false;<br>		}<br><br>		return flag;<br>	}<br>时间复杂度O(n&#47;2);</div> <span class="time">2018-10-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">木子皿</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于如何用数组实现LRU写了一篇博客：https:&#47;&#47;blog.csdn.net&#47;SlowIsFastLemon&#47;article&#47;details&#47;82985685</div> <span class="time">2018-10-10</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/bd/b5/b8dfa30a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">双</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">对于cpu对数组的缓存问题，高级语言如java，生成一个对象数组，数组里面保存了大对象，这个时候和cpu缓存就没关系了吧？这些大对象数组读到cpu的cache中还是连续的吗</div> <span class="time">2018-10-09</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">不是。但是那是因为java语言本身的特性 数组中存储的是对象的地址 并非对象本身 虽然对象是非连续的 没法利用cpu缓存 但地址在数组中是连续存储的 可以利用cpu缓存。你也可以去看下c语言 处理方式就跟java不一样</p> <p class="reply-time">2018-10-10</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/5f/a1/8f91ec43.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">weirdo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">请问回文串一定得是奇数吗？ 如果偶数也可以的话 那用快慢指针法怎么才能到中点呢？偶数长度的字符串中点没有元素 该怎么处理呢？</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/2e/44/b6f5b1fd.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">园园</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">用链表实现LRU，那么链表中的节点存的是什么数据呢？</div> <span class="time">2018-10-09</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">这个不好说 你可以直接存要缓存的对象 也可以存对象的地址 比如指针或者引用</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/0c/c2/310f15a4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Geek_zy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师您好 我刚才问的那个的问题意思就是。单双向链表的基地址存储的位置分别在头节点的那个位置。     </div> <span class="time">2018-10-09</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">哦哦哦 应该需要另一个指针来存储 文章里描述的不清楚</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/4c/06/634b7db7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">IT蛇精病</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">LRU就是淘汰算法，在计算机的高速缓存中有具体实现。在之前已接触过这方面的问题。基于局部性原则，时间局部性和空间局部性，时间局部性说的是一个数据被访问，那么在一定时间内可能会被频繁访问，空间局部性说的是一个数据被访问到，那么附近的空间在一段时间内也会可能频繁被访问。</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/25/9e/69b65b6f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">一棵开花的树</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">总结的一篇博客，用python实现的，仅供参考：https:&#47;&#47;blog.csdn.net&#47;phyllisyuell&#47;article&#47;details&#47;82974345</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/01/ce/4bd67683.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Stephan.Wang</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如何判断回文字符串。<br>读首节点和尾节点，两种情况<br>1.相等 --&gt; 删除首尾节点，继续读下一组首尾节点<br>2.不想等 --&gt; 判断不是回文字符串<br><br>一直读到单链表长度为1</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/49/b8/fb19aa6a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">yaxin</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">链表与数组的最大区别是，链表支持动态扩容，数组不支持。</div> <span class="time">2018-10-09</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/0c/c2/310f15a4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Geek_zy</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">双向链表的地址存在的是 头结点的前驱指针上吗？<br>单向链表的地址存的是头结点的data区吗？</div> <span class="time">2018-10-09</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">没太看懂您说的 不好意思 能重新表述一下吗</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ed/38/217ecccb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">大坏蛋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">请教老师和留言区大佬：https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo老师的Java版链表demo中，删除结点，是否需要将被删除结点next引用指向null？以便GC时可以及时清理。谢谢解答！</div> <span class="time">2018-10-08</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">不用呢 gc是分析可达性 分析的是指向这个节点的 而不是这个节点指向的</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/88/a7/cd469379.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">徐</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师， 看很多人提到用快慢指针找中点， 如果是奇数链表我能理解， 如果是偶数的回文串，怎么处理呢？ 是不是快慢指针只能用于奇数链表里？</div> <span class="time">2018-10-08</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">不啊 偶数的话大概处理思路是一样的 只会有很小的区别</p> <p class="reply-time">2018-10-09</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/04/2d/15d254d4.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">惜纸</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师你好，后进先出应该使用哪种算法？</div> <span class="time">2018-10-08</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">先进后出 和后进先出不是一个意思吗</p> <p class="reply-time">2018-10-08</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ef/1b/b2be3e68.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Durian</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表存字符串 并且判断该字符串是否是回文<br>创建第二个单链表为该链表的转置 如果该单链表的字符串是回文的话，那么转置后的单链表每个值都跟原单链表相等。如果不相等，则就不是回文<br>第一步，转置单链表<br>第二步，循环判断值是否相等<br>时间复杂度为O(n)<br>空间复杂度为O(n)</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0c/cf/022b8d3a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">詩揚</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">public class Plalindrome {<br>	public static void main(String[] args) {<br>		test(&quot;&quot;);<br>		test(&quot;1&quot;);<br>		test(&quot;123&quot;);<br>		test(&quot;123432&quot;);<br>		test(&quot;123321&quot;);<br>		test(&quot;1234321&quot;);<br>	}<br>	<br>	static void test(String s) {<br>		boolean isPlalindrome = isPlalindrome(getNodeHeadFromString(s));<br>		System.out.println(s + &quot; is plalindrome ? &quot; + isPlalindrome);<br>		System.out.println();<br>	}<br>	<br>	static boolean isPlalindrome(Node head) {<br>		System.out.print(&quot;before convert is:&quot;);<br>		print(head);<br>		<br>		if(head == null || head.next == null) {<br>			return true;<br>		}<br>		<br>		Node slow = head;<br>		Node fast = head;<br>		while(fast.next != null &amp;&amp; fast.next.next != null) {<br>			slow = slow.next;<br>			fast = fast.next.next;<br>		}<br>		<br>		Node afterHead = slow.next;<br>		&#47;&#47;反转后半部分<br>		afterHead = converse(afterHead);<br>		<br>		boolean result = true;<br>		for(<br>			Node beforeCur = head, afterCur = afterHead;<br>			beforeCur != null &amp;&amp; afterCur != null;<br>			beforeCur = beforeCur.next, afterCur = afterCur.next<br>			) {			<br>			if(beforeCur.c != afterCur.c) {<br>				result = false;<br>				break;<br>			}<br>		}<br>		&#47;&#47;反转的部分恢复<br>		slow.next = converse(afterHead);<br><br>		System.out.print(&quot;after convert is:&quot;);<br>		print(head);<br>		return result;<br>	}<br>	<br>	static Node converse(Node head) {<br>		if(head == null || head.next == null) {<br>			return head;<br>		}<br>		Node prev = null;<br>		Node cur = head;<br>		Node next = head.next;<br>		<br>		while(next != null) {<br>			cur.next = prev;<br>			prev = cur;<br>			cur = next;<br>			next = cur.next;<br>		}<br>		cur.next = prev;<br>		return cur;<br>	}<br>	<br>	static void print(Node head) {<br>		for(; head != null; head = head.next) {<br>			System.out.print(head.c);<br>		}<br>		System.out.println();<br>	}<br>	<br>	static Node getNodeHeadFromString(String s) {<br>		Node head = null;<br>		if(null == s || &quot;&quot;.equals(s)) {<br>			return head;<br>		}<br>		head = new Node(s.charAt(0));<br>		Node prev = head;<br>		for(int i = 1; i &lt; s.length(); i++) {<br>			Node cur = new Node(s.charAt(i));<br>			prev.next = cur;<br>			prev = cur;<br>		}<br>		prev.next = null;		<br>		return head;<br>	}<br>	<br>	static class Node {<br>		char c;<br>		Node next;<br>		Node(char c) {<br>			this.c = c;<br>		}<br>	}<br>}</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">SODA-M</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看到评论里面有朋友说水仙花串，如果按照对水仙花数的理解，回文串和水仙花字串好像没什么关系吧，有点困惑。不过如果所提到的解法是一种判断回文的方式</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f9/ab/374fe105.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Alan</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回复：myj：<br>您好，请问双向循环链表的最后一个节点的next指针为什么不是指向第一个节点的prev，而是指向了它的data部分，同样的，第一个节点的prev也指向了最后一个节点的data部分而不是它的next，这个图中prev的指向您是希望表达指向next指针呢？还是想表达指向整个节点对象呢？<br>---------------<br>链表中的每个节点（包括数据域，指针域）为一个整体，指针域中每个指针保存的是当前节点的上一个、下一个或更多节点的内存地址值，利用保存有地址值的指针可以定位到该地址所在的节点。因此图中箭头指向的是节点整体，而不是指向数据域或者指针域。我的理解就是这样，如果有不正确的地方还请老师指正~</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/ac/19/d6fe6ada.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">青石</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师你好，我是一名js程序员，链表和数组的区别主要是内存是否连续，增删查的复杂度区别。<br><br>对于js这类的高级语言来说，这些区别是否无法利用呢？平常编码中主要的也是堆栈这样机构。链表比较少接触到。</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ3eIjoCa5HXS3pVLX1hD7gXkmrfd51IGBqZ6Wx5SPhwS5wibzgiaYNQK7Xhpcu45EVp6hw9eZGmyeg/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">z4ul</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，课后思考题有推荐的答案吗？</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/6c/2a/43101709.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">myj</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">您好，请问双向循环链表的最后一个节点的next指针为什么不是指向第一个节点的prev，而是指向了它的data部分，同样的，第一个节点的prev也指向了最后一个节点的data部分而不是它的next，这个图中prev的指向您是希望表达指向next指针呢？还是想表达指向整个节点对象呢？</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/e3/41/b06f7ec0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">CozyThinker</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">耗时28分钟学习完毕</div> <span class="time">2018-10-08</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/Gkedlmv1ibTmUcALf69BCDhg5j0CGtqxaHHtpnbWc6yF8Wld7ILmgoScJtk4QiblfqoUJl9jyNhjgib9aEBGlIh8Q/132" class="avatar">
<div class="info">
	<div class="hd"><span class="username">韩某众</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">https:&#47;&#47;github.com&#47;TieChi&#47;aboutAlgs&#47;blob&#47;master&#47;linkedList.js<br>本节内容的js实现，望批评指正。</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/35/15/0b7de6b0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Veigar</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">def determine(str):<br>    str_01 = list(str)<br>    str_02 = list(str)[::-1]<br>    for i in range(0, len(str) &#47; 2):<br>        if str_01[i] != str_02[i]:<br>            return False<br><br>    # print str_02<br>    return True<br><br><br>if __name__ == &#39;__main__&#39;:<br>    str = raw_input(&#39;请输入判定字符串：&#39;)<br>    print &#39;是否为回文字符串：&#39;, determine(str)</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f9/90/f90903e5.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">SyndromePolynomial</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">用数组实现LRU缓存淘汰算法<br>能不能用空间换时间呢，就是维护另一个和原数组同样大小的数组，就叫做权重数组吧。<br>当一个新的数据被访问时：<br>1. 此数据之前已经被缓存在数组中了：<br>访问到的数据所对应的权重数组对应下标的权重变为0。如果数组是满的，填充过数据但此次未被访问到的数据权重加1；如果不满，没有填充数据的数组的权重还是为0，填充过数据但此次未被访问到的数据权重加1<br>2. 数据之前未被缓存<br>数组未满：寻找一个没有填充数据的位置，填入数据，权重为0；填充过数据但此次未被访问到的数据权重加1<br>数组已满：删除权重最大的，填入数据，权重为0；填充过数据但此次未被访问到的数据权重加1<br><br></div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0f/a8/51ea44ec.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">毛玉娇</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回文字符串判断（前提单链表实现）：可以采用新建链表，单用链表前插的方式，遍历新建后的链表拼接成新的字符串，若两个字符串相同则为回文字符串</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/8b/ee/49ba9142.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">王虹凯</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">空间换时间：数据库索引、缓存<br>时间换空间：jms消息中间件</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/9a/c9/20239acc.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Haoz</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">什么是链表？<br>链表是一种不需要一块连续的内存空间，通过「指针」将一组零散的内存块串联起来使用的数据结构<br><br>最常见的链表结构<br>单链表：每个链表的节点除了存储数据之外，还需要记录链上的下一个结点的地址<br><br>循环链表：与单链表唯一的区别就在于尾结点，循环链表的尾结点指针指向链表的头结点，像一个环一样首尾相连<br><br>双向链表：支持两个方向，每个结点不止有后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点 <br><br>双向链表的优点<br>- 删除给定指针指向的结点时，时间复杂度为 O( 1 )<br>- 对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些<br><br>链表和数组的性能对比<br>- 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读<br><br>- 数组的缺点是大小固定，一申明就要占用整块连续内存空间。如果申明的数组过大， 系统可能没有足够的连续内存空间分配给它，导致「内存不足」。如果申明的数组过小，可能出现不够用的情况，这时只能再申请一个更大的内存空间， 把原数组拷贝进去，非常耗时，而链表本身没有大小的限制，天然地支持动态扩容，这也是它和数组最大的区别<br><br>- 如果代码对内存的使用非常严苛，则数组更加合适，因为链表中的每个结点都需要消耗额外的存储空间来存储指向下一个结点的指针。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片<br><br>如何基于链表实现 LRU 算法？<br>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的，当有一个新的数据被访问时，从链表头开始顺序遍历链表<br><br>1、如果此数据已经被缓存在链表中，遍历链表得到这个数据对应的结点，并将其从原来的位置删除，然后插入到链表的头部<br><br>2、如果此数据没有在缓存链表中，可分为两种情况<br>- 如果此时缓存未满，则将此结点直接插入到链表的头部<br>- 如果缓存已满，则将尾部的结点删除，将新的数据结点插入链表的头部</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/1c/8e/e54277e1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">思韬</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组实现LRU<br>可以动态调整数组的开端，这样在保证数组连续性的时候可以选择移动数组的前端还是后端来减少开销。<br>1)如果未找到元素，则将新元素放在队头之前一位，并将其下标设置成数组开端的。如果原数组的开端为0下标，新的数组开端则为[n-1]。<br>1.1)如果数组已满，即从开端开始找了一圈之后又回到开端，则将新的元素放入队头前一位，即覆盖队尾元素，实现去除LRU元素。<br>2)如果在队列前半段找到元素，可以将其之前的元素往后移一位，然后将其放入队列开端。此时队列开端不变。<br>3)如果在队列后半段找到元素，可以将其之后元素往前移一位，然后将其放入队头前一位，并将其下标设置为新的数列开端。<br>总结：该方法保证数组移动的最大开销为n&#47;2。且若经常有新元素加入时，无需移动数组任何元素，仅移动队头的标记。</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/1f/b3/552c35f2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">MARS</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表的删除似乎不用重新遍历寻找指定节点的前一个节点，只需要使用一个指针变量在寻找删除节点的同时存下上一个节点的指针就好了</div> <span class="time">2018-10-07</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">SunshlnW</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">双向链表的优势那块，单链表的删除可以通过<br>p.setData(p.getNext().getData());<br>p.setNext(p.getNext().getNext());<br>来实现。<br>单链表的插入可以通过如此赋值来实现。<br>这个时候复杂度就是O（1）了</div> <span class="time">2018-10-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/37/e0/23f288ae.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">周平</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看到留言中，使用快慢指针的方法，解决 单链表判断是否 回文字符串的问题，很受启发。<br><br>同时，<br><br>JK David的思路，修改了 单向链表的存储内容，这个不太好吧。<br><br>兆甲 使用快慢指针的方法，我觉得是合理的。他通过 动态步长 来移动指针， 对比两组指针对应的元素是否一致来判断是否回文字串。</div> <span class="time">2018-10-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">王振华 程序员 区块链</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">“我们习惯性地把第一个结点叫做头结点，把最后一个结点叫做尾结点。其中，头结点用来记录链表的基地址。”这段话中的最后一句是不是有错误？<br>应该是“头指针用来记录链表的基地址”吧？头结点中应该记录的是下一个结点的内存地址呀？</div> <span class="time">2018-10-06</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">头结点对应的内存地址是基地址。头结点中的next指针记录的是下一个结点的地址。</p> <p class="reply-time">2018-10-06</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/f2/90/e3e19c6e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">0xFFFFFFFF</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">Java解法<br>```java<br>class Node {<br>    char val;<br>    Node next;<br>}<br>boolean fastAndSlowPointer(Node node) {<br>        if (node == null) {<br>            return false;<br>        }<br>        if (node.next == null) {<br>            return true; &#47;&#47; 定义单节点返回true<br>        }<br>        Node fast = node.next;<br>        Node slow = node;<br>        Node prev = null; &#47;&#47; slow指针的前驱节点，用来反转指针<br>        while (fast != null) {<br>            Node next = slow.next;<br>            slow.next = prev;<br>            prev = slow;<br>            slow = next;<br>            fast = fast.next;<br>            if (fast != null) {<br>                fast = fast.next;<br>                if (fast == null) {<br>                    &#47;&#47; 说明链表有奇数个节点(因为此时fast节点是第2n位置的节点，单是为null)<br>                    &#47;&#47; slow指针跳过最中间节点。奇数长度回文一定是中间节点两边对称<br>                    slow = slow.next;<br>                }<br>            }<br>        }<br>        while (prev != null) {<br>            if (prev.val != slow.val) {<br>                return false;<br>            }<br>            prev = prev.next;<br>            slow = slow.next;<br>        }<br>        return slow == null;<br>    }<br>```</div> <span class="time">2018-10-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/fc/43/3438409b.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Wayne</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组实现LRU:<br>数据元素定义为｛data,valid｝，<br>插入元素时，如果数组未满，头与尾-1个元素间存在这个元素都标记为invalid，然后将元素插入到数组的尾部，尾部相同则不重复添加。如果数组满，则触发数组清理，然后同上。<br>数组清理，倒序遍历数组，如遇invalid元素则计算连续最大的invalid个数，再将后面的元素前移相应步数。如果没有invalid，则整体向前移动适当数量的步数。<br><br>集中清理，优化效率。</div> <span class="time">2018-10-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/3e/78/0654bcc1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Wy 🐠</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">这一章内容配上leetcode里LRU那道设计题，以及题解就更直白啦</div> <span class="time">2018-10-06</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">勤劳的小胖子-libo</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">乍一想来，直接双向链表，二个指针，一个指头向后，一个指尾向前，对指向的值一一比较，到都指向null，表示相同。时间复杂度，O(n)遍历，空间复杂度是O(1)，保存二个指针。<br>但应该有优化的方法，结束的条件应该可以优化。</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">张飞online</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">其实链表还好，一个链表加多线程操作，再加性能优化，也就是你加锁的粒度不能太大，要到链表里面加</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">明翼</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">几个问题请教下：1.单项链表用一个变量保存前一个节点，删除时候应该和双向链表时间复杂度一样啊。<br>2.&quot;当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；&quot;这个是有问题的，如何知道访问数据不在链表中，这本身也需要一次遍历。<br><br>至于回文问题，用一个双向链表表示，从头到尾遍历再返回来遍历得到的字符串比较即可</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">智慧树叶</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">课后思考:可以用双链表，先将字符串单个写入双链表，然后取中间节点向两头发散比较是否相等。核心算法的时间复杂度的话是O(n)。</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ea/b7/1f7316e6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">wean</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组简单易用，在实现上是使用连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中不是连续存储，对 CPU 缓存不友好，没办法有效预读。<br><br>但数组的特点也是它的不足，他的内存空间是固定的，如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致内存不足(out of memory)，例如如果现在系统由 100M 不连续的内存空间，声明 100M 数组就会失败，另外到数组扩容时，复制原数组的内容到新数组也很费时。这就是数组和链表最大的区别。<br><br>另外如果我们的代码对内存使用非常苛刻，那应该使用数组，比如安卓之类的，因为链表需要维护额外的空间去存储指针。而且对链表进行频繁的插入、删除操作，还对导致频繁的内存申请和释放，容易造成内存碎片。如果是 Java 语言，就可能导致频繁的 gc。</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/3c/5f/cc30c10c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">liu</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">##数据结构与算法<br><br>###第五课，链表上（Linked List）<br><br>#### 开篇题目，如何实现LRU的缓存淘汰算法<br>1、缓存算法：一种高性能的数据读取技术，如CPU缓存，数据库缓存，浏览器缓存<br>2、三种缓存淘汰策略：先进先出（FIFO），最少使用策略（LFU），最近最少使用车策略（LRU）<br><br>#### 链表和数组的底层存储结构<br>1、数组需要一组连续的内存空间存储，如果连续的内存不够，则申请失败，对内存要求较高<br>2、链表则与数组相反，它不需要连续的内存空间，它是将一组零散的内存块组合起来使用，只要内存足够，都可以申请<br>    支持动态扩容。<br><br>#### 链表结构<br><br>##### 单链表<br>1、内存块，即链表节点，用来存储数据和下一个节点指针next<br>2、头结点和尾节点（NULL）比较特殊<br>3、支持插入（O(1)）、删除（O(1)）、查找（O（n)）等操作<br><br>##### 循环链表<br>1、循环链表是一种特殊的单链表，首尾相连的<br>2、优点：从尾到头遍历方便，在处理的数据有环形结构特点的时候适用，如约瑟夫问题<br><br>##### 双向链表<br>1、不仅包含后继指针next，还有前驱指针prev<br>2、支持双向遍历，灵活性高<br>3、删除操作<br>    1、删除节点中“某个值等于指定值“的节点，算法时间复杂度为O(n)<br>    2、删除某个指针指向的节点，可以根据前驱节点直接获取前一个指定，无需从头遍历，性能要比单链表高，<br>        算法时间复杂度为O(1)<br>4、查询操作，对于无序的数据来说，效率跟单链表一样为O(n)，如果数据为有序的，平均只需要查找一半的数据        <br><br>##### 双向循环链表<br>1、双向链表差不多，区别在于首尾节点相连<br><br>#### 设计思想<br>1、用空间换取时间的设计思想，如果内存足够，但追求代码的执行速度的时候，可选择空间复杂度高、时间复杂度低的<br>    的算法或数据结构。<br>2、用时间换取空间的设计思想，如果内存吃紧，则选择空间复杂度低，时间复杂度高的算法或数据结构<br>3、缓存技术就是用了空间换取时间的设计思想<br><br>#### 链表数组性能对比<br>1、数组，插入删除（O（n）），随机访问（O（1））<br>2、链表，插入删除（O（1）），随机访问（O（n））<br><br>#### 开篇解答，基于链表实现LRU缓存算法<br>1、维护一个单链表，越靠近尾节点则表示越早之前访问，如果有数据来，则先遍历后插入<br>2、判断此数据是否已经在链表中<br>    1、如果已经在缓存链表中了，先把数据取出来然后放到链表头<br>    2、如果不在在缓存链表中，则判断缓存链表是否已满<br>        1、如果已满，则把最后一个剔除，然后把新数据放到头结点<br>        2、如果未满，则直接把新数据放到头结点<br>3、此缓存算法时间复杂度O(n)<br>4、优化思路，使用散列表记录每个数据的位置，降低缓存访问时间<br><br>#### 开篇解答，基于数组的LRU缓存算法的实现<br>1、维护一个数组，越靠近尾部则表示越早之前访问，如果有数据来，则先遍历后插入<br>2、判断此数据是否已经在数组中<br>    1、如果已经在缓存链表中，先把数据取出来，然后把之前的数据往后搬移一位，最后把刚才取出的数据放到头<br>    2、如果不在在缓存链表中，则判断缓存链表是否已满<br>        1、如果已满，则把最后一个剔除，然后把之前的数据往后搬移一位，最后把数据放到头<br>        2、如果未满，先把所有数据往后搬移一位，然后把新数据放到头结点<br>3、此缓存算法时间复杂度O(n)（查找O(n)，数据搬移O(n)），因为涉及数据搬移，所以该算法比基于链表的效率低<br><br>#### 课后思考，基于单链表的回文字符串判断<br>1、声明两个指针a，b，指向链表头结点<br>2、a，b指针向前移动，a每次移动一格，b每次移动两个，直到b为null或者b.next为null，此时a的位置恰好在链表中间<br>3、使用栈c存储每次a指针指向的节点<br>4、循环结束<br>5、接着b指针继续向前移动，栈c弹栈并且跟b节点值比较<br>6、如果不相等则循环结束，说明不是回文字符串返回false<br>7、否则继续5、6步骤，直到b.next为null<br>8、是回文字符串，返回true</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/af/ce/d7ae8da9.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">学渣！！！</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题采用快慢指针：<br>public static boolean isPalindrome(Node head){<br>        Node pre = null;<br>        Node slow = head;<br>        Node fast = head;<br>        while(fast != null &amp;&amp; fast.next != null){<br>            fast = fast.next.next;<br>            Node next = slow.next;<br>            slow.next = pre; &#47;&#47;把slow的下一个节点指向pre,使前半段节点反序<br>            pre = slow;<br>            slow = next;<br>        }<br><br>        &#47;&#47;当是奇数个元素时，slow要跳过最中间过素<br>        if(fast != null){<br>            slow = slow.next;<br>        }<br><br>        while(slow != null){<br>            if(slow.data != pre.data){<br>                return false;<br>            }<br>            slow = slow.next;<br>            pre = pre.next;<br>        }<br>        return true;<br>    }<br><br>    public static void main(String[] args) {<br>        Node node1_1 = new Node(&quot;n&quot;);<br>        Node node1_2 = new Node(&quot;o&quot;);<br>        Node node1_3 = new Node(&quot;o&quot;);<br>        Node node1_4 = new Node(&quot;n&quot;);<br>        node1_1.next = node1_2;<br>        node1_2.next = node1_3;<br>        node1_3.next = node1_4;<br>        node1_4.next = null;<br>        System.out.println(isPalindrome(node1_1));<br><br><br>        Node node2_1 = new Node(&quot;l&quot;);<br>        Node node2_2 = new Node(&quot;e&quot;);<br>        Node node2_3 = new Node(&quot;v&quot;);<br>        Node node2_4 = new Node(&quot;e&quot;);<br>        Node node2_5 = new Node(&quot;l&quot;);<br>        node2_1.next = node2_2;<br>        node2_2.next = node2_3;<br>        node2_3.next = node2_4;<br>        node2_4.next = node2_5;<br>        node2_5.next = null;<br>        System.out.println(isPalindrome(node2_1));<br>    }<br><br>    static class Node {<br>        private String data;<br>        private Node next;<br><br>        public Node(String data) {<br>            this.data = data;<br>        }<br>    }<br>因为没有额外增加内存所以空间复杂度为O(1),时间复杂度为O(n)<br>老师，想问下你文章里的图用什么画图工具完成的</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/df/a3/7b36b257.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Nuko</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">将单链表反转，时间O（n），在对两条链表遍历比较，时间O（n）</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/ce/7b/fa0f9368.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">刘十一</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">思考题：利用链表判断一个字符串是否是回文，基本思想就是首尾进行对比，时间复杂度是O(n)，老师可不可以往后将思考题的答案或者说您的思路，在下一篇文章中提供出来呢？</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="" class="avatar">
<div class="info">
	<div class="hd"><span class="username">code047</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">打卡</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">SunshlnW</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组实现LRU：可以采用“空间换时间”策略，申请足够大内存的数组，然后定义一个变量count记录位置，count位置的数字代表最近最久未使用的数据，定义一个标志Nan，表示数据为Nan的这个位置被置换过。从数组起始位置开始存放数据。<br>1）当缓存区没有满时，直接放入数组，需要置换的数据被置为Nan，被置换的数据加入数组。<br>2）当缓存区满的时候，利用count记录最近最久未使用的数据，如果该位置数据被置换，则count后移一位。如果不是该位置被置换，则被置换的数据被置为Nan，被置换的数据放加入数组。<br>思考：<br>https:&#47;&#47;wizardforcel.gitbooks.io&#47;the-art-of-programming-by-july&#47;content&#47;01.04.html<br>1、首先利用快慢指针找到单链表中间结点点，同时将链表的前半部分逆序<br>2、利用中间结点指针和头结点指针判断链表前半部分和后半部分是否相等。</div> <span class="time">2018-10-05</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/09/33/57757a23.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小苏饼</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">LRU这个缓存淘汰算法能不能用优先队列呢？</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">这个貌似不行，你可以说说你的思路：）</p> <p class="reply-time">2018-10-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f0/33/7eea7af1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">blacksmith</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">用数组实现LRU缓存淘汰算法思路：<br>维护一个数组，在数组中越靠前位置的数据是越早之前访问的。当有一个新的数据被访问时，我们从数组的0位置开始循环遍历数组。<br>1.如果此数据已经在缓存的数组中，我们遍历得到这个数据对应的位置，将其从原位置删除，后续位置的数组往前移动一个内存单元，然后将被访问的数据存储在数组的末尾。<br>2.如果此数据没有在缓存数组中，将其添加到数组的末尾，如果缓存已满，则将此数据存储在数组的开始位置（0位置）。</div> <span class="time">2018-10-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/53/73/27d1d70c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">dead_lock</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">不理解链表删除为什么是O(1)，因为单向链表删除需要找到前驱节点复杂度为O(n)，谢谢老师解答</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">删除是O(1)是有前提的，就是已经知道前驱结点的情况下，删除是O(1)。</p> <p class="reply-time">2018-10-05</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/e7/e1/2e27eabf.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Flying</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">『在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：<br>删除结点中“值等于某个给定值”的结点；<br>删除给定指针指向的结点。』<br>问题1（删除结点中值等于某个给定值的结点）是什么意思，是用空值替代吗，还是其他操作。<br>问题2:（删除给定指针指向的结点），比如删除中间的一个结点，是不是应该这样操作:把前一个的next指向后一个的previous，这样就相当于删除了中间的结点了。<br>希望老师解答一下。</div> <span class="time">2018-10-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f6/32/c9d8fd60.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Snail</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如果链表中3个连续的元素A,B,C，删除元素B，只需要将A的next设置为C即可，对吗？B会自动被垃圾回收吗？</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">java语言可以的，但是其他语言，比如C语言，要程序员自己free这块内存空间</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/0f/0e/83f56320.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">仲毅</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">雖然要花點時間了解，但是對準備考研也是很有用處的!</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">嗯嗯</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/49/b8/fb19aa6a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">yaxin</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数组，查找方便，插入删除不方便。<br>链表，插入删除方便，查找不方便。<br>链表是以空间换时间，因为链表指针也要存储。如果对空间要求比较高的程序，优先考虑数组。<br><br><br></div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">是的</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/fa/92/3c6a224c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">A.....</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师,快点更啊,等不及了</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">每周三篇 已经有同学跟不上了！你这种尖子生就迁就一下吧：）</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/10/8d/80959fd8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">煜</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表删除指针指向的节点的时候，为什么不用p-&gt;next-&gt;next来判断是不是为要删除的节点呢？这样就不用找到相应的前驱节，时间复杂度和双链表一样的</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我这里的前提是指针已经指向要删除的结点了。所以没法通过p-&gt;next来判定是否是要删除的结点了。你可能会问，指针是怎么指向要删除结点的呢？这个等到我们讲到散列表的时候，会有相应的一个例子。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/10/8d/80959fd8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">煜</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表删除指针指向的节点的时候，为什么不用p-&gt;next-&gt;next来判断是不是为要删除的节点呢？这样就不用找到相应的前驱节，时间复杂度和双链表一样的</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我这里的前提是指针已经指向要删除的结点了。所以没法通过p-&gt;next来判定是否是要删除的结点了。你可能会问，指针是怎么指向要删除结点的呢？这个等到我们讲到散列表的时候，会有相应的一个例子。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/eb/31/96b76ca8.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">起点·终站</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回文的那个，for循环倒序插入一个新数组在判断相等，所以是O(n)………有现成的方法reverse()</div> <span class="time">2018-10-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/14/97/127aaa7c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">假装在火星</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">单链表判断是否为回文字符串，最直接的思路就是从字符串两端开始判断，首先是第一个字符与最后一个字符，依次判断所有字符串，如果出现一次不相等，那么就能得出结论。<br>Python代码实现如下：<br>(篇幅限制，没有注释，另外代码只给出了用到的方法，完整代码见https:&#47;&#47;github.com&#47;linsanityHuang&#47;python_data_and_algorithms&#47;blob&#47;master&#47;Reverse_String.py)<br>单向链表实现：<br>class Node(object):<br>	def __init__(self, value=None, next=None):<br>		self.value, self.next = value, next<br>class LinkedList(object):<br>	def __init__(self, maxsize=None):<br>		self.maxsize = maxsize<br>		self.root = Node()<br>		self.tailnode = None<br>		self.length = 0<br><br>	def __len__(self):<br>		return self.length<br>	<br>	def append(self, value):<br>		if self.maxsize is not None and len(self) &gt;= self.maxsize:<br>			raise Exception(&quot;LinkedList is Full&quot;)<br>		node = Node(value)<br>		tailnode = self.tailnode<br>		# 还没有append过，length=0，追加到root后<br>		if tailnode is None:<br>			self.root.next = node<br>		# 否则追加到最后一个节点的后边，并且更新最后一个节点是刚append的节点<br>		else:<br>			tailnode.next = node<br>		self.tailnode = node<br>		self.length += 1<br>	<br>	# 删除尾节点<br>	def pop(self):<br>		if self.root.next is None:<br>			raise Exception(&#39;pop from empty LinkedList&#39;)<br>		prevnode = self.root<br>		for curnode in self.iter_node():<br>			if curnode is self.tailnode and curnode is not self.root:<br>				value = curnode.value<br>				# 删除当前尾节点<br>				del curnode<br>				prevnode.next = None<br>				self.tailnode = prevnode<br>				self.length -= 1<br>				return value<br>			else:<br>				prevnode = curnode<br><br>	def popleft(self):<br>		if self.root.next is None:<br>			raise Exception(&#39;pop from empty LinkedList&#39;)<br>		headnode = self.root.next<br>		self.root.next = headnode.next<br>		self.length -= 1<br>		value = headnode.value<br>		<br>		# 如果删除的是尾节点，需要把尾节点置为None<br>		if self.tailnode is headnode:<br>			self.tailnode = None<br>		del headnode<br>		return value<br><br>判断是否会问字符串：<br>def is_reversed_str(word):<br>	if not isinstance(word, str):<br>		return<br>	str_linkedlist = LinkedList(maxsize=len(word))<br>       # O(n)<br>	for item in word:<br>		str_linkedlist.append(item)<br>	<br>	size = len(str_linkedlist)<br>	flag = True<br>        #O(n^2)<br>	for _ in range(size &#47;&#47; 2):<br>		if str_linkedlist.pop() != str_linkedlist.popleft():<br>			flag = False<br>			break<br>	return flag<br><br>复杂度分析：<br>O(n^2)</div> <span class="time">2018-10-04</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/53/73/27d1d70c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">dead_lock</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。<br><br>老师您好，文中单向链表删除和插入操作时间复杂度为O(1)，后面讲解中有提到 单向链表在删除指定指针节点或者删除值相等节点的时候，需要找到前驱节点，复杂度为O(n)，<br>我理解的是这两个时间复杂度都是在说明单向链表的删除，为什么一个是O(1)一个是O(n)</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">同学，你觉得应该是O(1)还是O(n)呢？或者你觉得其中哪一个不理解呢？你可以自己试着分析一下时间复杂度的。如果还不清楚，再给我留言吧。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/fa/80/f8be387d.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">途</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">链表+hash实现lru不就是jdk的LinkedHashmap么</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">不是 我后面讲到散列那节课会讲</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/96/89/9312b3a2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Vincen</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">老师，我用go语言实现了一个单链表，为什么除了增加一个数据的时间复杂度为O(1)，删改查的时间复杂度都为O(n)?</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">你说的稍微有点笼统，要具体看代码怎么写的。比如增加一个数据，是在p指针之后增加、还是之前增加、还是直接增加到链表的头部，这个时间复杂度都是不一样的。删除操作也是类似的，是删除某个指针指向的结点，还是删除值等于某个值的结点等等，要具体看的。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/e0/26/4d458ce3.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">猫头鹰爱拿铁</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">判断字符串是否为回文字符串？遍历单链表同时放到一个栈里面，然后再遍历一遍单链表，遍历的同时和栈pop出的数据对比，全都一致则说明为回文字符串。</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">方法很巧妙，不过借助了栈，空间复杂度就是O(n)了。可以想想有没有空间复杂度是O(1)的算法。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/be/31/d7386dd0.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">阿伟</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">https:&#47;&#47;github.com&#47;sunpengwei1992&#47;go_common.git<br>跟随作者讲解，所有练习会在里面用代码实现，有兴趣的可以探讨，互相学习。已经有一些实现了，大家可以看看，有不对的地方，望指正，邮箱：sunpengwei1992@aliyun.com</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">👍</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/26/88/e8098480.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">James Scott</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">王老师：您好！起初我是这样考虑的，访问单链表从链表头部开始访问的，那么越靠近链表尾部的节点应该被访问的时间越晚，刚刚看了您回复给CaiBird的留言就明白了。谢谢王老师的指点</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">嗯嗯 理解就好 🤝</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f1/2f/3ec9fcfb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">缓哟</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">一个数组，头部是最久没有访问的。当访问一个新数据的时候，遍历数组，如果存在，且内存空间没满，就删除，重新插入到后面。如果不存在，且内存空间没满，直接插入，如果满了，删除数组第一个数据，1～ n-1位置的数据前移，再插入到n-1的位置。<br>数组实现LRU，不知道对不对;-)<br><br>回文<br>如果是用循环单链表存储，那么维护一个尾指针，当尾结点和头结点相等的时候，删除这两个结点，一直这样子，当链表为空或者只有一个结点的时候，就是回文。<br>这样子行不行嘿;-)<br><br>评论里有讲双链表和栈，看题目说是用单链表</div> <span class="time">2018-10-04</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">1. 可行<br>2. 不可行</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/4b/2f/a93ff216.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">天宇星旋</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">删除给定指针指向的结点。对于这个问题，老师你文中说错了，无论是单向链表还是双向链表，其删除的时间复杂度都是O(1)。单向链表只需要将待删除结点的指针只想next→next，并将下一个结点的值赋值给待删除结点，这样就可以达到删除指定结点。替换的思想。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">我没说错，我说的前提是有一个指针指向了p结点，我现在要删除p结点，如何做？你可以看我github上的代码！同学 再认真看遍我写的文章吧</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/f1/6b/c95dab3c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">飞羽</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我的思路是与栈结合，循环遍历一次链表，并将数据压栈，由于栈先进后出的特性，相当于反转了链表的数据。<br>之后再遍历一次，依次出栈并与链表节点上的数据进行比较，如果完全相同，就说明是回文。<br><br>实现语言是JavaScript（直接用js的数组模拟栈的行为）<br>时间复杂度是O(n)<br>空间复杂度是O(n)<br><br>class Link {<br>  constructor(data, next){<br>    this.data = data;<br>    this.next = next;<br>  }<br>}<br><br>class Stack {<br>  constructor(){<br>    this.datas = []<br>  }<br>  add(data){<br>    this.datas.push(data);<br>  }<br>  get(){<br>    return this.datas.pop();<br>  }<br>}<br><br>const a = new Link(&#39;a&#39;, null);<br>let next = a.next = new Link(&#39;b&#39;, null);<br>next = next.next = new Link(&#39;c&#39;, null);<br>next = next.next = new Link(&#39;b&#39;, null);<br>next = next.next = new Link(&#39;a&#39;, null);<br><br>function isRev(link){<br>  if(!link.data || !link.next) return false;<br>  const cache = new Stack();<br>  let _link = link<br>  let i = 0;<br>  while (_link) {<br>    cache.add(_link.data);<br>    _link = _link.next;<br>  }<br>  while (link) {<br>    const data  = cache.get()<br>    if(link.data !== data){<br>      return false;<br>    }<br>    link = link.next;<br>  }<br>  return true;<br>}<br><br>console.log(isRev(a));<br></div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">小老鼠</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">1,可否总结下什么时候用数组？什么时候用链表？<br>2,对于嵌入式系统，空间比较缺乏，是不是应该用数组？但数组又要连续的空间，应该如何处理？</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">1. 你可以根据数组和链表的特点，结合业务需求来看。比如，你存储的数据需要支持排序，那用数组比较合适了。要支持快速查找，那也是数组比较合适了。如果要做频繁的删除、插入，就像举的LRU的例子，那就比较适合链表。<br>2. 这个要具体看了。如果数组申请的空间不大，内存可以满足，那就用数组吧。</p> <p class="reply-time">2018-10-04</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/25/0b/f9fc5255.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">DADDYHINS</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">我的思路比较弱智，把原本的单链表逆置，写两个指针，遍历两个链表并比较它们指向的元素是否相同，这样做的时间复杂度是O(n^2)，但是空间需求大🤔。坐等更好的解答</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/eb/dc/ae5485bb.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">PoetAndPoem</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回文问题关键在于两点:1.判断链表的中间位置2.从中间位置向两边开始依次比较是否相等。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">注意是单链表</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/98/72/0dccb3e7.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">韩</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回文字符串用双向链表。<br>从头结点和尾结点逐个删除结点。头尾相同则删除。<br>最后判断剩余链表长度是否≤1，是则是回文字符串。<br>时间复杂度O(n),空间复杂度O(n)</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">蝴蝶</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">关于数组做LRU算法,我有一个想法,就是申明一个指定长度(n)的数组,将缓存的对象按照时间顺序一一保存,同时也保存一个缓存对象操作时的索引index.当去数组中查找缓存的对象时,按照从头至尾的方向遍历,时间复杂度O(n),当有找到指定的对象时,那就直接取出.当没有找到对象时,按照index的位置,向后算一位(如果后一位不存在,那就从头开始),并将对象缓存到那个位置,然后index向后移动1位.这样的情况,就保证了index处总是新的那个.</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/36/5f/3350f4d2.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">就酱</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">一个链表节点指针每次都从头节点开始遍历链表，到达尾节点时和头节点比较值，不同则返回结果；相同则把头尾节点都删除；循环直到游走的指针节点和头节点相同。<br>时间复杂度分析：循环次数 n+(n-2)+...+(n-2k+2) 其中 k 为循环次数，最坏情况 k = n&#47;2，最好情况 1，所以平均时间复杂度 O(n)</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/ff/73/8c64ed7f.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">辰陌</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">日常打卡，总结到笔记本了，，就不打出来了，，希望各位大神踊跃发言，可以更好地给我等菜鸟解惑创造有利环境。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">旅途</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">有一些问题<br>1.如果创建不了100个对象的数组，100个对象的链表也应该创建不了吧？<br>2.关于单向链表删除的问题，删除时使用遍历找到被删除的元素，被删除的前一个就是前置节点啊，不用需要再遍历一遍了吧</div> <span class="time">2018-10-03</span>
	<div class="reply">
	<div class="reply-hd"><i class="iconfont"></i> <span>作者回复</span></div> 
	<p class="reply-content">1. 为什么呢？能说一下你的理由吗？<br>2. 嗯，对的，文章里也并没有要遍历两遍呢</p> <p class="reply-time">2018-10-03</p>
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/12/93/3470fc43.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">Mr.钧👻</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">链表，是一种线性的，一堆零散内存组成的数据结构。它删除和插入的时间复杂度是O(1)，查询的时间复杂度是O(n)。和数组正好相反。注意时间换空间，空间换时间的设计思路。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/10/b5/0813608c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">牵手约定</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">一直跟着老师的步伐走。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/9e/3a/7d70960c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">张初炼</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">暂时想到了两个办法。<br>1. 创建一个新的单向链表。遍历原有的链表，遍历过程中把每一个节点存储的字符拷贝一份并插入到新链表的头部。得到的新链表相当于是把原有链表“倒置”了。最后同时遍历两个链表并比较每个节点，如果都相同则是回文字符串，否则不是。时间复杂度是 O(n)，空间复杂度也是 O(n)。<br><br>2. 遍历原有链表从而计算节点总个数 list_len。(list_len &#47; 2) 便是这个链表的“中间位置”。再次遍历链表，进行到“中间位置”后，依次把后面所有节点“转向”，即指向 prev 而非 next。结束后从链表的头和尾同时开始再做一个遍历(只进行到“中间位置”)，比较每次访问到节点字符，如果一直相等则是回文字符串，否则不是。时间复杂度是 O(n)，空间复杂度是 O(1)。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/15/e0/bc9f556c.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">hope</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">看完了，打卡，希望老师上一些代码，个人觉得只有实践才会理解的更牢固，再就是评论区都是大神，可以多看</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/11/fa/24/e1329796.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">甘远林</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">刚查了一下什么是回文，哈哈。</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/4d/e6/e530c9ee.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">H~Z~G</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">回文这个是不是可以判断字符的右边界位置，通过递归每次二分判断呢？</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">往事随风，顺其自然</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">LRU-k算法时间复杂度和空间复杂度怎样？</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/1f/bb/c488d5db.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">刘远通</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">遍历把链表存到数组里面 然后用数组随机访问的特点 判断是否是回文？</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">一步</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">请教一个问题啊，就是当数组的内存不够用的时候，去申请新的内存，为什么不先判断是否有靠近已申请内存的连续内存呢？有的话，是不是就可以利用上数组原来申请的内存了呢？在原内存上进行扩容呢？</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/43/14/8bcb21e6.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">张岳文</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">用链表实现栈，很容易匹配这种成对出现的东西。<br>c++中的栈变量感觉就是这样的。比如int a; int b; 释放的时候就反过来release b; release a; 这不就是回文吗。还有函数调用栈。。还有xml各种成对匹配的文本格式。。<br><br>m缓存是什么。？</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/13/02/77/f307372e.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">涛</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">如果解答需要经过别的数据结构去转换单链表，我不知道这个习题的意义是什么。老师给出的存储就是单链表，难道不是思考单链表的操作去判断回文吗？</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/10/e1/08/3dc76043.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">钢</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">取中间节点，分割为两个链表，并将其中一个链表反序，然后匹配是否相等</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li><li data-v-87ffcada="" class="comment-item"><img src="https://static001.geekbang.org/account/avatar/00/12/1a/9a/7b246eb1.jpg" class="avatar">
<div class="info">
	<div class="hd"><span class="username">大可可</span>
	<div class="control">
		 <a href="javascript:;" class="btn-praise"><i class="iconfont"></i> <span>0</span></a></div>
	</div>
	<div class="bd">数据库的宽表是不是空间换时间</div> <span class="time">2018-10-03</span>
	<div class="reply">
	
	</div>
</div>
</li></ul></div></div></div></div><div id="translate-man-app" class="content-3WfBL_0" style="background-color: rgb(255, 255, 255); display: none;"><div data-v-ea0bd11e="" class="outputBox-qe9A4_0"><div data-v-ea0bd11e="" class="outputBox-3oESn_0"><span data-v-ea0bd11e="" class="outputBox-13Ovx_0"></span></div><div data-v-ea0bd11e="" class="outputBox-1GLb__0"><div data-v-ea0bd11e="" class="outputBox-onVZH_0"><img src="chrome-extension://fapgabkkfcaejckbfmfcdgnfefbmlion/static/sound.svg"            class="icon-tprjJ_0"></div></div><div data-v-ea0bd11e="" class="outputBox-2sJgr_0"></div><div data-v-ea0bd11e="" class="outputBox-17RAm_0" style="display: none;"><div data-v-ea0bd11e=""></div></div></div></div><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({        showProcessingMessages: false,        messageStyle: "none",        tex2jax: {          inlineMath: [['$','$'], ['\\(','\\)']],          displayMath: [ ["$$","$$"] ],          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a']        }      });      MathJax.Hub.Register.MessageHook("End Process", function (message) {        var eve = new Event('mathjaxfini')        window.dispatchEvent(eve)      })</script></body></html>